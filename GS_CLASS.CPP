/**********************************************************
Name: GS_CLASS
                                   
Module description: File funzioni di base per la gestione
                    delle classi di entita' 
            
Author: Roberto Poltini

(c) Copyright 1995-2015 by IREN ACQUA GAS  S.p.A

**********************************************************/


/**********************************************************/
/*   INCLUDE                                              */
/**********************************************************/


#include "stdafx.h"         // MFC core and standard components

#define INITGUID
#import "msado15.dll" no_namespace rename ("EOF", "EndOfFile") rename ("EOS", "ADOEOS")

#include <stdio.h>
#include <stdlib.h>
#include <io.h>
#include <string.h>
#include <math.h>
#include <ctype.h>

#include "rxdefs.h"   
#include "adslib.h"   
#include "adsdlg.h"
#include "aced.h"
#include "AcExtensionModule.h" // per CAcModuleResourceOverride

#include "resource.h"
#include "GSresource.h"

#include "gs_opcod.h"     // codici delle operazioni
#include "..\gs_def.h" // definizioni globali
#include "gs_error.h"
#include "gs_utily.h"
#include "gs_resbf.h"
#include "gs_list.h"
#include "gs_ase.h"
#include "gs_dbref.h"     // prototipi funzioni gestione riferimenti a db
#include "gs_user.h"
#include "gs_init.h"                  
#include "gs_netw.h"      // funzioni di rete
#include "gs_dwg.h"       // gestione disegni
#include "gs_class.h"
#include "gs_lisp.h"      // va dopo gs_class.h
#include "gs_sec.h"
#include "gs_prjct.h"     // gestione progetti
#include "gs_area.h"      // gestione sessioni di lavoro
#include "gs_thm.h"       // gestione tematismi e sistemi di coordinate
#include "gs_graph.h"
#include "gs_evid.h"
#include "gs_query.h"
#include "gs_attbl.h"     // per gestione blocchi attributi
#include "gs_find.h"      // per copia classi
#include "gs_ade.h"
#include "gs_topo.h"      // per topologia simulazioni
#include "gs_conv.h"      // per copia di gruppi
#include "gs_whip.h"      // per viste postgresql e storicizzazione


/*************************************************************************/
/*  GLOBAL VARIABLES                                                     */
/*************************************************************************/
struct Common_Dcl_main_copy_class_Struct
{
	int              new_prj;
	TCHAR            nom_cls[MAX_LEN_CLASSNAME];
	C_STRING         descr_cls;
	C_STRING         TableRef;
	C_STRING         ConnStrUDLFile;
	C_2STR_LIST      PropList;
	DataCopyTypeEnum CopyType;
	C_FAS_LIST	     fasList;
   C_GPH_INFO_LIST  GraphInfoList;
	C_PROJECT        *pOldPrj;
	C_CLASS          *cpy_cls;
	C_4INT_STR_LIST  list_class_to_visual;
	presbuf          evid_value[11];
};

struct Common_Dcl_Create_Classes_Struct
{
   int        cod_prj4create_classes;
   C_STRING   name_file4create_classes;
};


/*************************************************************************/
/* PRIVATE FUNCTIONS                                                     */
/*************************************************************************/


int gsc_save_class_sel(int cod_prj, TCHAR *filename, presbuf arg);
int gsc_load_class_sel(TCHAR *filename, int flag_prj, int *prj, C_INT_LIST *lista);

int gsc_group_from_lsp (presbuf *rb, presbuf *p);
int gsc_attrib_from_lsp (C_DBCONNECTION *pConn, int cat, int type, presbuf *rb, C_RB_LIST *list);

int gsc_readdef(C_DBCONNECTION *pConn, C_STRING &TableRef, const TCHAR *key_attrib,
                C_RB_LIST &DefaultValues);
int gsc_check_mod_attr (int prj, int cls, int sub, TCHAR *fieldname, int bit);
int gsc_check_mod_attr (int flag, int bit);
int gsc_crea_grp_tablink(C_DBCONNECTION *pConn, C_STRING &LnkTableRef);
int gsc_del_memconnect (C_NODE *pFather, int cls);
int gsc_delClassPermissions(int prj, int cls);
int gsc_del_db_conc(C_PROJECT *pPrj, int cls, int mode = ALL + 1);
resbuf *gsc_get_default_from_graph(const TCHAR *func_calc);
int gsc_del_grp_tab_link(C_DBCONNECTION *pConn, C_STRING &TableRef);
int gsc_del_db_grp_rel(C_PROJECT *pPrj, int cls);
static int Backup_gs_class(BackUpModeEnum mode, C_PROJECT *pPrj, int cls, int sub = -1);

static int is_graph_calc_to_recalc(const TCHAR *old_fun, const TCHAR *old_file,
                                   const TCHAR *new_fun, const TCHAR *new_file);

int gsc_AutomaticCreationClass(int Prj, C_STRING &ClsPathFile, 
                               C_GPH_INFO *pGphInfo, C_INFO &AlphaNumInfo);

int gsc_get_class_lock(C_RB_LIST &ColValues, C_LONG_LIST &LockedBy, int *Mode, int *State);
int gsc_GraphCharact2attriblist(_RecordsetPtr &pRs, C_ATTRIB_LIST *p_attrib_list);


//-----------------------------------------------------------------------//
//////////////////  C_CLASS_LIST  INIZIO   ////////////////////////////////
//-----------------------------------------------------------------------//


// costruttore
C_CLASS_LIST::C_CLASS_LIST(C_NODE *p_prj) : C_LIST()
   { father_prj = p_prj; }

// distruttore
C_CLASS_LIST::~C_CLASS_LIST() 
   { remove_all(); }


/*********************************************************/
/*.doc C_CLASS_LIST::get_father_prj           <external> */
/*+
  Questa funzione ritorna il puntatore al progetto padre.
-*/  
/*********************************************************/
C_NODE *C_CLASS_LIST::get_father_prj(void)
   { return father_prj; }


/*********************************************************/
/*.doc C_CLASS_LIST::set_father_prj           <external> */
/*+
  Questa funzione setta il puntatore al progetto padre.
  Parametri:
  C_NODE *p_prj;     puntatore a progetto padre
    
  Restituisce GS_GOOD in caso di successo altrimenti GS_BAD.
-*/  
/*********************************************************/
int C_CLASS_LIST::set_father_prj(C_NODE *p_prj)
   { father_prj = p_prj; return GS_GOOD; }


/*********************************************************/
/*.doc C_CLASS_LIST::search_key               <external> */
/*+
  Questa funzione cerca una classe in memoria.
  Parametri:
  int cls;      Codice della classe
  int sub;      Codice della sotto-classe
    
  Restituisce il puntatore alla classe in caso di successo altrimenti NULL.
-*/  
/*********************************************************/
C_CLASS *C_CLASS_LIST::search_key(int cls, int sub)
{
   C_CLASS *pCls;
   
   if (!(pCls = (C_CLASS *) C_LIST::search_key(cls))) return NULL;
      
   if (sub > 0)
   {
      C_LIST *pSubList; // Lista sotto-classi

      // Ritorna il puntatore alla lista delle sotto-classi
      if ((pSubList = pCls->ptr_sub_list()) == NULL) 
         { GS_ERR_COD = eGSInvClassType; return NULL; }

      // Cerca la sotto-classe solo in memoria
      if ((pCls = (C_CLASS *) pSubList->search_key(sub)) == NULL)
         GS_ERR_COD = eGSClassNotFound; 
   }
      
   return pCls;
}


/*********************************************************/
/*.doc C_CLASS_LIST::sort_for_extraction      <external> */
/*+
  Questa funzione ordina le classi per ordine di complessità cioè
  di relazione con le altre classi.
  Per esempio le classi semplici, spaghetti, simulazioni sono di 
  grado 1; i gruppi di semplici sono di grado 2; 
  i gruppi di gruppi di semplici sono di grado 3 e cosi' via.
  A parità di livello le classi vengono ordinate come segue:
  1) superfici 2) spaghetti 3) punti 4) polilinee 5) testi.

  Restituisce GS_GOOD in caso di successo altrimenti GS_BAD.
-*/  
/*********************************************************/
int C_CLASS_LIST::sort_for_extraction(void)
{
   // lista con coeff e codice classe
   // dove coeff è calcolato da livello di complessità * 100 + tipo classe
   // ordinato in modo che superfici = 1, spaghetti = 2, polilinee = 3,
   // punti = 4, testi = 5.
   C_CLASS         *pCls = (C_CLASS *) get_head();
   C_ID            *pID;
   C_INT_LONG_LIST ItemList;
   C_INT_LONG      *pItem;
   int             Prj = get_father_prj()->get_key();
   long            Coeff;

   while (pCls)
   {
      pID = pCls->ptr_id();
      if ((Coeff = 100 * gsc_get_class_ord(Prj, pID->code, pID->sub_code)) == 0)
         return GS_BAD;

      switch (pID->category)
      {
         case CAT_SIMPLEX:
            switch (pID->type)
            {
               case TYPE_SURFACE:
                  Coeff += 1;
                  break;
               case TYPE_NODE:
                  Coeff += 3;
                  break;
               case TYPE_POLYLINE:
                  Coeff += 4;
                  break;
               case TYPE_TEXT:
                  Coeff += 5;
                  break;
               default:
                  Coeff += 10;
            }
            break;
         case CAT_SPAGHETTI:
            Coeff += 2;
            break;
         default:
            Coeff += 10;
      }

      if ((pItem = new C_INT_LONG(pID->code, Coeff)) == NULL)
         { GS_ERR_COD = eGSOutOfMem; return GS_BAD; }
      ItemList.add_tail(pItem);

      pCls = (C_CLASS *) pCls->get_next();
   }

   ItemList.sort_id(); // in ordine crescente per il numero long (id) che è il coeff

   // Ordina la lista delle classi
   pItem = (C_INT_LONG *) ItemList.get_head();
   while (pItem)
   {
      pCls = (C_CLASS *) cut_key(pItem->get_key());
      add_tail(pCls);
      
      pItem = (C_INT_LONG *) pItem->get_next();
   }

   return GS_GOOD;
}

int C_CLASS_LIST::copy(C_CLASS_LIST &out)
{
	C_CLASS *new_class, *punt;

	out.remove_all();
	punt = (C_CLASS *) get_head();  
	while (punt)
	{
		if ((new_class = gsc_alloc_new_class(punt->get_category())) == NULL)
         return GS_BAD;
      punt->copy(new_class);
      out.add_tail(new_class);
	  
		punt = (C_CLASS *) get_next();
	}

	return GS_GOOD;
}


//-----------------------------------------------------------------------//
//////////////////  C_CLASS_LIST  FINE              ///////////////////////
//////////////////  C_CACHE_ATTRIB_VALUES  INIZIO   ///////////////////////
//-----------------------------------------------------------------------//


// costruttore
C_CACHE_ATTRIB_VALUES::C_CACHE_ATTRIB_VALUES(C_STRING &AttribName)
{
   set_name(AttribName.get_name());
   ListNotExisting    = false;
   UpdateableFromDA   = -1; // -1 = non inizializzato
   LispCondListLoaded = false;
}
C_CACHE_ATTRIB_VALUES::C_CACHE_ATTRIB_VALUES(C_ATTRIB *pAttrib)
{
   set_name(pAttrib->get_name());
   ListNotExisting    = false;
   UpdateableFromDA   = -1; // -1 = non inizializzato
   LispCondListLoaded = false;
}

// distruttore
C_CACHE_ATTRIB_VALUES::~C_CACHE_ATTRIB_VALUES() 
{}

int C_CACHE_ATTRIB_VALUES::get_UpdateableFromDA(void) { return UpdateableFromDA; }

C_STR_LIST *C_CACHE_ATTRIB_VALUES::ptr_AttribListDependencies(void) { return &AttribListDependencies; }


/*********************************************************/
/*.doc C_CACHE_ATTRIB_VALUES::init_UpdateableFromDA <internal> */
/*+
  Questa funzione setta il flag per sapere se l'attributo è aggiornabile 
  direttamente dalla grafica ovvero dalla lettura dell'attributo del blocco DA.
  Il flag UpdateableFromDA assumerà valore -1 quando non ancora inizializzato,
  0 se l'attributo non è aggiornabile da blocco DA e 1 se l'attributo 
  è aggiornabile da blocco DA.
  Un attributo NON è aggiornabile da blocco DA se:
  1) il suo valore è associato ad una lista di scelta a 2 colonne condizionata 
     o parametrica
  2) se almeno 1 condizione o un parametro si riferisce ad un attributo visibile 
     (uno potrebbe condizionare la lista di scelta dell'altro)
  Parametri:
  FILE *f;                       Puntatore al file di lista di scelta a 2 colonne
  bool  Unicode;                 Flag che determina se il contenuto del file è in 
                                 formato UNICODE o ANSI
  C_ATTRIB_LIST *pAttribList;    Lista degli attributi della classe
  C_STR_LIST &LispCondList;      Lista delle eventuali condizioni LISP

  Restituisce il puntatore alla coppia codice-descrizione in caso di successo 
  altrimenti NULL.
-*/  
/*********************************************************/
void C_CACHE_ATTRIB_VALUES::init_UpdateableFromDA(FILE *f, bool Unicode, C_ATTRIB_LIST *pAttribList,
                                                  C_STR_LIST &LispCondList)
{
   C_ATTRIB *pAttrib;

   if (!AttribListDependenciesLoaded)
      if (init_AttribListDependencies(f, Unicode, pAttribList, LispCondList) == GS_BAD)
         return;

   pAttrib = (C_ATTRIB *) pAttribList->get_head();
   while (pAttrib)
   {
      if (pAttrib->is_visible() == GS_GOOD)
         // verifico se esiste un attributo visibile che è parametro della condizione
         if (AttribListDependencies.search_name(pAttrib->get_name(), GS_BAD) != NULL)
         {
            UpdateableFromDA = 0; // attributo non aggiornabile da blocco DA
            return;
         }

      pAttrib = (C_ATTRIB *) pAttribList->get_next();
   }

   UpdateableFromDA = 1; // attributo aggiornabile da blocco DA
}


/*********************************************************/
/*.doc C_CACHE_ATTRIB_VALUES::init_AttribListDependencies <internal> */
/*+
  Questa funzione setta la lista degli attributi da cui dipende la lista di scelta
  a 2 colonne condizionata o parametrica.
  Parametri:
  FILE *f;                       Puntatore al file di lista di scelta a 2 colonne
  bool  Unicode;                 Flag che determina se il contenuto del file è in 
                                 formato UNICODE o ANSI
  C_ATTRIB_LIST *pAttribList;    Lista degli attributi della classe
  C_STR_LIST &LispCondList;      Lista delle eventuali condizioni LISP

  Restituisce GS_GOOD in caso di successo altrimenti GS_BAD.
-*/  
/*********************************************************/
int C_CACHE_ATTRIB_VALUES::init_AttribListDependencies(FILE *f, bool Unicode, C_ATTRIB_LIST *pAttribList,
                                                       C_STR_LIST &LispCondList)
{
   C_STR       *pCond;
   C_ATTRIB    *pAttrib;
   C_2STR_LIST ValueList;
   C_STRING    ConnStrUDLFile, UdlPropertiesStr, SelectStm;

   // La funzione dà per scontato che il file f si riferisca ad una lista 2 colonne
   AttribListDependencies.remove_all();

   // Scorro la lista di eventuali condizioni
   pCond = (C_STR *) LispCondList.get_head();
   while (pCond)
   {
      pAttrib = (C_ATTRIB *) pAttribList->get_head();
      while (pAttrib)
      {
         // verifico se esiste un attributo che è parametro della condizione
         if (gsc_is_param(NULL, pCond->get_name(), pAttrib->get_name()) == GS_GOOD)
            AttribListDependencies.add_tail_unique(pAttrib->get_name(), FALSE);

         pAttrib = (C_ATTRIB *) pAttribList->get_next();
      }

      pCond = (C_STR *) LispCondList.get_next();
   }

   // Scorro la lista di eventuali condizioni (cerco anche la condizione nulla)
   LispCondList.add_tail_unique(NULL);
   pCond = (C_STR *) LispCondList.get_head();
   while (pCond)
   {
      // Leggo le righe della sezione (senza leggere da DB)
      if (ValueList.load(f, _T(';'), pCond->get_name(), false, Unicode) == GS_BAD) 
         return GS_BAD;

      // Se le righe lette contengono il collegamento ad un DB
      if (gsc_is_C_2STR_LIST_referred_to_DB(ValueList, ConnStrUDLFile, 
                                            UdlPropertiesStr, SelectStm))
      {
         C_2STR_LIST    UDLProperties;
         C_DBCONNECTION *pConn;
         C_STR_LIST     ParamList;

         if (gsc_path_exist(ConnStrUDLFile) == GS_GOOD)
            // se si tratta di un file e NON di una stringa di connessione
            if (gsc_nethost2drive(ConnStrUDLFile) == GS_BAD) return GS_BAD; // lo converto

         if (UdlPropertiesStr.len() > 0)
         {
            // Conversione path UDLProperties da assoluto in dir relativo
            if (gsc_UDLProperties_nethost2drive(ConnStrUDLFile.get_name(),
                                                UdlPropertiesStr) == GS_BAD)
               return GS_BAD;
            if (gsc_PropListFromConnStr(UdlPropertiesStr.get_name(), UDLProperties) == GS_BAD)
               return GS_BAD;
         }

         if ((pConn = GEOsimAppl::DBCONNECTION_LIST.get_Connection(ConnStrUDLFile.get_name(), 
                                                                   &UDLProperties)) == NULL)
            return GS_BAD;

         if (pConn->GetParamNames(SelectStm, ParamList) == GS_GOOD && 
             ParamList.get_count() > 0)
         {
            pAttrib = (C_ATTRIB *) pAttribList->get_head();
            while (pAttrib)
            {
               // verifico se esiste un attributo che è parametro della
               // istruzione SQL
               if (ParamList.search_name(pAttrib->get_name(), FALSE))
                  AttribListDependencies.add_tail_unique(pAttrib->get_name(), FALSE);

               pAttrib = (C_ATTRIB *) pAttribList->get_next();
            }
         }
      }

      pCond = (C_STR *) LispCondList.get_next();
   }
   LispCondList.remove_tail();

   AttribListDependenciesLoaded = true;

   return GS_GOOD;
}


/*********************************************************/
/*.doc C_CACHE_ATTRIB_VALUES::isDependingOnAttrib <external> */
/*+
  Questa funzione controlla se la lista di scelta dipende da un
  attributo particolare (lista di scelta a 2 colonne condizionata o parametrica)
  Parametri:
  C_STRING &AttribName; Nome attributo da cui può dipendere la lista di scelta

  Restituisce true in caso di successo altrimenti false.
  N.B.: deve essere già stata eseguita la funzione init_AttribListDependencies
-*/  
/*********************************************************/
bool C_CACHE_ATTRIB_VALUES::isDependingOnAttrib(C_STRING &AttribName)
{
   return (AttribListDependencies.search_name(AttribName.get_name(), GS_BAD) != NULL) ? true : false;
}


/*********************************************************/
/*.doc C_CACHE_ATTRIB_VALUES::isListNotExisting <external> */
/*+
  Questa funzione controlla se l'attributo ha o meno una lista di scelta.
  Parametri:

  Restituisce true in caso di successo altrimenti false.
-*/  
/*********************************************************/
bool C_CACHE_ATTRIB_VALUES::isListNotExisting(void)
{
   return ListNotExisting;
}


/*********************************************************/
/*.doc C_CACHE_ATTRIB_VALUES::has_parameters  <external> */
/*+
  Questa funzione verifica se la lista dei valori è sottoposta ad almeno un parametro.
  Questo può essere sotto forma di condizione lisp oppure in forma di query sql parametrizzata.
  Serve alla funzione gsc_dd_sel_uniqueVal che nel caso ci siano parametri deve mostrare solo
  i valori codificati  senza descrizioni.
  Parametri:
  int prj;                 Codice progetto
  int cls;                 Codice classe
  int sub;                 Codice sottoclasse
  int sec;                 Codice tabella secondaria
-*/  
/*********************************************************/
bool C_CACHE_ATTRIB_VALUES::has_parameters(int prj, int cls, int sub, int sec)
{
   C_STRING           SupportFile;
   ValuesListTypeEnum FileType;
   FILE               *f;
   bool               Unicode = false;

   // vero se non esiste una lista attributi a 
   // 2 colonne associata all'attributo
   if (ListNotExisting) return FALSE;

   // Cerco il file di supporto
   if (gsc_FindSupportFiles(get_name(), prj, cls, sub, sec,
                            SupportFile, &FileType) == GS_BAD)
      { ListNotExisting = true; UpdateableFromDA = 1; return FALSE; }
   // Sono supportate solo le liste a 2 colonne
   if (FileType != TAB && FileType != REF)
      { ListNotExisting = true; UpdateableFromDA = 1; return FALSE; }

   if (!LispCondListLoaded) // se non ancora caricata
   {
      // Carico la lista di eventuali condizioni GEOlisp
      if ((f = gsc_open_profile(SupportFile, READONLY, MORETESTS, &Unicode)) == NULL)
         return FALSE;
      if (gsc_get_profile(f, LispCondList, Unicode) == GS_BAD)
         { gsc_fclose(f); return FALSE; }
      gsc_fclose(f);
      LispCondListLoaded = true;
   }
   if (LispCondList.get_count() > 0) return TRUE;

   // Leggo le righe della sezione (senza leggere da DB)
   C_2STR_LIST ValueList;
   if ((f = gsc_open_profile(SupportFile, READONLY, MORETESTS, &Unicode)) == NULL)
      return FALSE;
   if (ValueList.load(f, _T(';'), NULL, false, Unicode) == GS_BAD) { gsc_fclose(f); return FALSE; }
   gsc_fclose(f);

   C_STRING ConnStrUDLFile, UdlProperties, OldSelectStm;
   if (gsc_is_C_2STR_LIST_referred_to_DB(ValueList, ConnStrUDLFile, 
                                          UdlProperties, OldSelectStm))
      if (OldSelectStm.at(_T(':')) != NULL) return TRUE; // i parametri in sql iniziano per ":"

   return FALSE;
}


/*********************************************************/
/*.doc C_CACHE_ATTRIB_VALUES::get_Descr       <external> */
/*+
  Questa funzione cerca ed eventualmente aggiunge una coppia codice-descrizione. 
  La funzione cerca prima in memoria ed eventualmente nella lista definita dalla 
  lista di scelta attributi a doppia colonna, una descrizione in base al suo codice.
  Parametri:
  C_RB_LIST &ColValues;    Lista dei valori della scheda dell'entità
  int prj;                 Codice progetto
  int cls;                 Codice classe
  int sub;                 Codice sottoclasse
  int sec;                 Codice tabella secondaria

  Restituisce il puntatore alla coppia codice-descrizione in caso di successo 
  altrimenti NULL.
-*/  
/*********************************************************/
C_2STR *C_CACHE_ATTRIB_VALUES::get_Descr(C_RB_LIST &ColValues, int prj, int cls, 
                                         int sub, int sec)
   { return get_Descr(ColValues.get_head(), prj, cls, sub, sec); }
C_2STR *C_CACHE_ATTRIB_VALUES::get_Descr(presbuf ColValues, int prj, int cls, 
                                         int sub, int sec)
{
   presbuf            pRb;
   C_STRING           SupportFile, Code, CodeForSearch;
   ValuesListTypeEnum FileType;
   FILE               *f;
   bool               Unicode = false, fromDB = true;
   C_STR              *pCond = NULL;
   C_2STR             *pDescr;

   // vero se non esiste una lista attributi a 
   // 2 colonne associata all'attributo
   if (ListNotExisting) return NULL;

   // Cerco il codice nella lista dei valori degli attributi
   if (!(pRb = gsc_nth(1, gsc_assoc(get_name(), ColValues, FALSE)))) return NULL;
   Code.paste(gsc_rb2str(pRb));
   // Scarto i codici nulli
   if (Code.len() == 0) return NULL;

   CodeForSearch = Code;

   // se le liste di condizioni lisp sono già state caricate
   if (LispCondListLoaded)
      // verifico quella valida
      if ((pCond = LispCondList.getFirstTrueGEOLispCond(ColValues)))
      {  // aggiungo un suffisso al valore di codice
         CodeForSearch += _T("-GeoLisp=");
         CodeForSearch += pCond->get_name();
      }

   // Cerco la descrizione nella lista in memoria
   if ((pDescr = (C_2STR *) m_ValuesList.search_name(CodeForSearch.get_name()))) return pDescr;

   // Cerco il file di supporto
   if (gsc_FindSupportFiles(get_name(), prj, cls, sub, sec,
                            SupportFile, &FileType) == GS_BAD)
      { ListNotExisting = true; UpdateableFromDA = 1; return NULL; }
   // Sono supportate solo le liste a 2 colonne
   if (FileType != TAB && FileType != REF)
      { ListNotExisting = true; UpdateableFromDA = 1; return NULL; }

   // Carico la lista di eventuali condizioni GEOlisp
   if ((f = gsc_open_profile(SupportFile, READONLY, MORETESTS, &Unicode)) == NULL)
      return NULL;

   if (!LispCondListLoaded) // se non ancora caricata
   {
      if (gsc_get_profile(f, LispCondList, Unicode) == GS_BAD)
         { gsc_fclose(f); return NULL; }
      LispCondListLoaded = true;
   }

   if (UpdateableFromDA == -1) // non inizializzato
   {
      C_ATTRIB_LIST *pAttribList = NULL;

      if (sec > 0)
      {  // cerco la lista degli attributi della tabella secondaria
         C_SECONDARY *pSec;
         
         if ((pSec = gsc_find_sec(prj, cls, sub, sec)) == NULL) 
            { gsc_fclose(f); return NULL; }
         pAttribList = pSec->ptr_attrib_list();
      }
      else
      {
         C_CLASS *pCls;

         if ((pCls = gsc_find_class(prj, cls, sub)) == NULL) 
            { gsc_fclose(f); return NULL; }
         pAttribList = pCls->ptr_attrib_list();
      }

      if (pAttribList)
      {
         init_UpdateableFromDA(f, Unicode, pAttribList, LispCondList);
         init_AttribListDependencies(f, Unicode, pAttribList, LispCondList);
      }
   }

   if ((pCond = LispCondList.getFirstTrueGEOLispCond(ColValues)))
      // Carico la lista di valori relativi alla sezione GEOLisp
      pDescr = gsc_C_2STR_LIST_load_by_code(f, Code.get_name(), _T(';'), 
                                            pCond->get_name(), fromDB, Unicode,
                                            ColValues);
   else
      // Carico la lista di valori di default
      pDescr = gsc_C_2STR_LIST_load_by_code(f, Code.get_name(), _T(';'), 
                                            NULL, fromDB, Unicode,
                                            ColValues);

   gsc_fclose(f);

   // Se esiste la salvo nella lista di cache
   if (!pDescr)
      pDescr = new C_2STR(CodeForSearch.get_name(), Code.get_name());
   else
      if (pCond) // se c'era una condizione lisp la memorizzo con suffisso al codice
         pDescr->set_name(CodeForSearch.get_name());

   m_ValuesList.add_tail(pDescr);

   return pDescr;
}


/*********************************************************/
/*.doc C_CACHE_ATTRIB_VALUES::get_Value       <external> */
/*+
  Questa funzione restituisce il valore eventualmente depurato dalla
  suffisso aggiunto in fase di lettura quando il valore è condizionato da
  una funzione LISP. Il suffisso consiste in "-GeoLisp=" seguito dalla
  condizione LISP che è stata soddisfatta.
  Parametri:
  C_2STR *p;   Puntatore alla coppia valore-descrizione

  Restituisce il valore in formato stringa in caso di successo altrimenti NULL.
  N.B: Alloca memoria.
-*/  
/*********************************************************/
TCHAR *C_CACHE_ATTRIB_VALUES::get_ValueWithoutSuffix(C_2STR *p)
{
   TCHAR    *pSuffix;
   C_STRING dummy;

   if (!p) return NULL;
        
   if ((pSuffix = gsc_strstr(p->get_name(), _T("-GeoLisp="))))
      dummy.set_name(p->get_name(), 0, (int) (pSuffix - p->get_name() - 1));
   else
      dummy = p->get_name();

   return dummy.cut();
}


/*********************************************************/
/*.doc C_CACHE_ATTRIB_VALUES::get_Value       <external> */
/*+
  Questa funzione cerca ed eventualmente aggiunge una coppia codice-descrizione. 
  La funzione cerca prima in memoria ed eventualmente nella lista definita dalla 
  lista di scelta attributi a doppia colonna, un codice in base alla sua descrizione.
  Parametri:
  C_RB_LIST &ColValues;    Lista dei valori della scheda dell'entità
  int prj;                 Codice progetto
  int cls;                 Codice classe
  int sub;                 Codice sottoclasse
  int sec;                 Codice tabella secondaria

  Restituisce il valore in formato stringa in caso di successo altrimenti NULL.
  N.B: Alloca memoria.
-*/  
/*********************************************************/
TCHAR *C_CACHE_ATTRIB_VALUES::get_Value(C_RB_LIST &ColValues, C_STRING &Descr,
                                         int prj, int cls, 
                                         int sub, int sec)
{
   C_STRING           SupportFile, Code;
   ValuesListTypeEnum FileType;
   FILE               *f;
   bool               Unicode = false, fromDB = true;
   C_STR              *pCond = NULL;
   C_2STR             *pDescr;

   // vero se non esiste una lista attributi a 
   // 2 colonne associata all'attributo
   if (ListNotExisting) return NULL;

   // Scarto i valori nulli
   if (Descr.len() == 0) return NULL;

   // se le liste di condizioni lisp sono già state caricate
   if (LispCondListLoaded)
      // verifico quella valida
      if ((pCond = LispCondList.getFirstTrueGEOLispCond(ColValues)))
      {  // aggiungo un suffisso al valore di codice
         Code = _T("-GeoLisp=");
         Code += pCond->get_name();
      }

   // Cerco il valore nella lista in memoria
   if ((pDescr = (C_2STR *) m_ValuesList.search_name2(Descr.get_name())))
   {
      TCHAR *p;

      // Se non c'era un suffissso di una condizione LISP
      if (Code.len() == 0) return get_ValueWithoutSuffix(pDescr);

      // devo cercare se fra le descrizioni in memoria c'è ne è una con codice
      // avente suffisso noto
      while (pDescr)
      {
         if ((p = gsc_strstr(pDescr->get_name(), Code.get_name())) && 
             p == pDescr->get_name() + gsc_strlen(pDescr->get_name()) - Code.len())
             return get_ValueWithoutSuffix(pDescr);

         pDescr = (C_2STR *) m_ValuesList.search_next_name2(Descr.get_name());
      }
   }

   // Cerco il file di supporto
   if (gsc_FindSupportFiles(get_name(), prj, cls, sub, sec,
                            SupportFile, &FileType) == GS_BAD)
      { ListNotExisting = true; UpdateableFromDA = 1; return NULL; }
   // Sono supportate solo le liste a 2 colonne
   if (FileType != TAB && FileType != REF)
      { ListNotExisting = true; UpdateableFromDA = 1; return NULL; }

   // Carico la lista di eventuali condizioni GEOlisp
   if ((f = gsc_open_profile(SupportFile, READONLY, MORETESTS, &Unicode)) == NULL)
      return NULL;

   if (!LispCondListLoaded) // se non ancora caricata
   {
      if (gsc_get_profile(f, LispCondList, Unicode) == GS_BAD)
         { gsc_fclose(f); return NULL; }
      LispCondListLoaded = true;
   }

   if (UpdateableFromDA == -1) // non inizializzato
   {
      C_ATTRIB_LIST *pAttribList = NULL;

      if (sec > 0)
      {  // cerco la lista degli attributi della tabella secondaria
         C_SECONDARY *pSec;
         
         if ((pSec = gsc_find_sec(prj, cls, sub, sec)) == NULL) 
            { gsc_fclose(f); return NULL; }
         pAttribList = pSec->ptr_attrib_list();
      }
      else
      {
         C_CLASS *pCls;

         if ((pCls = gsc_find_class(prj, cls, sub)) == NULL) 
            { gsc_fclose(f); return NULL; }
         pAttribList = pCls->ptr_attrib_list();
      }

      if (pAttribList)
      {
         init_UpdateableFromDA(f, Unicode, pAttribList, LispCondList);
         init_AttribListDependencies(f, Unicode, pAttribList, LispCondList);
      }
   }

   if ((pCond = LispCondList.getFirstTrueGEOLispCond(ColValues)))
      // Carico la lista di valori relativi alla sezione GEOLisp
      pDescr = gsc_C_2STR_LIST_load_by_descr(f, Descr.get_name(), _T(';'), 
                                            pCond->get_name(), fromDB, Unicode,
                                            &ColValues);
   else
      // Carico la lista di valori di default
      pDescr = gsc_C_2STR_LIST_load_by_descr(f, Descr.get_name(), _T(';'), 
                                             NULL, fromDB, Unicode,
                                             &ColValues);

   gsc_fclose(f);

   // Se esiste la salvo nella lista di cache
   if (!pDescr) return NULL;

   if (pCond) // se c'era una condizione lisp la memorizzo con suffisso al codice
   {
      Code = pDescr->get_name();
      Code += _T("-GeoLisp=");
      Code += pCond->get_name();
      pDescr->set_name(Code.get_name());
   }

   m_ValuesList.add_tail(pDescr);

   return get_ValueWithoutSuffix(pDescr);
}


//-----------------------------------------------------------------------//
//////////////////   C_CACHE_ATTRIB_VALUES   FINE   ///////////////////////
///////////////    C_CACHE_ATTRIB_VALUES_LIST  INIZIO     /////////////////
//-----------------------------------------------------------------------//


// costruttore
C_CACHE_ATTRIB_VALUES_LIST::C_CACHE_ATTRIB_VALUES_LIST(void)
{}

// distruttore
C_CACHE_ATTRIB_VALUES_LIST::~C_CACHE_ATTRIB_VALUES_LIST(void) 
{}


/*********************************************************/
/*.doc C_CACHE_ATTRIB_VALUES_LIST::has_parameters  <external> */
/*+
  Questa funzione verifica se la lista dei valori è sottoposta ad almeno un parametro.
  Questo può essere sotto forma di condizione lisp oppure in forma di query sql parametrizzata.
  Serve alla funzione gsc_dd_sel_uniqueVal che nel caso ci siano parametri deve mostrare solo
  i valori codificati  senza descrizioni.
  Parametri:
  C_STRING &AttribName;    Nome attributo
  int prj;                 Codice progetto
  int cls;                 Codice classe
  int sub;                 Codice sottoclasse
  int sec;                 Codice tabella secondaria
-*/  
/*********************************************************/
bool C_CACHE_ATTRIB_VALUES_LIST::has_parameters(C_STRING &AttribName,
                                                   int prj, int cls, int sub, int sec)
{
   C_CACHE_ATTRIB_VALUES *p = (C_CACHE_ATTRIB_VALUES *) search_name(AttribName.get_name());
   
   if (!p)
   {
      if (!(p = new C_CACHE_ATTRIB_VALUES(AttribName)))
         { GS_ERR_COD = eGSOutOfMem; return NULL; }
      add_tail(p);
   }

   return p->has_parameters(prj, cls, sub, sec);
}


/*********************************************************/
/*.doc C_CACHE_ATTRIB_VALUES_LIST::get_Descr    <external> */
/*+
  Questa funzione cerca una descrizione conoscendo i valori della scheda 
  dell'entità e dell'attributo di interesse e, se non già caricato in
  memoria, lo carica da file o da db.
  Parametri:
  C_STRING &AttribName;    Nome attributo
  C_RB_LIST &ColValues;    Lista dei valori della scheda dell'entità
  int prj;                 Codice progetto
  int cls;                 Codice classe
  int sub;                 Codice sottoclasse
  int sec;                 Codice tabella secondaria

  Restituisce il puntatore alla coppia codice-descrizione in caso di successo 
  altrimenti NULL.
-*/  
/*********************************************************/
C_2STR *C_CACHE_ATTRIB_VALUES_LIST::get_Descr(C_STRING &AttribName, C_RB_LIST &ColValues,
                                              int prj, int cls, int sub, int sec)
   { return get_Descr(AttribName, ColValues.get_head(), prj, cls, sub, sec); }
C_2STR *C_CACHE_ATTRIB_VALUES_LIST::get_Descr(C_STRING &AttribName, presbuf ColValues,
                                              int prj, int cls, int sub, int sec)
{
   C_CACHE_ATTRIB_VALUES *p = (C_CACHE_ATTRIB_VALUES *) search_name(AttribName.get_name());
   
   if (!p)
   {
      if (!(p = new C_CACHE_ATTRIB_VALUES(AttribName)))
         { GS_ERR_COD = eGSOutOfMem; return NULL; }
      add_tail(p);
   }

   return p->get_Descr(ColValues, prj, cls, sub, sec);
}


/*********************************************************/
/*.doc C_CACHE_ATTRIB_VALUES_LIST::get_Value  <external> */
/*+
  Questa funzione cerca un valore partendo dalla sua descrizione
  conoscendo i valori della scheda 
  dell'entità e dell'attributo di interesse e, se non già caricato in
  memoria, lo carica da file o da db.
  Parametri:
  C_STRING &AttribName;    Nome attributo
  C_RB_LIST &ColValues;    Lista dei valori della scheda dell'entità
  C_STRING &Descr;         Descrizione del valore
  int prj;                 Codice progetto
  int cls;                 Codice classe
  int sub;                 Codice sottoclasse
  int sec;                 Codice tabella secondaria

  Restituisce il valore in formato stringa in caso di successo altrimenti NULL.
  N.B: Alloca memoria.
-*/  
/*********************************************************/
TCHAR *C_CACHE_ATTRIB_VALUES_LIST::get_Value(C_STRING &AttribName, C_RB_LIST &ColValues,
                                              C_STRING &Descr, int prj, int cls, int sub, int sec)
{
   C_CACHE_ATTRIB_VALUES *p = (C_CACHE_ATTRIB_VALUES *) search_name(AttribName.get_name());
   
   if (!p)
   {
      if (!(p = new C_CACHE_ATTRIB_VALUES(AttribName)))
         { GS_ERR_COD = eGSOutOfMem; return NULL; }
      add_tail(p);
   }

   return p->get_Value(ColValues, Descr, prj, cls, sub, sec);
}


//-----------------------------------------------------------------------//
///////////////    C_CACHE_ATTRIB_VALUES_LIST    FINE     /////////////////
///////////////    C_CACHE_CLS_ATTRIB_VALUES  INIZIO     /////////////////
//-----------------------------------------------------------------------//


// costruttore
C_CACHE_CLS_ATTRIB_VALUES::C_CACHE_CLS_ATTRIB_VALUES(int prj, int cls, int sub, int sec)
{
   m_prj = prj;
   m_cls = cls;
   m_sub = sub;
   m_sec = sec;
}

// distruttore
C_CACHE_CLS_ATTRIB_VALUES::~C_CACHE_CLS_ATTRIB_VALUES(void) 
{}


/*********************************************************/
/*.doc C_CACHE_CLS_ATTRIB_VALUES::has_parameters  <external> */
/*+
  Questa funzione verifica se la lista dei valori è sottoposta ad almeno un parametro.
  Questo può essere sotto forma di condizione lisp oppure in forma di query sql parametrizzata.
  Serve alla funzione gsc_dd_sel_uniqueVal che nel caso ci siano parametri deve mostrare solo
  i valori codificati  senza descrizioni.
  Parametri:
  C_STRING &AttribName;    Nome attributo
-*/  
/*********************************************************/
bool C_CACHE_CLS_ATTRIB_VALUES::has_parameters(C_STRING &AttribName)
{
   return m_attrib_values_list.has_parameters(AttribName, m_prj, m_cls, m_sub, m_sec);
}


/*********************************************************/
/*.doc C_CACHE_CLS_ATTRIB_VALUES::get_Descr    <external> */
/*+
  Questa funzione cerca una descrizione conoscendo i valori della scheda 
  dell'entità e dell'attributo di interesse e se non giaà caricato in
  memoria lo carica da file o da db.
  Parametri:
  C_STRING &AttribName;    Nome attributo
  C_RB_LIST &ColValues;    Lista dei valori della scheda dell'entità

  Restituisce il puntatore alla coppia codice-descrizione in caso di successo 
  altrimenti NULL.
-*/  
/*********************************************************/
C_2STR *C_CACHE_CLS_ATTRIB_VALUES::get_Descr(C_STRING &AttribName, C_RB_LIST &ColValues)
{
   return m_attrib_values_list.get_Descr(AttribName, ColValues, m_prj, m_cls, m_sub, m_sec);
}
C_2STR *C_CACHE_CLS_ATTRIB_VALUES::get_Descr(C_STRING &AttribName, presbuf ColValues)
{
   return m_attrib_values_list.get_Descr(AttribName, ColValues, m_prj, m_cls, m_sub, m_sec);
}


/*********************************************************/
/*.doc C_CACHE_CLS_ATTRIB_VALUES::get_Value   <external> */
/*+
  Questa funzione cerca un valore partendo dalla sua descrizione
  conoscendo i valori della scheda 
  dell'entità e dell'attributo di interesse e se non giaà caricato in
  memoria lo carica da file o da db.
  Parametri:
  C_STRING &AttribName;    Nome attributo
  C_RB_LIST &ColValues;    Lista dei valori della scheda dell'entità
  C_STRING &Descr;         Descrizione del valore

  Restituisce il valore in formato stringa in caso di successo altrimenti NULL.
  N.B: Alloca memoria.
-*/  
/*********************************************************/
TCHAR *C_CACHE_CLS_ATTRIB_VALUES::get_Value(C_STRING &AttribName, C_RB_LIST &ColValues,
                                             C_STRING &Descr)
{
   return m_attrib_values_list.get_Value(AttribName, ColValues, Descr,
                                         m_prj, m_cls, m_sub, m_sec);
}


/*********************************************************/
/*.doc C_CACHE_CLS_ATTRIB_VALUES::get_pCacheAttribValues <external> */
/*+
  Questa funzione cerca l'istanza di un oggetto C_CACHE_ATTRIB_VALUES
  che rappresenta le proprietà cache relative ad un attributo di una classe.
  La funzione fa solo operazione di ricerca, non carica niente.
  Parametri:
  C_STRING &AttribName;    Nome attributo

  Restituisce il puntatore in caso di successo altrimenti NULL.
-*/  
/*********************************************************/
C_CACHE_ATTRIB_VALUES *C_CACHE_CLS_ATTRIB_VALUES::get_pCacheAttribValues(C_STRING &AttribName)
{
   return (C_CACHE_ATTRIB_VALUES *) m_attrib_values_list.search_name(AttribName.get_name());
}


/******************************************************************************/
/*.doc C_CACHE_CLS_ATTRIB_VALUES::get_pCacheAttribValues <external> */
/*+
  Questa funzione cancella l'istanza di un oggetto C_CACHE_ATTRIB_VALUES
  che rappresenta le proprietà cache relative ad un attributo di una classe.
  Parametri:
  C_CACHE_ATTRIB_VALUES *p;

  Restituisce GS_GOOD in caso di successo altrimenti GS_BAD.
-*/  
/******************************************************************************/
int C_CACHE_CLS_ATTRIB_VALUES::remove(C_CACHE_ATTRIB_VALUES *p)
{
   return m_attrib_values_list.remove(p);
}


//-----------------------------------------------------------------------//
///////////////    C_CACHE_CLS_ATTRIB_VALUES     FINE     /////////////////
////////////    C_CACHE_CLS_ATTRIB_VALUES_LIST   INIZIO     ///////////////
//-----------------------------------------------------------------------//


// costruttore
C_CACHE_CLS_ATTRIB_VALUES_LIST::C_CACHE_CLS_ATTRIB_VALUES_LIST(void)
{}

// distruttore
C_CACHE_CLS_ATTRIB_VALUES_LIST::~C_CACHE_CLS_ATTRIB_VALUES_LIST(void) 
{}


/*********************************************************/
/*.doc C_CACHE_CLS_ATTRIB_VALUES_LIST::search    <external> */
/*+
  Questa funzione cerca un elemento della lista conoscendo 
  la classe di interesse.
  Parametri:
  int prj;                 Codice progetto
  int cls;                 Codice classe
  int sub;                 Codice sottoclasse
  int sec;                 Codice tabella secondaria

  Restituisce il puntatore alla coppia codice-descrizione in caso di successo 
  altrimenti NULL.
-*/  
/*********************************************************/
C_CACHE_CLS_ATTRIB_VALUES *C_CACHE_CLS_ATTRIB_VALUES_LIST::search(int prj, int cls, int sub, int sec)
{
   C_CACHE_CLS_ATTRIB_VALUES *p;

   p = (C_CACHE_CLS_ATTRIB_VALUES *) get_head();
   while (p != NULL)
   {
      if (prj == p->m_prj && cls == p->m_cls && sub == p->m_sub && sec == p->m_sec)
         break;
      p = (C_CACHE_CLS_ATTRIB_VALUES *) get_next();
   }

   return p;
}


/*********************************************************/
/*.doc C_CACHE_CLS_ATTRIB_VALUES_LIST::has_parameters  <external> */
/*+
  Questa funzione verifica se la lista dei valori è sottoposta ad almeno un parametro.
  Questo può essere sotto forma di condizione lisp oppure in forma di query sql parametrizzata.
  Serve alla funzione gsc_dd_sel_uniqueVal che nel caso ci siano parametri deve mostrare solo
  i valori codificati  senza descrizioni.
  Parametri:
  C_STRING &AttribName;    Nome attributo
  int prj;                 Codice progetto
  int cls;                 Codice classe
  int sub;                 Codice sottoclasse
  int sec;                 Codice tabella secondaria
-*/  
/*********************************************************/
bool C_CACHE_CLS_ATTRIB_VALUES_LIST::has_parameters(C_STRING &AttribName,
                                                       int prj, int cls, int sub, int sec)
{
   C_CACHE_CLS_ATTRIB_VALUES *p = search(prj, cls, sub, sec);

   if (!p)
   {
      if (!(p = new C_CACHE_CLS_ATTRIB_VALUES(prj, cls, sub, sec)))
         { GS_ERR_COD = eGSOutOfMem; return NULL; }
      add_tail(p);
   }

   return p->has_parameters(AttribName);
}


/*********************************************************/
/*.doc C_CACHE_CLS_ATTRIB_VALUES_LIST::get_Descr    <external> */
/*+
  Questa funzione cerca una descrizione conoscendo i valori della scheda 
  dell'entità, dell'attributo e della classe di interesse e,
  se non già caricato in memoria, lo carica da file o da db.
  Parametri:
  C_STRING &AttribName;    Nome attributo
  C_RB_LIST &ColValues;    Lista dei valori della scheda dell'entità
  int prj;                 Codice progetto
  int cls;                 Codice classe
  int sub;                 Codice sottoclasse
  int sec;                 Codice tabella secondaria

  Restituisce il puntatore alla coppia codice-descrizione in caso di successo 
  altrimenti NULL.
-*/  
/*********************************************************/
C_2STR *C_CACHE_CLS_ATTRIB_VALUES_LIST::get_Descr(C_STRING &AttribName, C_RB_LIST &ColValues,
                                                  int prj, int cls, int sub, int sec)
   { return get_Descr(AttribName, ColValues.get_head(), prj, cls, sub, sec); }
C_2STR *C_CACHE_CLS_ATTRIB_VALUES_LIST::get_Descr(C_STRING &AttribName, presbuf ColValues,
                                                  int prj, int cls, int sub, int sec)
{
   C_CACHE_CLS_ATTRIB_VALUES *p = search(prj, cls, sub, sec);

   if (!p)
   {
      if (!(p = new C_CACHE_CLS_ATTRIB_VALUES(prj, cls, sub, sec)))
         { GS_ERR_COD = eGSOutOfMem; return NULL; }
      add_tail(p);
   }

   return p->get_Descr(AttribName, ColValues);
}


/*********************************************************/
/*.doc C_CACHE_CLS_ATTRIB_VALUES_LIST::get_Value <external> */
/*+
  Questa funzione cerca un valore partendo dalla sua descrizione
  conoscendo i valori della scheda dell'entità, 
  dell'attributo e della classe di interesse e,
  se non già caricato in memoria, lo carica da file o da db.
  Parametri:
  C_STRING &AttribName;    Nome attributo
  C_RB_LIST &ColValues;    Lista dei valori della scheda dell'entità
  C_STRING &Descr;         Descrizione del valore
  int prj;                 Codice progetto
  int cls;                 Codice classe
  int sub;                 Codice sottoclasse
  int sec;                 Codice tabella secondaria

  Restituisce il valore in formato stringa in caso di successo altrimenti NULL.
  N.B: Alloca memoria.
-*/  
/*********************************************************/
TCHAR *C_CACHE_CLS_ATTRIB_VALUES_LIST::get_Value(C_STRING &AttribName, C_RB_LIST &ColValues,
                                                  C_STRING &Descr, int prj, int cls, int sub, int sec)
{
   C_CACHE_CLS_ATTRIB_VALUES *p = search(prj, cls, sub, sec);

   if (!p)
   {
      if (!(p = new C_CACHE_CLS_ATTRIB_VALUES(prj, cls, sub, sec)))
         { GS_ERR_COD = eGSOutOfMem; return NULL; }
      add_tail(p);
   }

   return p->get_Value(AttribName, ColValues, Descr);
}


/*********************************************************/
/*.doc C_CACHE_CLS_ATTRIB_VALUES_LIST::get_pCacheAttribValues <external> */
/*+
  Questa funzione cerca l'istanza di un oggetto C_CACHE_ATTRIB_VALUES
  che rappresenta le proprietà cache relative ad un attributo di una classe.
  La funzione fa solo operazione di ricerca, non carica niente.
  Parametri:
  C_STRING &AttribName;    Nome attributo
  int prj;                 Codice progetto
  int cls;                 Codice classe
  int sub;                 Codice sottoclasse
  int sec;                 Codice tabella secondaria

  Restituisce il puntatore in caso di successo altrimenti NULL.
-*/  
/*********************************************************/
C_CACHE_ATTRIB_VALUES *C_CACHE_CLS_ATTRIB_VALUES_LIST::get_pCacheAttribValues(C_STRING &AttribName, int prj, 
                                                                              int cls, int sub, int sec)
{
   C_CACHE_CLS_ATTRIB_VALUES *p = search(prj, cls, sub, sec);

   if (p) return p->get_pCacheAttribValues(AttribName);
   
   return NULL;
}


/**************************************************************************/
/*.doc C_CACHE_CLS_ATTRIB_VALUES_LIST::removeDependingOnAttrib <external> */
/*+
  Questa funzione cancella in memoria tutte le liste di valori 
  di una certa classe che dipendono da un attributo 
  (liste di scelta a 2 colonne condizionata o parametrica).
  Parametri:
  C_STRING &AttribName;    Nome attributo
  int prj;                 Codice progetto
  int cls;                 Codice classe
  int sub;                 Codice sottoclasse
  int sec;                 Codice tabella secondaria
-*/  
/**************************************************************************/
void C_CACHE_CLS_ATTRIB_VALUES_LIST::removeDependingOnAttrib(C_STRING &AttribName, int prj, 
                                                             int cls, int sub, int sec)
{
   C_CACHE_CLS_ATTRIB_VALUES  *pCacheClsAttribValues;
   C_CACHE_ATTRIB_VALUES      *pCacheAttribValues;

   if ((pCacheClsAttribValues = search(prj, cls, sub, sec)) == NULL) return;
   pCacheAttribValues = (C_CACHE_ATTRIB_VALUES *) pCacheClsAttribValues->m_attrib_values_list.get_head();
   while (pCacheAttribValues)
      if (pCacheAttribValues->isDependingOnAttrib(AttribName))
      {
         pCacheClsAttribValues->m_attrib_values_list.remove(pCacheAttribValues);
         pCacheAttribValues = (C_CACHE_ATTRIB_VALUES *) pCacheClsAttribValues->m_attrib_values_list.get_cursor();
      }
      else
         pCacheAttribValues = (C_CACHE_ATTRIB_VALUES *) pCacheAttribValues->get_next();
}


//-----------------------------------------------------------------------//
////////////    C_CACHE_CLS_ATTRIB_VALUES_LIST    FINE      ///////////////
//-----------------------------------------------------------------------//


//-----------------------------------------------------------------------//
// FUNZIONI GET & SET PER STRUTTURE INTERNE CLASSI DI IDENTITA'          //
// VERSIONE LISP                                                         //
//-----------------------------------------------------------------------//
int gsc_list_from_lsp(presbuf *rb, presbuf *list)
{
   if (rb == NULL) return GS_GOOD;
   if ((*rb) == NULL) return GS_GOOD;
   
   if (((*rb) = (*rb)->rbnext) != NULL)
   {
      if ((*rb)->restype != RTNIL)     // c'è la connect list
      {
         presbuf p;

         if ((*list = p = acutBuildList(RTLB, 0)) == NULL)
            { GS_ERR_COD = eGSOutOfMem; return GS_BAD; }

         if (gsc_scorcopy(*rb, p) == NULL) return GS_BAD;
         else (*rb) = gsc_scorri(*rb);
      }
      else                           // non c'è il valore
         if ((*list = acutBuildList(RTNIL, 0)) == NULL)
            { GS_ERR_COD = eGSOutOfMem; return GS_BAD; }
   }

   return GS_GOOD;
}   

                    
//---- C_ID ------------------------------------------------------------//
int gs_get_id(void)
{
   C_CLASS   *pCls;
   C_ID      *id;
   presbuf   arg;
   C_RB_LIST ret;
   int       prj, cls, sub;

   acedRetNil();
   // Legge nella lista dei parametri: progetto classe e sub
   arg = acedGetArgs();
   if (arg_to_prj_cls_sub(&arg, &prj, &cls, &sub) == GS_BAD) return RTERROR;
   
   // Ritorna il puntatore alla classe cercata
   if ((pCls = gsc_find_class(prj, cls, sub)) == NULL) return RTERROR;

   // Ritorna il puntatore ad C_ID della classe
   if ((id = pCls->ptr_id()) == NULL) return RTERROR;

   // Ritorna lista resbuf
   if ((ret << id->to_rb()) == NULL) return RTERROR;
   ret.LspRetList();

   return RTNORM;
}
                    
//---- C_GRID -------------------------------------------------------------//
int gsc_grid_from_lsp(presbuf *rb, presbuf *p)
{
   if (gsc_list_from_lsp(rb, p) == GS_BAD) return GS_BAD;

   return GS_GOOD;
}   

int gs_get_grid(void)
{
   C_CLASS   *pCls;
   C_GRID    *grid;
   resbuf    *arg;
   C_RB_LIST ret;
   int       prj, cls, sub;

   acedRetNil();
   // Legge nella lista dei parametri: progetto classe e sub
   arg = acedGetArgs();
   if (arg_to_prj_cls_sub(&arg,&prj,&cls,&sub) == GS_BAD) return RTERROR;

   // Ritorna il puntatore alla classe cercata
   if ((pCls = gsc_find_class(prj,cls,sub)) == NULL) return RTERROR;

   // Ritorna il puntatore a C_GRID della classe
   if ((grid = pCls->ptr_grid()) == NULL)
      { GS_ERR_COD = eGSInvClassType; return RTERROR; }

   // Ritorna lista resbuf
   if ((ret << grid->to_rb()) == NULL) return RTERROR;
   ret.LspRetList();

   return RTNORM;
}


int gs_get_connect_list(void)
{
   C_CLASS        *pCls;
   C_CONNECT_LIST *connect;
   presbuf        arg;
   C_RB_LIST      ret;
   int            prj, cls, sub;

   acedRetNil();
   // Legge nella lista dei parametri: progetto classe e sub
   arg = acedGetArgs();
   if (arg_to_prj_cls_sub(&arg, &prj, &cls, &sub) == GS_BAD) return RTERROR;

   // Ritorna il puntatore alla classe cercata
   if ((pCls = gsc_find_class(prj, cls, sub)) == NULL) return RTERROR;

   // Ritorna il puntatore a CONNECT_LIST della classe
   if ((connect = pCls->ptr_connect_list()) == NULL)
      { GS_ERR_COD = eGSInvClassType; return RTERROR; }

   // Ritorna lista resbuf
   if ((ret << connect->to_rb()) == NULL) return RTERROR;
   if (ret.get_head()->restype != RTNIL) ret.LspRetList();
   
   return RTNORM;
}


//---- GROUP_LIST -----------------------------------------------------//
int gsc_group_from_lsp(presbuf *rb, presbuf *p)
{
   if (rb != NULL && (*rb) != NULL && (*p) != NULL && (*rb)->rbnext != NULL &&
       ((*rb)->rbnext->restype == RTPOINT || (*rb)->rbnext->restype == RT3DPOINT))
       // la lista in forma RTPOINT o RT3DPOINT
   {
      *rb = (*rb)->rbnext;
      if (((*p) = gsc_copybuf(*rb)) == NULL) return GS_BAD;
   }
   else
      if (gsc_list_from_lsp(rb, p) == GS_BAD) return GS_BAD;

   return GS_GOOD;
}   


int gs_get_group_list(void)
{
   C_CLASS      *pCls;
   C_GROUP_LIST *GroupList;
   presbuf      arg;
   C_RB_LIST    ret;
   int          prj, cls, sub;

   acedRetNil();
   // Legge nella lista dei parametri: progetto classe e sub
   arg = acedGetArgs();
   if (arg_to_prj_cls_sub(&arg, &prj, &cls, &sub) == GS_BAD) return RTERROR;

   // Ritorna il puntatore alla classe cercata
   if ((pCls = gsc_find_class(prj, cls, sub)) == NULL) return RTERROR;

   // Ritorna il puntatore a GROUP_LIST della classe
   if ((GroupList = pCls->ptr_group_list()) == NULL)
         { GS_ERR_COD = eGSInvClassType; return RTERROR; }

   // Ritorna lista resbuf
   if ((ret << GroupList->to_rb()) == NULL) return RTERROR;
   if (ret.get_head()->restype != RTNIL) ret.LspRetList();

   return RTNORM;
}


//---- ATTRIB LIST -------------------------------------------------------//
int gsc_attrib_from_lsp(C_DBCONNECTION *pConn, int cat, int type, presbuf *rb, C_RB_LIST *list)
{                       
   presbuf succ, p;
   
   if (rb != NULL && (*rb) != NULL && (succ = (*rb)->rbnext) != NULL &&
       succ->restype != RTNIL) // c'è la attrib list 
   {
      if (gsc_list_from_lsp(rb, &p) == GS_BAD) return GS_BAD;
      (*list) += p; 
   }   
   else  // attrib list di default
   {
      *rb = succ;
      if (((*list) += acutBuildList(RTLB, 0)) == NULL) return GS_BAD;
      if (gsc_getdefaultattr(pConn, cat, type, &p) == GS_BAD) return GS_BAD;
      (*list) += p;
      if (((*list) += acutBuildList(RTLE, 0)) == NULL) return GS_BAD;
   }
   
   return GS_GOOD;
}


int gs_get_attrib_list(void)
{
   C_CLASS       *pCls;
   C_ATTRIB_LIST *attrib;
   resbuf        *arg;
   C_RB_LIST     ret;
   int           prj, cls, sub;

   acedRetNil();
   // Legge nella lista dei parametri: progetto classe e sub
   arg = acedGetArgs();
   if (arg_to_prj_cls_sub(&arg, &prj, &cls, &sub) == GS_BAD) return RTERROR;

   // Ritorna il puntatore alla classe cercata
   if ((pCls = gsc_find_class(prj, cls, sub)) == NULL) return RTERROR;

   // Ritorna il puntatore alla ATTRIBLIST della classe
   if ((attrib = pCls->ptr_attrib_list()) == NULL)
      { GS_ERR_COD = eGSInvClassType; return RTERROR; }

   // Ritorna lista resbuf
   if ((ret << attrib->to_rb()) == NULL) return RTERROR;
   ret.LspRetList();
   
   return RTNORM;
}


/*********************************************************/
/*.doc gs_get_default_values <internal> */
/*+
  Questa funzione restituisce una lista di resbuf così composta:
  ((<nome colonna><valore di default>) ... )
  Parametri LISP:
  (<prj><cls><sub>[<ss>||<ent>])
-*/  
/*********************************************************/
int gs_get_default_values(void)
{
   presbuf   arg;
   int       prj, cls, sub;
   C_CLASS   *pCls;
   C_RB_LIST ColValues;
   C_SELSET  SelSet;

   acedRetNil();
   // Legge nella lista dei parametri: progetto classe e sub
   arg = acedGetArgs();
   if (arg_to_prj_cls_sub(&arg, &prj, &cls, &sub) == GS_BAD) return RTERROR;

   if (arg)
      if (arg->restype == RTPICKS)
      {
         SelSet << arg->resval.rlname;
         SelSet.ReleaseAllAtDistruction(GS_BAD);
      }
      else
      if (arg->restype == RTENAME)
      {
         SelSet.add(arg->resval.rlname);
         SelSet.ReleaseAllAtDistruction(GS_BAD);
      }

   // Ritorna il puntatore alla classe cercata
   if ((pCls = gsc_find_class(prj, cls, sub)) == NULL) return RTERROR;

   if (pCls->get_default_values(ColValues, &SelSet) == NULL) return RTERROR;
   ColValues.remove_head(); ColValues.remove_tail();
   ColValues.LspRetList();
   
   return RTNORM;
}


int gs_get_class(void)
{
   C_CLASS   *pCls;
   resbuf    *arg;
   C_RB_LIST ret;
   int       prj, cls, sub;

   acedRetNil();
   // Legge nella lista dei parametri: progetto classe e sub
   arg = acedGetArgs();

   if (arg_to_prj_cls_sub(&arg, &prj, &cls, &sub) == GS_BAD) return RTERROR;

   // Ritorna il puntatore alla classe cercata
   if ((pCls = gsc_find_class(prj, cls, sub)) == NULL) return RTERROR;

   // Ritorna lista resbuf
   if ((ret << pCls->to_rb()) == NULL) return RTERROR;
   ret.LspRetList();

   return RTNORM;
}


/*********************************************************/
/*.doc gs_createsimplex <external> */
/*+
  Questa funzione LISP crea una classe di entità semplice di GEOsim.
  Parametri:
  Lista RESBUF (<prj><nome><descr><tipo><info><attrib><fas><gph_info>[<connect>])
         
  info         : (<UDL reference><UDL Props><Table reference><key_attrib>)
  UDL reference: Udl file | UDL connection string
  UDL Props    : ((<Prop Name1><Value1>)(<Prop Name2><Value2>)...) | nil

  fas          : (<colore><hatch><line><style><layer><block><width><elevation>
                  <scale><rotation><h_text><thickness><dir_dwg><vis_attrib><coord>
                  <file_ref_block><ref_block><file_graph_calc><fun_graph_calc>)
  gph_info     : (("SOURCE_TYPE" <SourceType_val>)("COORDINATE" <Coordinate_val>)...)
                 <SourceType_val> = 1 | 2            1 -> DWG, 2 -> DB 
                 <Coordinate_val> = sistema di coordinate
  connect      : ((cod_cls)(cod_connection)...)

  Restituisce codice classe in caso di successo altrimenti restituisce NIL.
-*/  
/*********************************************************/
int gs_createsimplex(void)
{
   C_CLASS   *pCls = NULL;
   C_RB_LIST list;
   presbuf   arg, p;
   int       prj, type, new_code, result = GS_BAD;
   C_STRING  name, descr(GS_EMPTYSTR);
   GraphDataSourceEnum SrcType;

   acedRetNil();
   arg = acedGetArgs();

   if (arg == NULL || arg->restype != RTLB)
      { GS_ERR_COD = eGSInvalidArg; return RTERROR; }

   // Alloca una classe semplice
   if ((pCls = gsc_alloc_new_class(CAT_SIMPLEX)) == NULL) return RTERROR;

   do
   {
      // codice progetto
      if ((p = gsc_nth(0, arg)) == NULL || gsc_rb2Int(p, &prj) != GS_GOOD) // non è stato passato
         { GS_ERR_COD = eGSInvalidArg; break; }  
      // nome classe
      if ((p = gsc_nth(1, arg)) == NULL || p->restype != RTSTR) // non è stato passato
         { GS_ERR_COD = eGSInvalidArg; break; }
      name = p->resval.rstring;
      // descrizione classe
      if ((p = gsc_nth(2, arg)) && p->restype == RTSTR)
         descr = p->resval.rstring;
      // tipo classe
      if ((p = gsc_nth(3, arg)) == NULL || gsc_rb2Int(p, &type) != GS_GOOD) // non è stato passato
         { GS_ERR_COD = eGSInvalidArg; break; }
   
      // creo resbuf per input dati C_ID 
      if ((list << acutBuildList(RTLB,
                                    RTNIL,                                          // code
                                    RTLB,
                                       RTSTR, _T("SUB_CODE"), RTSHORT, 0,           // sub_code
                                    RTLE,
                                    RTLB,
                                       RTSTR, _T("CATEGORY"), RTSHORT, CAT_SIMPLEX, // category
                                    RTLE,
                                    RTLB,
                                       RTSTR, _T("TYPE"), RTSHORT, type,            // type
                                    RTLE,
                                    RTLB,
                                       RTSTR, _T("NAME"), RTSTR, name.get_name(),   // class name
                                    RTLE,
                                    RTLB,
                                       RTSTR, _T("DESCRIPTION"), RTSTR, descr.get_name(), // description
                                    RTLE,
                                 RTLE, 0)) == NULL) 
         break;

      // set dati C_ID
      if (pCls->ptr_id()->from_rb(list.get_head()) == GS_BAD) break;

      // set dati C_INFO
      if (pCls->ptr_info()->from_rb(gsc_nth(4, arg)) == GS_BAD) break;
      if (pCls->get_type() == TYPE_TEXT && pCls->ptr_info()->LinkedTable) // se tipo testo con tabella collegata
         // leggo il campo che contiene il valore del testo
         if (!(p = gsc_CdrAssoc(_T("TEXT_ATTRIB"), gsc_nth(4, arg), FALSE)) || p->restype != RTSTR)
            { GS_ERR_COD = eGSInvRBType; break; }
         else name = p->resval.rstring;

      // set dati C_ATTRIB_LIST
      if (pCls->ptr_attrib_list()->from_rb(gsc_nth(5, arg)) == GS_BAD) break;
      if (pCls->get_type() == TYPE_TEXT && pCls->ptr_info()->LinkedTable) // se tipo testo con tabella collegata
      {  // imposto l'attributo visibile
         C_ATTRIB *pAttrib = (C_ATTRIB *) pCls->ptr_attrib_list()->search_name(name.get_name(), FALSE);
         if (!pAttrib) { GS_ERR_COD = eGSInvAttribName; break; }        
         pAttrib->vis = GS_GOOD;
      }

      // set dati C_FAS
      if (pCls->ptr_fas()->from_rb(gsc_nth(6, arg)) == GS_BAD) break;

      // set dati C_GPH_INFO
      if (!(p = gsc_nth(7, arg))) { GS_ERR_COD = eGSInvalidArg; break; }
      if ((SrcType = gsc_getGraphDataSourceType(p)) == GSNoneGphDataSource) break;
      if (pCls->allocGraphInfo(SrcType) == GS_BAD) break;
      if (pCls->ptr_GphInfo()->from_rb(p) == GS_BAD) break;

      // parametri opzionali:
      
      // set dati C_CONNECT_LIST
      if ((p = gsc_nth(8, arg)) != NULL) // non è stata passata
         if (pCls->ptr_connect_list()->from_rb(p) == GS_BAD) break;

      // creazione della classe
      if ((new_code = gsc_createclass(prj, pCls)) == 0) break;
      
      result = GS_GOOD;
   }
   while (0);

   if (result == GS_BAD) { delete pCls; return RTERROR; }
   
   acedRetInt(new_code);

   return RTNORM;
}


/*********************************************************/
/*.doc gs_createspaghetti <external> */
/*+
  Questa funzione LISP crea una classe di entità spaghetti di GEOsim.
  Parametri:
  Lista RESBUF (<prj><nome><fas><gph_info>)
  fas: (<colore><hatch><line><style><layer><block><width><elevation>
        <scale><rotation><h_text><thickness><dir_dwg><vis_attrib><coord>
        <file_ref_block><ref_block><file_graph_calc><fun_graph_calc>)
  gph_info     : (("SOURCE_TYPE" <SourceType_val>)("COORDINATE" <Coordinate_val>)...)
                 <SourceType_val> = 1 | 2            1 -> DWG, 2 -> DB 
                 <Coordinate_val> = sistema di coordinate
  
  con fas si intende solo l'insieme delle caratteristiche grafiche.

  Restituisce codice classe in caso di successo altrimenti restituisce NIL.
-*/  
/*********************************************************/
int gs_createspaghetti(void)
{
   C_CLASS   *pCls = NULL;
   presbuf   arg, p;
   int       prj, new_code, result = GS_BAD;
   C_STRING  name, descr(GS_EMPTYSTR);
   C_RB_LIST list;
   GraphDataSourceEnum SrcType;

   acedRetNil();
   arg = acedGetArgs();

   if (arg == NULL || arg->restype != RTLB)
      { GS_ERR_COD = eGSInvalidArg; return RTERROR; }

   // Alloca una classe spaghetti
   if ((pCls = gsc_alloc_new_class(CAT_SPAGHETTI)) == NULL) return RTERROR;

   do
   {
      // codice progetto
      if ((p = gsc_nth(0, arg)) == NULL || p->restype != RTSHORT) // non è stato passato
         { GS_ERR_COD = eGSInvalidArg; break; }
      prj = (int) p->resval.rint;
      // nome classe
      if ((p = gsc_nth(1, arg)) == NULL || p->restype != RTSTR) // non è stato passato
         { GS_ERR_COD = eGSInvalidArg; break; }
      name = p->resval.rstring;
      // descrizione classe
      if ((p = gsc_nth(2, arg)) && p->restype == RTSTR)
         descr = p->resval.rstring;

      // creo resbuf per input dati C_ID
      if ((list << acutBuildList(RTLB,
                                    RTNIL,                                             // code
                                    RTLB,
                                       RTSTR, _T("SUB_CODE"), RTSHORT, 0,              // sub_code
                                    RTLE,
                                    RTLB,
                                       RTSTR, _T("CATEGORY"), RTSHORT, CAT_SPAGHETTI,  // category
                                    RTLE,
                                    RTLB,
                                       RTSTR, _T("TYPE"), RTSHORT, TYPE_SPAGHETTI,     // type
                                    RTLE,
                                    RTLB,
                                       RTSTR, _T("NAME"), RTSTR, name.get_name(),      // class name
                                    RTLE,
                                    RTLB,
                                       RTSTR, _T("DESCRIPTION"), RTSTR, descr.get_name(), // description
                                    RTLE,
                                 RTLE, 0)) == NULL) 
         break;

      // set dati C_ID
      if (pCls->ptr_id()->from_rb(list.get_head()) == GS_BAD) break;

      // set dati C_FAS
      if (pCls->ptr_fas()->from_rb(gsc_nth(3, arg)) == GS_BAD) break;

      // set dati C_GPH_INFO
      if (!(p = gsc_nth(4, arg))) { GS_ERR_COD = eGSInvalidArg; break; }
      if ((SrcType = gsc_getGraphDataSourceType(p)) == GSNoneGphDataSource) break;
      if (pCls->allocGraphInfo(SrcType) == GS_BAD) break;
      if (pCls->ptr_GphInfo()->from_rb(p) == GS_BAD) break;

      // creazione della classe
      if ((new_code = gsc_createclass(prj, pCls)) == 0) break;
      
      result = GS_GOOD;
   }
   while (0);

   if (result == GS_BAD) { delete pCls; return RTERROR; }
   
   acedRetInt(new_code);

   return RTNORM;
}


/*********************************************************/
/*.doc gs_creategroup <external> */
/*+
  Questa funzione LISP crea una classe di entità gruppo di GEOsim.
  Parametri:
  Lista RESBUF (<prj><nome> compl info attrib)
         compl ((<cod_cls><quante>)...)
         info: (<dir_tab><driver><key_attrib>)
  
  Restituisce codice classe in caso di successo altrimenti restituisce NIL.
-*/  
/*********************************************************/
int gs_creategroup(void)
{
   C_CLASS   *pCls = NULL;
   presbuf   arg, p;
   int       prj, new_code, result = GS_BAD;
   C_STRING  name, descr(GS_EMPTYSTR);
   C_RB_LIST list;

   acedRetNil();
   arg = acedGetArgs();

   if (arg == NULL || arg->restype != RTLB)
      { GS_ERR_COD = eGSInvalidArg; return RTERROR; }

   // Alloca una classe gruppo
   if ((pCls = gsc_alloc_new_class(CAT_GROUP)) == NULL) return RTERROR;

   do
   {
      // codice progetto
      if ((p = gsc_nth(0, arg)) == NULL || p->restype != RTSHORT) // non è stato passato
         { GS_ERR_COD = eGSInvalidArg; break; }
      prj = (int) p->resval.rint;
      // nome classe
      if ((p = gsc_nth(1, arg)) == NULL || p->restype != RTSTR) // non è stato passato
         { GS_ERR_COD = eGSInvalidArg; break; }
      name = p->resval.rstring;
      // descrizione classe
      if ((p = gsc_nth(2, arg)) && p->restype == RTSTR)
         descr = p->resval.rstring;

      // creo resbuf per input dati C_ID 
      if ((list << acutBuildList(RTLB,
                                    RTNIL,                                          // code
                                    RTLB,
                                       RTSTR, _T("SUB_CODE"), RTSHORT, 0,           // sub_code
                                    RTLE,
                                    RTLB,
                                       RTSTR, _T("CATEGORY"), RTSHORT, CAT_GROUP,   // category
                                    RTLE,
                                    RTLB,
                                       RTSTR, _T("TYPE"), RTSHORT, TYPE_GROUP,      // type
                                    RTLE,
                                    RTLB,
                                       RTSTR, _T("NAME"), RTSTR, name.get_name(),   // class name
                                    RTLE,
                                    RTLB,
                                       RTSTR, _T("DESCRIPTION"), RTSTR, descr.get_name(), // description
                                    RTLE,
                                 RTLE, 0)) == NULL) 
         break;

      // set dati C_ID
      if (pCls->ptr_id()->from_rb(list.get_head()) == GS_BAD) break;

      // set dati C_GROUP_LIST
      if (pCls->ptr_group_list()->from_rb(gsc_nth(3, arg)) == GS_BAD) break;

      // set dati C_INFO
      if (pCls->ptr_info()->from_rb(gsc_nth(4, arg)) == GS_BAD) break;

      // set dati C_ATTRIB_LIST
      if (pCls->ptr_attrib_list()->from_rb(gsc_nth(5, arg)) == GS_BAD) break;

      if ((new_code = gsc_createclass(prj, pCls)) == 0) break;
      
      result = GS_GOOD;
   }
   while (0);

   if (result == GS_BAD) { delete pCls; return RTERROR; }
   
   acedRetInt(new_code);

   return RTNORM;
}


/*********************************************************/
/*.doc gs_creategrid <external> */
/*+
  Questa funzione LISP crea una classe di entità griglia di GEOsim.
  Parametri:
  Lista RESBUF (<prj><nome> grid info attrib fas)
         grid: (<x_orig><y_orig><delta_x><delta_y><n_elem_x><n_elem_y>)
  
  Restituisce codice classe in caso di successo altrimenti restituisce NIL.
-*/  
/*********************************************************/
int gs_creategrid(void)
{
   C_CLASS   *pCls = NULL;
   C_RB_LIST list;
   presbuf   arg, p;
   int       prj, new_code, result = GS_BAD;
   C_STRING  name, descr(GS_EMPTYSTR);

   acedRetNil();
   arg = acedGetArgs();

   if (arg == NULL || arg->restype != RTLB)
      { GS_ERR_COD = eGSInvalidArg; return RTERROR; }

   // Alloca una classe semplice
   if ((pCls = gsc_alloc_new_class(CAT_GRID)) == NULL) return RTERROR;

   do
   {
      // codice progetto
      if ((p = gsc_nth(0, arg)) == NULL || p->restype != RTSHORT) // non è stato passato
         { GS_ERR_COD = eGSInvalidArg; break; }
      prj = (int) p->resval.rint;
      // nome classe
      if ((p = gsc_nth(1, arg)) == NULL || p->restype != RTSTR) // non è stato passato
         { GS_ERR_COD = eGSInvalidArg; break; }
      name = p->resval.rstring;
      // descrizione classe
      if ((p = gsc_nth(2, arg)) && p->restype == RTSTR)
         descr = p->resval.rstring;

      // creo resbuf per input dati C_ID 
      if ((list << acutBuildList(RTLB,
                                    RTNIL,                                          // code
                                    RTLB,
                                       RTSTR, _T("SUB_CODE"), RTSHORT, 0,           // sub_code
                                    RTLE,
                                    RTLB,
                                       RTSTR, _T("CATEGORY"), RTSHORT, CAT_GRID,    // category
                                    RTLE,
                                    RTLB,
                                       RTSTR, _T("TYPE"), RTSHORT, TYPE_GRID,       // type
                                    RTLE,
                                    RTLB,
                                       RTSTR, _T("NAME"), RTSTR, name.get_name(),   // class name
                                    RTLE,
                                    RTLB,
                                       RTSTR, _T("DESCRIPTION"), RTSTR, descr.get_name(), // description
                                    RTLE,
                                 RTLE, 0)) == NULL) 
         break;

      // set dati C_ID
      if (pCls->ptr_id()->from_rb(list.get_head()) == GS_BAD) break;

      // set dati C_GRID
      if (pCls->ptr_grid()->from_rb(gsc_nth(3, arg)) == GS_BAD) break;

      // set dati C_INFO
      if (pCls->ptr_info()->from_rb(gsc_nth(4, arg)) == GS_BAD) break;

      // set dati C_ATTRIB_LIST
      if (pCls->ptr_attrib_list()->from_rb(gsc_nth(5, arg)) == GS_BAD) break;

      // creazione della classe
      if ((new_code = gsc_createclass(prj, pCls)) == 0) break;
      
      result = GS_GOOD;
   }
   while (0);

   if (result == GS_BAD) { delete pCls; return RTERROR; }
   
   acedRetInt(new_code);

   return RTNORM;
}


/*********************************************************/
/*.doc gs_createextern <external> */
/*+
  Questa funzione LISP crea una classe di entità simulazione di GEOsim.
  Parametri:
  Lista RESBUF (<prj><nome><tipo>(<udlconn>[<udlprops>]<tab_ref>)<dir_dwg>[<coord>])
  <tab_ref> : (<catalog>|nil <schema>|nil)
  
  Lista RESBUF (<prj><nome><tipo>(<udlconn>[<udlprops>]<tab_ref>)<gph_info>)

  <tab_ref>  : (<catalog>|nil <schema>|nil)
  <gph_info> : (("SOURCE_TYPE" <SourceType_val>)("COORDINATE" <Coordinate_val>)...)
                 <SourceType_val> = 1 | 2            1 -> DWG, 2 -> DB 
                 <Coordinate_val> = sistema di coordinate

  Restituisce codice classe in caso di successo altrimenti restituisce NIL.
-*/  
/*********************************************************/
int gs_createextern(void)
{
   C_EXTERN            *pCls;
   C_SUB               *pSub;
   presbuf             arg, lista_sub, p, pGphInfoRbList;
   int                 prj, i, len, new_code, type;
   C_STRING            name, dir_dwg, coord(DEFAULT_DWGCOORD), descr(GS_EMPTYSTR);
   C_STRING            filename, Table;
   C_RB_LIST           list;
   C_PROFILE_SECTION_BTREE ProfileSections;
   C_SECONDARY         *pSec;
   C_2STR_LIST         PropList;
   GraphDataSourceEnum SrcType;
   C_GPH_INFO          *pGphInfo;

   acedRetNil();
   arg = acedGetArgs();

   if (arg == NULL || arg->restype != RTLB)
      { GS_ERR_COD = eGSInvalidArg; return RTERROR; }

   // codice progetto
   if ((p = gsc_nth(0, arg)) == NULL || p->restype != RTSHORT) // non è stato passato
      { GS_ERR_COD = eGSInvalidArg; return RTERROR; }
   prj = p->resval.rint;
   // nome classe
   if ((p = gsc_nth(1, arg)) == NULL || p->restype != RTSTR) // non è stato passato
      { GS_ERR_COD = eGSInvalidArg; return RTERROR; }
      name = p->resval.rstring;
   // descrizione classe
   if ((p = gsc_nth(2, arg)) && p->restype == RTSTR)
      descr = p->resval.rstring;
   // tipo classe
   if ((p = gsc_nth(3, arg)) == NULL || p->restype != RTSHORT) // non è stato passato
      { GS_ERR_COD = eGSInvalidArg; return RTERROR; }
   type = p->resval.rint;
   
   // creo resbuf per input dati C_ID 
   if ((list << acutBuildList(RTLB,
                                 RTNIL,                                          // code
                                 RTLB,
                                    RTSTR, _T("SUB_CODE"), RTSHORT, 0,           // sub_code
                                 RTLE,
                                 RTLB,
                                    RTSTR, _T("CATEGORY"), RTSHORT, CAT_EXTERN, // category
                                 RTLE,
                                 RTLB,
                                    RTSTR, _T("TYPE"), RTSHORT, type,            // type
                                 RTLE,
                                 RTLB,
                                    RTSTR, _T("NAME"), RTSTR, name.get_name(),   // class name
                                 RTLE,
                                 RTLB,
                                    RTSTR, _T("DESCRIPTION"), RTSTR, descr.get_name(), // description
                                 RTLE,
                              RTLE, 0)) == NULL) 
      return RTERROR;

   // Alloca una classe simulazione
   if ((pCls = (C_EXTERN *) gsc_alloc_new_class(CAT_EXTERN)) == NULL) return RTERROR;
   // leggo C_ID
   if ((pCls->ptr_id())->from_rb(list.get_head()) == GS_BAD)
      { delete pCls; return RTERROR; }
   // Legge nella lista dei parametri i riferimenti alla tabella
   if ((pCls->ptr_info())->from_rb(gsc_nth(4, arg)) == GS_BAD)
      { delete pCls; return RTERROR; }
  
   // set dati C_GPH_INFO
   if (!(p = gsc_nth(5, arg)))
      { delete pCls; return RTERROR; }
   if ((SrcType = gsc_getGraphDataSourceType(p)) == GSNoneGphDataSource)
      { delete pCls; return RTERROR; }
   if ((pGphInfo = gsc_alloc_GraphInfo(SrcType)) == NULL)
      { delete pCls; return RTERROR; }
   if (pGphInfo->from_rb(p) == GS_BAD)
      { delete pCls; return RTERROR; }

   if (pCls->get_file_stru(filename) == GS_BAD)
      { delete pCls; return RTERROR; }

   if (gsc_read_profile(filename, ProfileSections) == GS_BAD) return RTERROR;

   // Ricopia i dati dalla struttura di ingresso
   if ((p = pCls->read_stru(ProfileSections)) == NULL)
      { delete pCls; return RTERROR; }

   list << p;
   lista_sub = list.nth(2);
   len = gsc_length(lista_sub);

   // Aggiungo alla lista delle sub la struttura pGphInfo (C_GPH_INFO)
   for (i = 0; i < len; i++)
   {
      if ((p = gsc_nth(i, lista_sub)) == NULL)
         { delete pCls; return RTERROR; }
      p = gsc_scorri(gsc_nth(2, p)); // ultimo elemento della terza lista
      list.set_cursor(p);

      p = pGphInfoRbList = acutBuildList(RTLB, 0);
      while (p->rbnext) p = p->rbnext;
      p->rbnext = pGphInfo->to_rb();
      while (p->rbnext) p = p->rbnext;
      p->rbnext = acutBuildList(RTLE, 0);

      list.link_atCursor(pGphInfoRbList);
   }

   // Ricopia i dati dalla struttura di ingresso
   for (i = 0; i < len; i++)
   {
      if ((pSub = new C_SUB) == NULL)
         { delete pCls; GS_ERR_COD = eGSOutOfMem; return RTERROR; }
      (pCls->ptr_sub_list())->add_tail(pSub);

      if (pSub->from_rb(gsc_nth(i, lista_sub)) == GS_BAD)
         { delete pCls; return RTERROR; }
   }

   // Per default i layer sono uguali al nome della classe
   pSub = (C_SUB *) pCls->ptr_sub_list()->get_head();
   while (pSub)
   {
      gsc_strcpy(pSub->ptr_fas()->layer, pCls->get_name(), MAX_LEN_LAYERNAME);
      gsc_strcpy(pSub->ptr_fas()->hatch_layer, pCls->get_name(), MAX_LEN_LAYERNAME);
      pSub = (C_SUB *) pSub->get_next();
   }

   if ((new_code = gsc_createclass(prj, pCls)) == 0)
      { delete pCls; return RTERROR; }

   // creaz. tabelle secondarie
   pSub = (C_SUB *) pCls->ptr_sub_list()->get_head();
   while (pSub)
   {
      i = 1;
      do
      {
         if ((pSec = new C_SECONDARY) == NULL) 
            { GS_ERR_COD = eGSOutOfMem; return RTERROR; }
         if (pSec->read_stru(ProfileSections, pSub, i++) == GS_GOOD)
         {
            // creazione tabella secondaria
            if (gsc_create_tab_sec(prj, pSub->ptr_id()->code, pSub->ptr_id()->sub_code, pSec) == GS_BAD)
               { delete pSec; return RTERROR; }
         }
         else
         {
            delete pSec;
            break;
         }
      }
      while (1);

      pSub = (C_SUB *) pSub->get_next();
   }

   acedRetInt(new_code);

   return RTNORM;
}


/*********************************************************/
/*.doc gs_mod_id <external> */
/*+
  Questa funzione LISP modifica la C_ID di una classe di entità di GEOsim.
  Parametri:
  Lista RESBUF (descrizione classe : prj_code class_code
                                     [class_subcode] class_name class_descr)
    
  Restituisce TRUE in caso di successo altrimenti restituisce NIL.
-*/  
/*********************************************************/
int gs_mod_id(void)
{
   C_CLASS   *pCls;
   C_ID      id;
   presbuf   arg = acedGetArgs();
   C_RB_LIST List;
   int       prj, cls = 0, sub = 0;

   acedRetNil();

   // Legge nella lista dei parametri il progetto
   if (!arg || arg->restype != RTSHORT)
      { GS_ERR_COD = eGSInvalidArg; return RTERROR; }
   prj = (int) arg->resval.rint;

   // creo resbuf per input dati C_ID 
   if ((List << acutBuildList(RTLB, 0)) == NULL) return RTERROR;
   // codice classe
   if ((arg = arg->rbnext) == NULL) { GS_ERR_COD = eGSInvalidArg; return RTERROR; }
   gsc_rb2Int(arg, &cls);

   if ((arg = arg->rbnext) == NULL) { GS_ERR_COD = eGSInvalidArg; return RTERROR; }
   if (arg->restype != RTSTR)  // c'è il sottocodice classe   
   {   // sottocodice classe
      gsc_rb2Int(arg, &sub);
      if ((arg = arg->rbnext) == NULL) { GS_ERR_COD = eGSInvalidArg; return RTERROR; }
   }

   // creo resbuf per input dati C_ID 
   if ((List << acutBuildList(RTLB,
                                 RTLB,
                                    RTSTR, _T("CODE"), RTSHORT, cls,                // code
                                 RTLE,
                                 RTLB,                                    
                                    RTSTR, _T("SUB_CODE"), RTSHORT, sub,            // sub_code
                                 RTLE,                                    
                                 RTLB,                                    
                                    RTSTR, _T("CATEGORY"), RTSHORT, 0,              // category
                                 RTLE,                                    
                                 RTLB,                                    
                                    RTSTR, _T("TYPE"), RTSHORT, 0,                  // type
                                 RTLE,
                                 RTLB,
                                    RTSTR, _T("NAME"), RTSTR, arg->resval.rstring,  // class name
                                 RTLE,
                              0)) == NULL) 
      return RTERROR;

   if ((arg = arg->rbnext) && arg->restype == RTSTR)
      if ((List += acutBuildList(RTLB,
                                    RTSTR, _T("DESCRIPTION"), RTSTR, arg->resval.rstring,  // class descr
                                 RTLE, 0)) == NULL) 
         return RTERROR;

   if ((List += acutBuildList(RTLE, 0)) == NULL) return RTERROR;

   // Ricopia i dati dalla struttura di ingresso
   if (id.from_rb(List.get_head()) == GS_BAD) return RTERROR;
   
   if ((pCls = gsc_find_class(prj, id.code, id.sub_code)) == NULL) return RTERROR; 
   // modifico classe
   if (pCls->mod_id(&id) == GS_BAD) return GS_BAD;

   acedRetT();

   return RTNORM;
}


/*********************************************************/
/*.doc gs_mod_fas <external> */
/*+
  Questa funzione LISP modifica la C_FAS di una classe di entità di GEOsim.
  Parametri:
  Lista RESBUF, descrizione classe :
  <prj><cls><sub><change_fas> C_FAS
    
  Restituisce GS_GOOD in caso di successo, GS_CAN se l'operazione è stata abortita,
  GS_BAD in caso di errore.
-*/  
/*********************************************************/
int gs_mod_fas(void)
{
   C_FAS  fas;
   resbuf *arg;
   int    prj, cls, sub, change_fas;

   acedRetNil();
   arg = acedGetArgs();
   // Legge nella lista dei parametri il progetto, classe e sottoclasse
   if (arg_to_prj_cls_sub(&arg, &prj, &cls, &sub) == GS_BAD) return RTERROR;

   change_fas = (arg && arg->restype == RTT) ? GS_GOOD : GS_BAD;
   if (!(arg = arg->rbnext)) { GS_ERR_COD = eGSInvalidArg; return RTERROR; }

   // Ricopia i dati dalla struttura di ingresso
   if (fas.from_rb(arg) == GS_BAD) return RTERROR;

   if (gsc_mod_fas(prj, cls, sub, &fas, change_fas) == GS_BAD) return RTERROR;

   acedRetT();

   return RTNORM;
}


/*********************************************************/
/*.doc gs_mod_coord <external> */
/*+
  Questa funzione LISP modifica il sistema di coordinate di una classe 
  di entità di GEOsim.
  Parametri:
  Lista RESBUF (descrizione classe : <progetto><classe><sottoclasse><coord>)
    
  Restituisce TRUE in caso di successo altrimenti restituisce NIL.
-*/  
/*********************************************************/
int gs_mod_coord(void)
{
   presbuf arg;
   int     prj, cls, sub, res;
   TCHAR   *coord;
   
   acedRetNil();
   // Legge nella lista dei parametri il progetto
   arg = acedGetArgs();
   if (arg_to_prj_cls_sub(&arg, &prj, &cls, &sub) == GS_BAD) return RTERROR;
   
   if (arg == NULL || arg->restype != RTSTR)
      { GS_ERR_COD=eGSInvalidArg; return RTERROR; }
   if ((coord = gsc_tostring(arg->resval.rstring)) == NULL)
      { GS_ERR_COD = eGSOutOfMem; return RTERROR; }

   res = gsc_mod_coord(prj, cls, coord);
   free(coord);

   if (res == GS_BAD) return RTERROR;
                             
   acedRetT();

   return RTNORM;
}


/*********************************************************/
/*.doc gs_mod_connect_list <external> */
/*+
  Questa funzione LISP modifica la C_CONNECT_LIST di una classe di entità
  di GEOsim.
  Parametri:
  Lista RESBUF (<progetto><classe><sottoclasse> C_CONNECT_LIST ...)
    
  Restituisce TRUE in caso di successo altrimenti restituisce NIL.
-*/  
/*********************************************************/
int gs_mod_connect_list(void)
{
   C_CONNECT_LIST conct;
   presbuf        arg = acedGetArgs();
   int            prj, cls, sub;
   C_CLASS        *pCls;

   acedRetNil();
   // Legge nella lista dei parametri il progetto
   if (arg_to_prj_cls_sub(&arg, &prj, &cls, &sub) == GS_BAD) return RTERROR;

   // Ricopia i dati dalla struttura di ingresso
   if (conct.from_rb(arg)==GS_BAD) return RTERROR;

   if ((pCls = gsc_find_class(prj, cls, sub)) == NULL) return RTERROR;
   if (pCls->mod_conct(&conct) == GS_BAD) return RTERROR;

   acedRetT();

   return RTNORM;
}


/*********************************************************/
/*.doc gs_mod_stru                            <external> */
/*+
  Questa funzione LISP modifica la C_ATTRIBT_LIST di una classe di entità o
  di una tabella secondaria.
  di GEOsim.
  Parametri:
  Lista RESBUF <prj><cls>[<sub>[<sec>]]
    
  Restituisce GS_GOOD in caso di successo, GS_CAN se l'operazione è stata abortita,
  GS_BAD in caso di errore.
-*/  
/*********************************************************/
int gs_mod_stru(void)
{      
   presbuf arg = acedGetArgs();
   int     prj, cls, sub, sec = 0, result;

   acedRetInt(GS_BAD);
   if (arg_to_prj_cls_sub(&arg, &prj, &cls, &sub) == GS_BAD) return RTERROR;

   if (arg)
      if (arg->restype != RTSHORT)  // codice secondaria opzionale
         { GS_ERR_COD = eGSInvalidArg; return GS_BAD; }
      else sec = (int) arg->resval.rint;

   if (sec == 0)
   {
      C_CLASS *pCls;

      // Ritorna il puntatore alla classe cercata 
      if ((pCls = gsc_find_class(prj, cls, sub)) == NULL) return RTERROR;
      if ((result = pCls->mod_stru()) == GS_BAD) return RTERROR;
   }
   else
   {
      C_SECONDARY *pSec;

      // Ritorna il puntatore alla tabella secondaria cercata
      if ((pSec = gsc_find_sec(prj, cls, sub, sec)) == NULL) return RTERROR;
      if ((result = pSec->mod_stru()) == GS_BAD) return RTERROR;
   }
   acedRetInt(result);

   return RTNORM;
}
                                                  
                                                  
/*********************************************************/
/*.doc gs_delclass                            <external> */
/*+
  Questa funzione LISP cancella una classe di entità di GEOsim.
  Parametri:
  Lista RESBUF (Codice progetto, Codice classe, Password)
    
  Restituisce TRUE in caso di successo altrimenti restituisce NIL.
-*/  
/*********************************************************/
int gs_delclass(void)
{
   presbuf   arg = acedGetArgs();
   int       cls;
   C_PROJECT *pPrj;

   acedRetNil();

   // codice del progetto
   if (arg == NULL || arg->restype != RTSHORT)
      { GS_ERR_COD = eGSInvalidArg; return RTERROR; }
   // Cerca progetto nella lista GEOsimAppl::PROJECTS
   if ((pPrj = (C_PROJECT *) GEOsimAppl::PROJECTS.search_key(arg->resval.rint)) == NULL)
      return RTERROR;

   // codice della classe
   if ((arg = arg->rbnext) == NULL || arg->restype != RTSHORT)
      { GS_ERR_COD=eGSInvalidArg; return RTERROR; }
   cls = (int) arg->resval.rint;

   // Password
   if ((arg = arg->rbnext) == NULL || arg->restype != RTSTR)
      { GS_ERR_COD = eGSInvalidArg; return RTERROR; }

   if (pPrj->DelClass(cls, arg->resval.rstring) == GS_BAD) return RTERROR;
   acedRetT();

   return RTNORM;
}
                                                  
                                                  
/*********************************************************/
/*.doc gs_synchronizeclass                     <external> */
/*+
  Questa funzione LISP sincronizza una classe di entità di GEOsim.
  Parametri:
  Lista RESBUF (<Codice progetto> <Codice classe> [<File DWG>])
    
  Restituisce TRUE in caso di successo altrimenti restituisce NIL.
-*/  
/*********************************************************/
int gs_synchronizeclass(void)
{
   presbuf    arg = acedGetArgs();
   int        cls;
   C_PROJECT  *pPrj;
   C_CLASS    *pCls;
   C_STRING   DWG, NextCmd;
   C_INT_LIST CodeClsList;

   acedRetNil();

   // codice del progetto
   if (arg == NULL || arg->restype != RTSHORT)
      { GS_ERR_COD = eGSInvalidArg; return RTERROR; }
   // Cerca progetto nella lista GEOsimAppl::PROJECTS
   if ((pPrj = (C_PROJECT *) GEOsimAppl::PROJECTS.search_key(arg->resval.rint)) == NULL)
      return RTERROR;

   // codice della classe
   if ((arg = arg->rbnext) == NULL) { GS_ERR_COD = eGSInvalidArg; return RTERROR; }
   
   // se si tratta di una sola classe
   if (arg->restype == RTSHORT) cls = (int) arg->resval.rint;
   // Se si tratta di una lista di classi
   else if (CodeClsList.from_rb(arg) == GS_GOOD)
   {
      // Considero solo la prima classe
      cls = ((C_INT *) CodeClsList.get_head())->get_key();
      // Memorizzo nella lista le classi successive
      CodeClsList.remove_head();

      // avanzo all'elemento di fine lista
		if (arg->restype == RTLB) arg = gsc_scorri(arg);
   }
   else // parametro di tipo sbagliato
      { GS_ERR_COD = eGSInvalidArg; return RTERROR; }

   if ((pCls = pPrj->find_class(cls)) == NULL) return RTERROR;

   if (pCls->ptr_GphInfo())
   {  // Se la grafica era in formato DWG
      if (pCls->ptr_GphInfo()->getDataSourceType() == GSDwgGphDataSource)
         DWG = ((C_DWG_INFO *) pCls->ptr_GphInfo())->dir_dwg;
      else // altrimenti
         DWG = GEOsimAppl::CURRUSRDIR;

      DWG += _T("\\SYNCRO CLASS");
      DWG += cls;
      DWG += _T(".DWG");
   }

   // Path completa di un file DWG opzionale
   if ((arg = arg->rbnext) && arg->restype == RTSTR)
   {
      DWG = arg->resval.rstring;
      DWG.alltrim();
      if (DWG.len() == 0) DWG.clear();
   }

   if (CodeClsList.get_count() > 0) // Se ci sono altre classi da sincronizzare
   {
      C_INT *pCodeCls = (C_INT *) CodeClsList.get_head();
      int   i = 1, nList = 0;

      NextCmd = _T("(setq ClsList '(");
      while (pCodeCls)
      {
   		// spezzare la lista delle classi scelte se troppo lunga
   	   if (i % 25 == 0)
         {
            NextCmd += _T("))\n(setq ClsList");
            NextCmd += nList++;
            NextCmd += _T(" '(");
         }
         NextCmd += pCodeCls->get_key();
         // scrivo il codice come numero reale per non avere problemi 
         // con la funzione list
         NextCmd += _T(".0 "); 
         i++;

         pCodeCls = (C_INT *) CodeClsList.get_next();
      }
      NextCmd += _T("))\n");

	   if (nList > 0)
	   {
		   NextCmd += _T("(setq ClsList (append ClsList");
		   for (i = 0; i < nList; i++)
		   {
			   NextCmd += _T(" ClsList");
			   NextCmd += i;
		   }
		   NextCmd += _T("))\n");
	   }

      NextCmd += _T("(gs_synchronizeclass ");
      NextCmd += pPrj->get_key();
      NextCmd += _T(" ClsList)");
   }

   if (pCls->synchronize(DWG.get_name(), NextCmd.get_name()) == GS_BAD)
      return RTERROR;
   acedRetT();

   return RTNORM;
}


/*********************************************************/
/*.doc gs_dwgoptimizationclass                <external> */
/*+
  Questa funzione LISP ottimizza i disegni di una classe di entità di GEOsim.
  Parametri:
  Lista RESBUF (Codice progetto, Codice classe)
    
  Restituisce TRUE in caso di successo altrimenti restituisce NIL.
-*/  
/*********************************************************/
int gs_dwgoptimizationclass(void)
{
   presbuf   arg = acedGetArgs();
   int       cls;
   C_PROJECT *pPrj;
   C_CLASS   *pCls;

   acedRetNil();

   // codice del progetto
   if (arg == NULL || arg->restype != RTSHORT)
      { GS_ERR_COD = eGSInvalidArg; return RTERROR; }
   // Cerca progetto nella lista GEOsimAppl::PROJECTS
   if ((pPrj = (C_PROJECT *) GEOsimAppl::PROJECTS.search_key(arg->resval.rint)) == NULL)
      return RTERROR;

   // codice della classe
   if ((arg = arg->rbnext) == NULL || gsc_rb2Int(arg, &cls) != GS_GOOD)
      { GS_ERR_COD = eGSInvalidArg; return RTERROR; }

   if ((pCls = pPrj->find_class(cls)) == NULL) return RTERROR;

   if (pCls->DWGOptimization() == GS_BAD) return RTERROR;
   acedRetT();

   return RTNORM;
}


//-----------------------------------------------------------------------//
// FUNZIONI GET & SET PER STRUTTURE INTERNE CLASSI DI IDENTITA' //
//-----------------------------------------------------------------------//


//---- C_FAS --------------------------------------------------------------//


/***********************************************************/
/*.doc gs_is_graph_calc_to_recalc               <external> */
/*+
  Questa funzione LISP restituisce TRUE se il calcolo grafico
  deve essere rielaborato (funzione di appoggio).
  Parametri:
  (<old_file><old_fun>)(<new_file><new_fun>)

-*/  
/*********************************************************/
int gs_is_graph_calc_to_recalc(void)
{
   const TCHAR *old_fun = NULL, *old_file = NULL, *new_fun = NULL, *new_file = NULL;
   presbuf arg = acedGetArgs();

   acedRetNil();
   if (!arg) { GS_ERR_COD = eGSInvalidArg; return RTERROR; }

   if (arg->restype == RTLB)
   {  // vecchio file di funzioni
      if (!(arg = arg->rbnext) || (arg->restype != RTSTR && arg->restype != RTNIL))
         { GS_ERR_COD = eGSInvalidArg; return RTERROR; }
      if (arg->restype == RTSTR) old_file = arg->resval.rstring;
      // vecchia funzione
      if (!(arg = arg->rbnext) || (arg->restype != RTSTR && arg->restype != RTNIL))
         { GS_ERR_COD = eGSInvalidArg; return RTERROR; }
      if (arg->restype == RTSTR) old_fun = arg->resval.rstring;

      if (!(arg = arg->rbnext) || arg->restype != RTLE)
         { GS_ERR_COD = eGSInvalidArg; return RTERROR; }
   }
   else if (arg->restype != RTNIL) { GS_ERR_COD = eGSInvalidArg; return RTERROR; }

   if (!(arg = arg->rbnext)) { GS_ERR_COD = eGSInvalidArg; return RTERROR; }
   if (arg->restype == RTLB)
   {  // nuovo file di funzioni
      if (!(arg = arg->rbnext) || (arg->restype != RTSTR && arg->restype != RTNIL))
         { GS_ERR_COD = eGSInvalidArg; return RTERROR; }
      if (arg->restype == RTSTR) new_file = arg->resval.rstring;
      // nuova funzione
      if (!(arg = arg->rbnext) || (arg->restype != RTSTR && arg->restype != RTNIL))
         { GS_ERR_COD = eGSInvalidArg; return RTERROR; }
      if (arg->restype == RTSTR) new_fun = arg->resval.rstring;
   }
   else if (arg->restype != RTNIL) { GS_ERR_COD = eGSInvalidArg; return RTERROR; }

   if (is_graph_calc_to_recalc(old_fun, old_file, new_fun, new_file)) acedRetT();

   return RTNORM;
}


/***********************************************************/
/*.doc is_graph_calc_to_recalc                  <internal> */
/*+
  Questa funzione restituisce TRUE se il calcolo grafico
  deve essere rielaborato (funzione di appoggio).
  Parametri:
  const TCHAR *old_fun;   vecchia funzione di calcolo grafico
  const TCHAR *old_file;  vecchia path del file contenente la funzione
  const TCHAR *new_fun;   nuova funzione di calcolo grafico
  const TCHAR *new_file;  nuova path del file contenente la funzione
-*/  
/*********************************************************/
static int is_graph_calc_to_recalc(const TCHAR *old_fun, const TCHAR *old_file,
                                   const TCHAR *new_fun, const TCHAR *new_file)
{
   if (gsc_strlen(new_fun) > 0) // se esiste una funzione di calcolo grafico
   {
      // allora verifico che le stringhe
      // siano diverse (se una = NULL e l'altra = "", sono da considerarsi uguali)
      C_STRING _OldFile, _OldFun, _NewFile, _NewFun;

      _OldFile = (old_file) ? old_file : GS_EMPTYSTR; _OldFile.alltrim();
      _OldFun  = (old_fun)  ? old_fun  : GS_EMPTYSTR; _OldFun.alltrim();
      _NewFile = (new_file) ? new_file : GS_EMPTYSTR; _NewFile.alltrim();
      _NewFun  = (new_fun)  ? new_fun  : GS_EMPTYSTR; _NewFun.alltrim();
      
      return (_OldFile.comp(_NewFile) != 0 || _OldFun.comp(_NewFun) != 0) ? TRUE : FALSE;
   }
   else 
      return FALSE;
}                                           


/***********************************************************/
/*.doc is_block_ref_to_update                   <internal> */
/*+
  Questa funzione restituisce TRUE se il blocco di riferimento
  è stato variato (funzione di appoggio).
  Parametri:
  const TCHAR *old_fun;   vecchia funzione di calcolo grafico
  const TCHAR *old_file;  vecchia path del file contenente la funzione
  const TCHAR *new_fun;   nuova funzione di calcolo grafico
  const TCHAR *new_file;  nuova path del file contenente la funzione
-*/  
/*********************************************************/
static int is_block_ref_to_update(const TCHAR *old_ref_block, const TCHAR *old_file,
                                  const TCHAR *new_ref_block, const TCHAR *new_file)
{
   if (gsc_strlen(new_ref_block) > 0) // se esiste un blocco di riferimento
   {
      // allora verifico che le stringhe
      // siano diverse (se una = NULL e l'altra = "", sono da considerarsi uguali)
      C_STRING _OldFile, _OldRefBlock, _NewFile, _NewRefBlock;

      _OldFile     = (old_file) ?       old_file       : GS_EMPTYSTR; _OldFile.alltrim();
      _OldRefBlock = (old_ref_block) ?  old_ref_block  : GS_EMPTYSTR; _OldRefBlock.alltrim();
      _NewFile     = (new_file) ?       new_file       : GS_EMPTYSTR; _NewFile.alltrim();
      _NewRefBlock = (new_ref_block)  ? new_ref_block  : GS_EMPTYSTR; _NewRefBlock.alltrim();
      
      return (_OldFile.comp(_NewFile) != 0 || _OldRefBlock.comp(_NewRefBlock) != 0) ? TRUE : FALSE;
   }
   else 
      return FALSE;
}                                           


/*********************************************************/
/*.doc gsc_mod_fas <internal> */
/*+
  Questa funzione modifica i valori della C_FAS di una classe.
  Parametri:
  int prj;           codice progetto
  int cls;           codice classe
  int sub;           codice sottoclasse
  C_FAS *p_fas;      puntat. a oggetto C_FAS già allocato e inizializzato
  int change_fas;    Flag per riallineare la fas con quella di default (default = GS_BAD)
    
  Restituisce GS_GOOD in caso di successo, GS_CAN se l'operazione viene abortita
  altrimenti restituisce GS_BAD.
  N.B. Non viene cambiato il valore di <dir_dwg>.
-*/  
/*********************************************************/
int gsc_mod_fas(int prj, int cls, int sub, C_FAS *p_fas, int change_fas)
{
   C_PROJECT *pPrj;
   C_CLASS   *porigcls, *pCls;
   C_FAS     *p_origfas;
   int       conf = GS_BAD, DABlockToUpdate;
   long      SessionId, BitForFAS = 0;
   
   // Cerca progetto nella lista GEOsimAppl::PROJECTS
   if ((pPrj = (C_PROJECT *) GEOsimAppl::PROJECTS.search_key(prj)) == NULL) return GS_BAD;
   if ((porigcls = pPrj->find_class(cls, sub)) == NULL) return GS_BAD;
   
   if (!(p_origfas = porigcls->ptr_fas())) { GS_ERR_COD = eGSInvClassType; return GS_BAD; }
   
   DABlockToUpdate = is_block_ref_to_update(p_origfas->ref_block, p_origfas->file_ref_block,
                                            p_fas->ref_block, p_fas->file_ref_block);

   // se devo riallineare la FAS con quella di default oppure
   // se deve essere riapplicata la funzione di calcolo grafico oppure
   // se deve essere riapplicato il blocco di riferimento
   if (change_fas == GS_GOOD || 
       is_graph_calc_to_recalc(p_origfas->fun_graph_calc, p_origfas->file_graph_calc,
                               p_fas->fun_graph_calc, p_fas->file_graph_calc) ||
       DABlockToUpdate == GS_GOOD)
   {  // Non possono esserci sessioni di lavoro attive
      if (GS_CURRENT_WRK_SESSION) { GS_ERR_COD = eGSSessionsFound; return GS_BAD; }

      // "La modifica apportata richiede il riallineamento della banca dati che potrebbe impiegare molto tempo. Confermare la modifica."
      if (gsc_ddgetconfirm(gsc_msg(376), &conf) == GS_BAD) return GS_BAD;
      if (conf != GS_GOOD) return GS_CAN;

      // ricavo le differenze delle caratteristiche grafiche fra le 2 FAS
      BitForFAS = p_origfas->get_GraphDifferences(*p_fas);
   }

   // verifico fas su classe di appoggio
   if ((pCls = gsc_alloc_new_class(porigcls->get_category())) == NULL)
      return GS_BAD;
   if (porigcls->copy(pCls) == GS_BAD) { delete pCls; return GS_BAD; }

   if (p_fas->copy(pCls->ptr_fas()) == GS_BAD) { delete pCls; return GS_BAD; }

   // carico eventuali funzioni di calcolo in GSL.GSL del progetto della classe
   gsc_load_gsl(((C_PROJECT *) porigcls->ptr_id()->pPrj)->get_dir());

   if (pCls->is_validfas(pCls->get_type(),
                         (pCls->ptr_info()) ? pCls->ptr_info()->getDBConnection(OLD) : NULL,
                         pCls->ptr_attrib_list()) == GS_BAD)
      { gs_gsl_reload(); delete pCls; return GS_BAD; }
	// ricarico GSL.GSL giusto
	gs_gsl_reload();

   // verifico se la classe fa parte di una sessione di lavoro
   if (pCls->is_inarea(&SessionId) == GS_BAD || SessionId > 0)
      { GS_ERR_COD = eGSSessionsFound; delete pCls; return GS_BAD; }

   // riga commentata solo per ricordare che se uso questa funzione in questo punto
   // il database di access si rovina e la riga di GS_CLASS viene persa
   // in quanto altre funzioni richiamate da questa richiamano la lock_on_gs_class
   // che, evidentemente, se trova già il record bloccato fa casino.
   //if (pCls->lock_on_gs_class(&RsVett, &RsVettLen) == GS_BAD) return GS_BAD;

   if (conf == GS_GOOD)
   {
      // creo backup per la grafica della classe
      if (pCls->Backup(GSCreateBackUp) == GS_BAD)
         { delete pCls; return GS_BAD; }
      pCls->Backup(GSRestoreBackUp);
      pCls->Backup(GSCreateBackUp);

      // aggiorno la grafica
      if (pCls->UpdGraphData(change_fas, &BitForFAS, DABlockToUpdate) == GS_BAD)
      {
         int error_code = GS_ERR_COD;
   
         // restora il backup per la grafica della classe
         if (pCls->Backup(GSRestoreBackUp) == GS_BAD)
            // "\nL'operazione è fallita. Ripristinare manualmente
            // \ni files di backup della classe (vedi manuale)."
            acutPrintf(gsc_msg(636));
         delete pCls;
         GS_ERR_COD = error_code;
   
         return GS_BAD;
      }
      // cancello backup per la grafica della classe
      pCls->Backup(GSRemoveBackUp);
   
      if ((porigcls = gsc_find_class(prj, cls, sub)) == NULL) 
         return GS_BAD;
   }
   delete pCls;

   // modifico classe in GS_CLASS
   porigcls->mod_fas(p_fas);

   return GS_GOOD;
}

                                             
/*********************************************************/
/*.doc gsc_mod_coord <external>                          */
/*+
  Questa funzione modifica il sistema di coordinate di una classe 
  di entità di GEOsim.
  Parametri:
  int prj;           codice progetto
  int cls;           codice classe
  TCHAR *coord;      sistema di coordinate
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int gsc_mod_coord(int prj, int cls, TCHAR *coord)
{
   C_FAS   m_fas;
   C_CLASS *pCls;
  
   if ((pCls = gsc_find_class(prj, cls, 0)) == NULL) return GS_BAD;

   if (gsc_validcoord(coord) == GS_BAD) return GS_BAD;

   // da fare
   
   return GS_GOOD;
}


/*********************************************************/
/*.doc gsc_createclass <external> */
/*+
  Questa funzione crea una classe di entità di GEOsim.
  La protezione di questa operazione è garantita perchè è stato usato un 
  indice con modalità UNIQUE sul campo GS_ID, SUB_GS_ID e sul campo NAME 
  della tabella GS_CLASS.
  Questo garantisce che, se due utenti creano una classe nello stesso
  momento, potrebbe essere che entrambe abbiano lo stesso nuovo codice
  (GS_ID) ma solo uno dei due potrà inserirla, l'altro ritenterà con un
  nuovo codice. Se invece, mentre viene inserita una classe, un altro 
  utente aggiorna un altra classe aggiornandone il nome, questo potrebbe 
  entrare in conflitto con quello da inserire. Il programma
  dopo aver ritentato l'inserimento per GS_NUM_TEST volte, termina con un
  errore.

  Parametri:
  int     prj;         codice del progetto
  C_CLASS *pCls;       puntat. a oggetto classe già allocato e inizializzato
    
  Restituisce il codice dell'entità in caso di successo altrimenti restituisce 0.
-*/  
/*********************************************************/
int gsc_createclass(int prj, C_CLASS *pCls)
{
   C_PROJECT *pPrj;

   // Cerca progetto nella lista GEOsimAppl::PROJECTS
   if ((pPrj = (C_PROJECT *) GEOsimAppl::PROJECTS.search_key(prj)) == NULL) return GS_BAD;

   return pPrj->CreateClass(pCls); // creazione classe
}


/*********************************************************/
/*.doc gs_destroyclass <external> */
/*+
  Questa funzione è la versione funzione LISP della "gsc_destroyclass".
  Parametri:
  Lista di resbuf (<Password><codice progetto><codice classe>)
    
  Restituisce TRUE in caso di successo (anche parziale) altrimenti 
  restituisce nil.
-*/  
/*********************************************************/
int gs_destroyclass(void)
{
   presbuf arg = acedGetArgs();
   int     prj, cls, sub;
   TCHAR    *Password;

   acedRetNil();
   if (!arg || arg->restype != RTSTR) { GS_ERR_COD = eGSInvalidArg; return RTERROR; }
   Password = arg->resval.rstring;
   arg = arg->rbnext;
   // Legge nella lista dei parametri: progetto classe e sub
   if (arg_to_prj_cls_sub(&arg, &prj, &cls, &sub) == GS_BAD) return RTERROR;

   if (gsc_destroyclass(prj, cls, Password) == GS_BAD) return RTERROR;
   acedRetT();

   return RTNORM;
}

                           
/*********************************************************/
/*.doc gsc_destroyclass <external> */
/*+
  Questa funzione cancella tutto quello che è possibile cancellare
  di una classe di entità GEOsim. Questa funzione è da usare solo nel 
  caso non sia possibile caricare correttamente la classe e quindi ottenere
  un oggetto C_CLASS o suo derivato e perciò applicare la funzione del().
  Parametri:
  int prj;               codice progetto
  int cls;               codice classe
  const TCHAR *Password; Password dell'utente corrente (per controllo)
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
  N.B. Questa funzione potrebbe lasciare sporco il disco o tabelle di GEOsim.
       (es. distruzione di una classe la cui tabella si trova su una 
        macchina spenta...)
-*/  
/*********************************************************/
int gsc_destroyclass(int prj, int cls, const TCHAR *Password)
{
   C_FAMILY_LIST  family_list;
   C_FAMILY       *p_family;
   int            sub, sec;
   C_PROJECT      *pPrj;
   presbuf        p;
   TCHAR          *dir_prj;
   C_NODE         *pCls;
   C_INT_INT_LIST list_2int;
   C_INT_INT      *p_2int;
   C_DBCONNECTION *pConn, *pClsConn = NULL;
   _RecordsetPtr  pRs;
   long           RsClsLen = 0, i, WrkSessionId;
   C_RB_LIST      ColValues;
   C_STRING       TableRef, ClsTableRef, statement;
   bool           LinkedTable;

   // verifico abilitazione
   if (gsc_superuser() != GS_GOOD)
      { GS_ERR_COD = eGSOpNotAble; return RTERROR; } // non è un SUPER USER

   // verifico che la password sia corretta
   if (gsc_strcmp(Password, (TCHAR *) GEOsimAppl::GS_USER.pwd) != 0)
      { GS_ERR_COD = eGSInvalidPwd; return GS_BAD; }
   
   // Cerca progetto nella lista GEOsimAppl::PROJECTS
   if ((pPrj = (C_PROJECT *) GEOsimAppl::PROJECTS.search_key(prj)) == NULL) return GS_BAD;
   dir_prj = pPrj->get_dir();

   // verifico se la classe che si sta cancellando è legata ad altre
   if (gsc_getfamily(pPrj, &family_list) == GS_BAD) return GS_BAD;
   if (p_family = family_list.search_list(cls))
      // se ha legame con altre classi verifico se è la classe madre della famiglia
      if (p_family->get_key() != cls)
         { GS_ERR_COD = eGSMemberOfGroup; return GS_BAD; }

   // verifico se la classe fa parte di una sessione di lavoro
   if (gsc_is_inarea(prj, cls, &WrkSessionId) == GS_BAD || WrkSessionId > 0)
      { GS_ERR_COD = eGSSessionsFound; return GS_BAD; }

   // ricavo connessione e riferimento a tabella GS_CLASS
   if (pPrj->getClassesTabInfo(&pConn, &TableRef) == GS_BAD) return GS_BAD;
   statement = _T("SELECT * FROM ");
   statement += TableRef;
   statement += _T(" WHERE GS_ID=");
   statement += cls;
   if (pConn->ExeCmd(statement, pRs, adOpenDynamic, adLockOptimistic) == GS_BAD) return GS_BAD;
   
   while (gsc_isEOF(pRs) == GS_BAD)
   {
      RsClsLen++;
      if (gsc_DBReadRow(pRs, ColValues) == GS_BAD) break;

      ClsTableRef = GS_EMPTYSTR;
      if ((pClsConn = gsc_getConnectionFromRb(ColValues, &ClsTableRef)) != NULL)
      {
         if ((p = ColValues.CdrAssoc(_T("LINKED_TABLE"))) != NULL)
         {
            gsc_rb2Bool(p, &LinkedTable);
            if (!LinkedTable)
            {
               // cancello tabella classe + eventuale tabella link e indice (gruppo)
               if (pClsConn->ExistTable(ClsTableRef) == GS_GOOD)
                  pClsConn->DelTable(ClsTableRef.get_name());
               gsc_del_grp_tab_link(pClsConn, ClsTableRef);
            }
         }

         if (pClsConn->get_CatalogResourceType() == DirectoryRes)
         {
            C_STRING Catalog, Schema, Table, Path;

            if (pClsConn->split_FullRefTable(ClsTableRef, Catalog,
                                             Schema, Table) == GS_GOOD &&
                gsc_RefTable2Path(pClsConn->get_DBMSName(), Catalog, Schema, Table, Path) == GS_GOOD)
               // Cancello direttorio
               gsc_rmdir_from_path(Path.get_name());
         }
      }

      // cancello la riga in GS_CLASS
      if (gsc_DBDelRow(pRs) == GS_BAD) break;

      gsc_Skip(pRs);
   }
   gsc_DBCloseRs(pRs);

   C_FAS dummyFAS;
   
   // cancello le informazioni relative alle caratteristiche grafiche 
   // della classe ed eventuali sottoclassi
   dummyFAS.del_db(pPrj, cls);

   // cancello le informazioni relative alla sorgente grafica 
   // della classe ed eventuali sottoclassi
   // rimuovendo anche le risorse grafiche (disegni, cartelle ...)
   C_GPH_INFO *pDummyGphInfo;
   bool       erasedForced;

   for (i = 0; i < RsClsLen; i++)
   {
      erasedForced = true;

      if ((pDummyGphInfo = gsc_GphDataSrcFromDB(pPrj, cls, i)) != NULL)
      {
         if (pDummyGphInfo->del_db(true) == GS_GOOD) erasedForced = false;
         delete pDummyGphInfo;
      }
      if (erasedForced)
      {
         // cancello la riga in GS_CLASS_GRAPH_INFO
         if (pPrj->getClassGphDataSrcTabInfo(&pConn, &TableRef) == GS_BAD) return GS_BAD;
         statement = _T("DELETE FROM ");
         statement += TableRef;
         statement += _T(" WHERE CLASS_ID=");
         statement += cls;
         statement += _T(" AND SUB_CL_ID=");
         statement += i;
         if (pConn->ExeCmd(statement) == GS_BAD) return GS_BAD;
      }
   }

   // cancello lista connessioni in memoria per tutte le altre classi
   gsc_del_memconnect(pPrj, cls);
   
   // cancello lista connessioni nei DB
   gsc_del_db_conc(pPrj, cls, ALL);

   // cancello le relazioni tra classi per gruppo nei DB
   gsc_del_db_grp_rel(pPrj, cls);

   // cancello caratteristiche attributi della classe, eventuali sottoclassi e
   // secondarie legate alla classe
   gsc_del_db_carattattr(pPrj, cls, -1, -1);

   // Cancello la classe dal set di classi del progetto
   gsc_del_db_ClassSet(pPrj, cls);

   if (RsClsLen > 1 && ClsTableRef.len() > 0 && pClsConn) // se simulazione
   {
      C_STRING Catalog, Schema, TopoTableRef;

      if (pClsConn->split_FullRefTable(ClsTableRef, Catalog,
                                       Schema, TopoTableRef) == GS_GOOD)
      {
         // Cancellazione topologia
         C_TOPOLOGY topo;
         topo.set_type(TYPE_POLYLINE);  // tipologia di tipo rete
         if (topo.getTopoTabName(pClsConn, prj, cls, Catalog.get_name(), 
                                 Schema.get_name(), TopoTableRef) == GS_GOOD)
            if (pClsConn->ExistTable(TopoTableRef) == GS_GOOD)
               pClsConn->DelTable(TopoTableRef.get_name());
      }
   }

   // blocco tutte le secondarie della classe
   ColValues.remove_all();
   // setto il riferimento di GS_SEC (<catalogo>.<schema>.<tabella>)
   if (pPrj->getSecsTabInfo(&pConn, &TableRef) == GS_BAD) return GS_BAD;
   statement = _T("SELECT GS_ID, SUB_CL_ID FROM ");
   statement += TableRef;
   statement += _T(" WHERE CLASS_ID=");
   statement += cls;
   if (pConn->ExeCmd(statement, pRs, adOpenDynamic, adLockOptimistic) == GS_GOOD)
   {
      while (gsc_isEOF(pRs) == GS_BAD)
      {
         if (gsc_DBReadRow(pRs, ColValues) == GS_BAD) break;

         if ((p = ColValues.CdrAssoc(_T("GS_ID"))) != NULL)
         {
            if (gsc_rb2Int(p, &sec) == GS_BAD) sec = 0;

            if ((p = ColValues.CdrAssoc(_T("SUB_CL_ID"))) != NULL)
            {
               if (gsc_rb2Int(p, &sub) == GS_BAD) sub = 0;

               if ((p_2int = new C_INT_INT) == NULL) break;
               if (p_2int->set_key(sec) == GS_BAD || 
                   p_2int->set_type(sub) == GS_BAD) break;
               list_2int.add_tail(p_2int);
            }
         }

         gsc_Skip(pRs);
      }
      gsc_DBCloseRs(pRs);

      // distruggo tutte le secondarie
      p_2int = (C_INT_INT *) list_2int.get_head();
      while (p_2int)
      {
         gsc_destroy_tab_sec(prj, cls, p_2int->get_type(), p_2int->get_key(), Password);
         p_2int = (C_INT_INT *) list_2int.get_next();
      }  
   }

   // cancello abilitazioni alla classe per tutti gli utenti 
   gsc_delClassPermissions(prj, cls);

   // la cerco solo in memoria senza caricarla da DB
   if (pCls = pPrj->ptr_classlist()->C_LIST::search_key(cls))
      // se era caricata in memoria la cancello dalla lista
      pPrj->ptr_classlist()->remove(pCls);

   return GS_GOOD;
}   


///////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////
inline C_CLASS *gsc_find_class(int prj, int cls, int sub)
{
   C_PROJECT *pPrj, *pPrevPrj = (C_PROJECT *) GEOsimAppl::PROJECTS.get_cursor();
   C_CLASS   *pCls = NULL;
   C_LIST    *pClsList = NULL; // Liste classi

   do
   {
      // Cerca progetto nella lista GEOsimAppl::PROJECTS
      if ((pPrj = (C_PROJECT *) GEOsimAppl::PROJECTS.search_key(prj)) == NULL)
         { GS_ERR_COD = eGSInvalidPrjCode; break; }

      if ((pCls = pPrj->find_class(cls, sub)) == NULL) break;
   }
   while (0);

   GEOsimAppl::PROJECTS.set_cursor(pPrevPrj);

   return pCls;
}


inline int arg_to_prj_cls_sub(resbuf **arg, int *prj, int *cls, int *sub)
{
   // Legge codice progetto
   if (*arg==NULL || (*arg)->restype!=RTSHORT)
      { GS_ERR_COD = eGSInvalidArg; return GS_BAD; }
   *prj=(int)(*arg)->resval.rint;
   
   // Legge codice classe
   *arg=(*arg)->rbnext;
   if (*arg==NULL || (*arg)->restype!=RTSHORT)
      { GS_ERR_COD = eGSInvalidArg; return GS_BAD; }
   *cls=(int)(*arg)->resval.rint;
   
   *arg = (*arg)->rbnext;        
   if (sub==NULL ) return GS_GOOD;
   if (*arg==NULL || (*arg)->restype==RTLB || (*arg)->restype==RTLE)
      { *sub=0; return GS_GOOD; }  // Non sto cercando una sotto-classe

   // Legge codice sotto-classe
   if ((*arg)->restype!=RTSHORT) { GS_ERR_COD = eGSInvalidArg; return GS_BAD; }
   *sub = (int)(*arg)->resval.rint;
   *arg = (*arg)->rbnext;        

   return GS_GOOD;
}


inline C_CLASS *gsc_alloc_new_class(resbuf *arg)
{
   if (arg==NULL || arg->restype!=RTLB)              // Parentesi '(' 
                                { GS_ERR_COD=eGSInvRBType; return GS_BAD; }
   if ((arg=arg->rbnext)==NULL || arg->restype!=RTLB) // Parentesi '('
                                { GS_ERR_COD=eGSInvRBType; return GS_BAD; }
   if ((arg=arg->rbnext)==NULL || arg->restype!=RTSHORT) // CODE
                                { GS_ERR_COD=eGSInvRBType; return GS_BAD; }
   if ((arg=arg->rbnext)==NULL || arg->restype!=RTSHORT) // SUB-CODE
                                { GS_ERR_COD=eGSInvRBType; return GS_BAD; }
   if ((arg=arg->rbnext)==NULL || arg->restype!=RTSHORT) // CATEGORY
                                { GS_ERR_COD=eGSInvRBType; return GS_BAD; }
   return gsc_alloc_new_class((int)arg->resval.rint);
}

inline C_CLASS *gsc_alloc_new_class(int category)
{
   C_CLASS *punt;

   switch(category)
   {
      case CAT_SPAGHETTI: punt = new C_SPAGHETTI; break;
      case CAT_SUBCLASS : punt = new C_SUB;       break;
      case CAT_SIMPLEX  : punt = new C_SIMPLEX;   break;
      case CAT_GROUP  : punt = new C_GROUP;   break;
      case CAT_GRID     : punt = new C_CGRID;     break;
      case CAT_EXTERN   : punt = new C_EXTERN;    break;
      default : GS_ERR_COD = eGSInvClassType; return NULL;
   }
   if (!punt) { GS_ERR_COD = eGSOutOfMem; return NULL; }

   punt->ptr_id()->category = category; // Setta categoria

   return punt;
}


//-----------------------------------------------------------------------//
//////////////////  C_ID  INIZIO  /////////////////////////////////////////
//-----------------------------------------------------------------------//


// costruttore
C_ID::C_ID()
{
   pPrj     = NULL;
   code     = sub_code = category = type = 0;
   sel      = DESELECTED;
   abilit   = GSInvisibleData;
   name[0]  = usr_cmds[0] = _T('\0');
   modified = GS_BAD;
   Version  = gsc_msg(130); // Versione attuale di GEOsim
   view_enabled    = false;
   history_enabled = false;
}


int C_ID::copy(C_ID *out)
{
   if (!out) { GS_ERR_COD = eGSNotAllocVar; return GS_BAD; }
   out->pPrj     = pPrj;
   out->code     = code;
   out->sub_code = sub_code;
   out->category = category;
   out->type     = type;
   gsc_strcpy(out->name, name, MAX_LEN_CLASSNAME);
   out->Descr    = Descr;
   out->abilit   = abilit;
   out->sel      = sel;
   gsc_strcpy(out->usr_cmds, usr_cmds, MAX_LEN_FIELD);
   out->modified = modified;
   out->Version  = Version;
   out->view_enabled    = view_enabled;
   out->history_enabled = history_enabled;
   
   return GS_GOOD;
}  
                          

//-----------------------------------------------------------------------//
int C_ID::ToFile(C_STRING &filename, const TCHAR *sez)
{  
   C_PROFILE_SECTION_BTREE ProfileSections;
   bool                    Unicode = false;

   if (gsc_path_exist(filename) == GS_GOOD)
      if (gsc_read_profile(filename, ProfileSections, &Unicode) == GS_BAD) return GS_BAD;

   if (ToFile(ProfileSections, sez) == GS_BAD) return GS_BAD;

   return gsc_write_profile(filename, ProfileSections, Unicode);
}
int C_ID::ToFile(C_PROFILE_SECTION_BTREE &ProfileSections, const TCHAR *sez)
{
   C_BPROFILE_SECTION *ProfileSection;

   if (!(ProfileSection = (C_BPROFILE_SECTION *) ProfileSections.search(sez)))
   {
      if (ProfileSections.add(sez) == GS_BAD) return GS_BAD;
      ProfileSection = (C_BPROFILE_SECTION *) ProfileSections.get_cursor();
   }

   ProfileSection->set_entry(_T("ID.CODE"),       code);
   ProfileSection->set_entry(_T("ID.SUB_CODE"),   sub_code);
   ProfileSection->set_entry(_T("ID.CATEGORY"),   category);
   ProfileSection->set_entry(_T("ID.TYPE"),       type);
   ProfileSection->set_entry(_T("ID.NAME"),       name);
   ProfileSection->set_entry(_T("ID.DESCRIPTION"),Descr.get_name() ? Descr.get_name(): GS_EMPTYSTR);
   ProfileSection->set_entry(_T("ID.ABILIT"), abilit);
   ProfileSection->set_entry(_T("ID.SEL"), sel);
   ProfileSection->set_entry(_T("ID.USR_CMDS"), usr_cmds);
   ProfileSection->set_entry(_T("ID.MODIFIED"), modified);
   ProfileSection->set_entry(_T("ID.VERSION"), Version.get_name() ? Version.get_name(): GS_EMPTYSTR);
   ProfileSection->set_entry(_T("ID.VIEW_ENABLED"), view_enabled);
   ProfileSection->set_entry(_T("ID.HISTORY_ENABLED"), history_enabled);

   return GS_GOOD;
}
//-----------------------------------------------------------------------//
int C_ID::load(C_STRING &filename, const TCHAR *sez)
{
   C_PROFILE_SECTION_BTREE ProfileSections;

   if (gsc_read_profile(filename, ProfileSections) == GS_BAD) return GS_BAD;
   return load(ProfileSections, sez);
}
int C_ID::load(C_PROFILE_SECTION_BTREE &ProfileSections, const TCHAR *sez)
{
   C_BPROFILE_SECTION *ProfileSection;
   C_2STR_BTREE       *pProfileEntries;
   C_B2STR            *pProfileEntry;
   
   if (!(ProfileSection = (C_BPROFILE_SECTION *) ProfileSections.search(sez)))
      return GS_CAN;
   pProfileEntries = (C_2STR_BTREE *) ProfileSection->get_ptr_EntryList();

   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(_T("ID.CODE"))))
      code = _wtoi(pProfileEntry->get_name2());
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(_T("ID.SUB_CODE"))))
      sub_code = _wtoi(pProfileEntry->get_name2());
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(_T("ID.CATEGORY"))))
      category = _wtoi(pProfileEntry->get_name2());
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(_T("ID.TYPE"))))
      type = _wtoi(pProfileEntry->get_name2());
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(_T("ID.NAME"))))
      gsc_strcpy(name, pProfileEntry->get_name2(), MAX_LEN_CLASSNAME);
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(_T("ID.DESCRIPTION"))))
      Descr = pProfileEntry->get_name2();
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(_T("ID.ABILIT"))))
      abilit = (GSDataPermissionTypeEnum) _wtoi(pProfileEntry->get_name2());
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(_T("ID.SEL"))))
      sel = _wtoi(pProfileEntry->get_name2());
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(_T("ID.USR_CMDS"))))
      gsc_strcpy(usr_cmds, pProfileEntry->get_name2(), MAX_LEN_FIELD);
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(_T("ID.MODIFIED"))))
      modified = _wtoi(pProfileEntry->get_name2());
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(_T("ID.VERSION"))))
      Version = pProfileEntry->get_name2();
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(_T("ID.VIEW_ENABLED"))))
      view_enabled = (_wtoi(pProfileEntry->get_name2()) == 0) ? false : true;
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(_T("ID.HISTORY_ENABLED"))))
      history_enabled = (_wtoi(pProfileEntry->get_name2()) == 0) ? false : true;

   return GS_GOOD;
}


/*********************************************************/
/*.doc C_ID::to_rb                            <internal> */
/*+
  Questa funzione restituisce la C_ID sottoforma di lista
  di coppie di resbuf ((<proprietà> <valore>) ...).

  Restituisce la lista in caso di successo altrimenti restituisce NULL.
-*/  
/*********************************************************/
resbuf *C_ID::to_rb(void)
{
   return acutBuildList(RTLB,
                           RTSTR, _T("CODE"),
                           RTSHORT, code,
                        RTLE,
                        RTLB,
                           RTSTR, _T("SUB_CODE"),
                           RTSHORT, sub_code,
                        RTLE,
                        RTLB,
                           RTSTR, _T("CATEGORY"),
                           RTSHORT, category,
                        RTLE,
                        RTLB,
                           RTSTR, _T("TYPE"),
                           RTSHORT, type,
                        RTLE,
                        RTLB,
                           RTSTR, _T("NAME"),
                           RTSTR, name,
                        RTLE,
                        RTLB,
                           RTSTR, _T("DESCRIPTION"),
                           RTSTR, Descr.get_name() ? Descr.get_name(): GS_EMPTYSTR,
                        RTLE,
                        RTLB,
                           RTSTR, _T("ABILIT"),
                           RTSHORT, abilit,
                        RTLE,
                        RTLB,
                           RTSTR, _T("SEL"),
                           RTSHORT, sel,
                        RTLE,
                        RTLB,
                           RTSTR, _T("USR_CMDS"),
                           RTSTR, usr_cmds,
                        RTLE,
                        RTLB,
                           RTSTR, _T("VERSION"),
                           RTSTR, Version.get_name() ? Version.get_name(): GS_EMPTYSTR,
                        RTLE,
                        RTLB,
                           RTSTR, _T("VIEW_ENABLED"),
                           view_enabled ? RTT : RTNIL,
                        RTLE,
                        RTLB,
                           RTSTR, _T("HISTORY_ENABLED"),
                           history_enabled ? RTT : RTNIL,
                        RTLE,
                        0);
} 


/*********************************************************/
/*.doc C_ID::from_rb                         <internal> */
/*+
  Questa funzione legge le proprietà della C_ID sottoforma di lista
  di coppie di resbuf ((<proprietà> <valore>) ...).
  Parametri:
  resbuf *rb;           Lista di valori

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_ID::from_rb(resbuf *rb)
{
   presbuf p;
   
   if (rb == NULL) { GS_ERR_COD = eGSInvalidArg; return GS_BAD; }
   if (rb->restype == RTNIL) return GS_GOOD;

   if ((p = gsc_CdrAssoc(_T("CODE"), rb, FALSE)))
      if (gsc_rb2Int(p, &code) == GS_BAD) { GS_ERR_COD = eGSInvRBType; return GS_BAD; }
   if ((p = gsc_CdrAssoc(_T("SUB_CODE"), rb, FALSE)))
      if (gsc_rb2Int(p, &sub_code) == GS_BAD) { GS_ERR_COD = eGSInvRBType; return GS_BAD; }
   if ((p = gsc_CdrAssoc(_T("CATEGORY"), rb, FALSE)))
      if (gsc_rb2Int(p, &category) == GS_BAD) { GS_ERR_COD = eGSInvRBType; return GS_BAD; }
   if ((p = gsc_CdrAssoc(_T("TYPE"), rb, FALSE)))
      if (gsc_rb2Int(p, &type) == GS_BAD) { GS_ERR_COD = eGSInvRBType; return GS_BAD; }
   if ((p = gsc_CdrAssoc(_T("NAME"), rb, FALSE)))
      if (p->restype == RTSTR)
      {
         if (wcslen(p->resval.rstring) >= MAX_LEN_CLASSNAME)
            { GS_ERR_COD = eGSStringTooLong; return GS_BAD; }
         gsc_strcpy(name, p->resval.rstring, MAX_LEN_CLASSNAME);
         gsc_alltrim(name);
      }
      else
         { GS_ERR_COD = eGSInvRBType; return GS_BAD; }
   if ((p = gsc_CdrAssoc(_T("DESCRIPTION"), rb, FALSE)))
      if (p->restype == RTSTR)
      {
         Descr = p->resval.rstring;
         Descr.alltrim();
      }
      else
         { GS_ERR_COD = eGSInvRBType; return GS_BAD; }
   if ((p = gsc_CdrAssoc(_T("ABILIT"), rb, FALSE)))
      if (gsc_rb2Int(p, (int *) &abilit) == GS_BAD) { GS_ERR_COD = eGSInvRBType; return GS_BAD; }
   if ((p = gsc_CdrAssoc(_T("SEL"), rb, FALSE)))
      if (gsc_rb2Int(p, &sel) == GS_BAD) { GS_ERR_COD = eGSInvRBType; return GS_BAD; }
   if ((p = gsc_CdrAssoc(_T("USR_CMDS"), rb, FALSE)))
      if (p->restype == RTSTR)
      {
         if (wcslen(p->resval.rstring) >= MAX_LEN_FIELD)
            { GS_ERR_COD = eGSStringTooLong; return GS_BAD; }
         gsc_strcpy(usr_cmds, p->resval.rstring, MAX_LEN_FIELD);
         gsc_alltrim(usr_cmds);
      }
      else
         { GS_ERR_COD = eGSInvRBType; return GS_BAD; }
   if ((p = gsc_CdrAssoc(_T("VERSION"), rb, FALSE)))
      if (p->restype == RTSTR)
      {
         Version = p->resval.rstring;
         Version.alltrim();
      }
      else
         { GS_ERR_COD = eGSInvRBType; return GS_BAD; }
   if ((p = gsc_CdrAssoc(_T("VIEW_ENABLED"), rb, FALSE)))
      gsc_rb2Bool(p, &view_enabled);
   else
      view_enabled = false;
   if ((p = gsc_CdrAssoc(_T("HISTORY_ENABLED"), rb, FALSE)))
      gsc_rb2Bool(p, &history_enabled);
   else
      history_enabled = false;

   return GS_GOOD;
} 


/*********************************************************/
/*.doc from_rb_db <internal> */
/*+
  Questa funzione carica i dati di una C_ID da un resbuf generato dalla
  lettura su tabella GS_CLASS.
  Parametri:
  C_RB_LIST &ColValues;                lista colonna-valore della riga di GS_CLASS
  GSDataPermissionTypeEnum cod_level;  livello di abilitazione per la classe
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_ID::from_rb_db(C_RB_LIST &ColValues, GSDataPermissionTypeEnum cod_level)
{
   presbuf p_cls;
   
   if ((p_cls = ColValues.CdrAssoc(DEFAULT_KEY_ATTR)) == NULL || // GS_ID
       gsc_rb2Int(p_cls, &code) == GS_BAD)
      { GS_ERR_COD = eGSInvClassCode; return GS_BAD; }

   if ((p_cls = ColValues.CdrAssoc(_T("SUB_GS_ID"))) == NULL)  // SUB_GS_ID
      { GS_ERR_COD = eGSInvClassCode; return GS_BAD; }
   if (gsc_rb2Int(p_cls, &sub_code) == GS_BAD) sub_code = 0;

   if ((p_cls = ColValues.CdrAssoc(_T("CATEGORY"))) == NULL || // CATEGORY
       gsc_rb2Int(p_cls, &category) == GS_BAD)
      { GS_ERR_COD = eGSInvCategoryType; return GS_BAD; }

   if ((p_cls = ColValues.CdrAssoc(_T("TYPE"))) == NULL ||     // TYPE
       gsc_rb2Int(p_cls, &type) == GS_BAD)
      { GS_ERR_COD = eGSInvClassType; return GS_BAD; }

   if ((p_cls = ColValues.CdrAssoc(_T("NAME"))) == NULL)     // NAME
      { GS_ERR_COD = eGSInvClassName; return GS_BAD; }
   if (p_cls->restype == RTSTR)
      wcscpy(name, gsc_alltrim(p_cls->resval.rstring));
   else
      if (p_cls->restype == RTNONE) wcscpy(name, GS_EMPTYSTR);
      else { GS_ERR_COD = eGSInvClassName; return GS_BAD; }

   if ((p_cls = ColValues.CdrAssoc(_T("DESCRIPTION"))) == NULL) // DESCRIPTION
       { GS_ERR_COD = eGSInvClassDescr; return GS_BAD; }
   if (p_cls->restype == RTSTR) Descr = p_cls->resval.rstring;
   else Descr.clear();

   abilit = cod_level;

   if ((p_cls = ColValues.CdrAssoc(_T("USR_CMDS"))) == NULL) // USR_CMDS
      { GS_ERR_COD = eGSInvUsrCmd; return GS_BAD; }
   if (p_cls->restype == RTSTR)
      gsc_strcpy(usr_cmds, gsc_alltrim(p_cls->resval.rstring), MAX_LEN_FIELD);
   else
      if (p_cls->restype == RTNONE) wcscpy(usr_cmds, GS_EMPTYSTR);
      else { GS_ERR_COD = eGSInvUsrCmd; return GS_BAD; }

   if ((p_cls = ColValues.CdrAssoc(_T("VERSION"))) == NULL) // VERSION
      { GS_ERR_COD = eGSInvVersion; return GS_BAD; }
   if (p_cls->restype == RTSTR) Version = p_cls->resval.rstring;
   else Version.clear();

   if ((p_cls = ColValues.CdrAssoc(_T("VIEW_ENABLED"))) != NULL) // VIEW_ENABLED
      gsc_rb2Bool(p_cls, &view_enabled);
   else
      view_enabled = false;

   if ((p_cls = ColValues.CdrAssoc(_T("HISTORY_ENABLED"))) != NULL) // HISTORY_ENABLED
      gsc_rb2Bool(p_cls, &history_enabled);
   else
      history_enabled = false;

   return GS_GOOD;
}  
   

/*********************************************************/
/*.doc to_rb_db <internal> */
/*+
  Questa funzione scarica i dati di una C_ID in un resbuf per scrivere
  nella tabella GS_CLASS.
  Parametri:
  presbuf *colvalues;    lista colonna-valore della riga di GS_CLASS
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_ID::to_rb_db(presbuf *colvalues)
{
   if ((*colvalues = acutBuildList(RTLB, RTSTR, DEFAULT_KEY_ATTR, RTSHORT, code, RTLE, 
                                   RTLB, RTSTR, _T("SUB_GS_ID"), RTSHORT, sub_code, RTLE,
                                   RTLB, RTSTR, _T("CATEGORY"), RTSHORT, category, RTLE,
                                   RTLB, RTSTR, _T("TYPE"), RTSHORT, type, RTLE,
                                   RTLB, RTSTR, _T("NAME"), RTSTR, name, RTLE,
                                   RTLB, RTSTR, _T("DESCRIPTION"), RTSTR, (Descr.get_name() ? Descr.get_name(): GS_EMPTYSTR), RTLE,
                                   RTLB, RTSTR, _T("USR_CMDS"), RTSTR, usr_cmds, RTLE,
                                   RTLB, RTSTR, _T("VERSION"), RTSTR, (Version.get_name() ? Version.get_name(): GS_EMPTYSTR), RTLE,
                                   RTLB, RTSTR, _T("VIEW_ENABLED"), view_enabled ? RTT : RTNIL, RTLE,
                                   RTLB, RTSTR, _T("HISTORY_ENABLED"), history_enabled ? RTT : RTNIL, RTLE,
                                   0)) == NULL)
      { GS_ERR_COD = eGSOutOfMem; return GS_BAD; }
   
   return GS_GOOD;
}  


/****************************************************************************/
/*.doc C_ID::refresh_abilit                                      <external> */
/*+
  Questa funzione rilegge le abilitazioni date all'utente corrente per questa classe.
  Parametri:

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/
/******************************************************************************/
int C_ID::refresh_abilit()
{  
   if (gsc_superuser() == GS_GOOD)
      abilit = GSUpdateableData;   // classi modificabili 
   else
   {
      C_INT_INT_LIST UsrClsList; // lista classi utente
      C_INT_INT      *pUsrCls;

      // lista classi utente
      if (gsc_getClassPermissions(GEOsimAppl::GS_USER.code, 
                                  pPrj->get_key(), UsrClsList) == GS_BAD)
         return GS_BAD;
      if ((pUsrCls = (C_INT_INT *) UsrClsList.search_key(code)))
         abilit = (GSDataPermissionTypeEnum) pUsrCls->get_type();
      else
         abilit = GSInvisibleData;
   }

   return GS_GOOD;
}


/****************************************************************************/
/*.doc C_ID::reportHTML                                          <external> */
/*+
  Questa funzione stampa su un file HTML i dati della C_ID escludendo:
  1) abilit (se invisib, in sola lettura , modificabile, accesso esclusivo)
  2) sel (se selezionato per la prossima estrazione)
  3) usr_cmds (sintassi per descrivere la chiamata ad uno o più comandi utente)
  Parametri:
  FILE *file;     puntatore a file
  bool SynthMode; Opzionale. Flag di modalità di report.
                  Se = true attiva il report sintetico (default = false)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/
/******************************************************************************/
int C_ID::reportHTML(FILE *file, bool SynthMode)
{  
   C_STRING StrType, StrCategory;
   C_STRING TitleBorderColor("#808080"), TitleBgColor("#c0c0c0");
   C_STRING BorderColor("#00CCCC"), BgColor("#99FFFF");

   if (fwprintf(file, _T("\n<table bordercolor=\"%s\" bgcolor=\"%s\" width=\"100%%\" border=\"1\">"),
                TitleBorderColor.get_name(), TitleBgColor.get_name()) < 0)
      { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

   // "Dati Identificativi Classe"
   if (fwprintf(file, _T("\n<tr><td align=\"center\"><b><font size=\"4\">%s<br><u>%s</u></font></b></td></tr></table><br>"),
                gsc_msg(751), name) < 0)
      { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

   // intestazione tabella
   if (fwprintf(file, _T("\n<table bordercolor=\"%s\" cellspacing=\"2\" cellpadding=\"2\" border=\"1\">"), 
                BorderColor.get_name()) < 0)
      { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

   // "Nome"
   if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%s</td></tr>"),
                BgColor.get_name(), gsc_msg(628), name) < 0)
      { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

   if (!SynthMode)
   {
      // "Descrizione"
      if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%s</td></tr>"),
                   BgColor.get_name(), gsc_msg(794),
                   (Descr.len() > 0) ? Descr.get_name() : _T("&nbsp;")) < 0)
         { GS_ERR_COD = eGSWriteFile; return GS_BAD; }
      // "Progetto"
      if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\" width=\"30%%\"><b>%s:</b></td><td width=\"70%%\">%s</td></tr>"),
                   BgColor.get_name(), gsc_msg(326), ((C_PROJECT *) pPrj)->get_name()) < 0)
         { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

      // "Codice"
      if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%d</td></tr>"),
                   BgColor.get_name(), gsc_msg(624), code) < 0)
         { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

      // "Sottocodice"
      if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%d</td></tr>"),
                   BgColor.get_name(), gsc_msg(625), sub_code) < 0)
         { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

      // "Categoria"
      getClsCategoryDescr(category, StrCategory);
      if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%s</td></tr>"),
                   BgColor.get_name(), gsc_msg(626), StrCategory.get_name()) < 0)
         { GS_ERR_COD = eGSWriteFile; return GS_BAD; }
   }

   if (category == CAT_SIMPLEX || sub_code > 0) gsc_getClsTypeDescr(type, StrType);
   else StrType = GS_EMPTYSTR;

   // "Tipo"
   if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%s</td></tr>"),
                BgColor.get_name(), gsc_msg(627), StrType.get_name()) < 0)
      { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

   if (!SynthMode)
   {
      // "Versione"
      if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%s</td></tr>"),
                   BgColor.get_name(), gsc_msg(64),
                   (Version.len() > 0) ? Version.get_name() : _T("&nbsp;")) < 0)
         { GS_ERR_COD = eGSWriteFile; return GS_BAD; }
      // "Abilitazione a viste SQL"
      if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%s</td></tr>"),
                   BgColor.get_name(), gsc_msg(1051),
                   (view_enabled) ? gsc_msg(774) : gsc_msg(775)) < 0) // "Sì", "No"
         { GS_ERR_COD = eGSWriteFile; return GS_BAD; }
      // "Abilitazione a storicizzazione"
      if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%s</td></tr>"),
                   BgColor.get_name(), gsc_msg(1052),
                   (history_enabled) ? gsc_msg(774) : gsc_msg(775)) < 0) // "Sì", "No"
         { GS_ERR_COD = eGSWriteFile; return GS_BAD; }
   }

   // fine tabella
   if (fwprintf(file, _T("\n</table><br><br>")) < 0)
      { GS_ERR_COD = eGSWriteFile; return GS_BAD; }
   
   return GS_GOOD;
}  


//-----------------------------------------------------------------------//
//////////////////  C_ID   FINE    ////////////////////////////////////////
//////////////////  C_FAS  INIZIO  ////////////////////////////////////////
//-----------------------------------------------------------------------//


// costruttore
C_FAS::C_FAS() : C_NODE()
{
   color.setByLayer();
   width = elevation = rotation = thickness = 0;
   line_scale = block_scale = h_text = 1;
   gsc_strcpy(line,  DEFAULT_LINETYPE, MAX_LEN_LINETYPENAME);
   gsc_strcpy(style, DEFAULT_TEXTSTYLE, MAX_LEN_TEXTSTYLENAME);
   gsc_strcpy(layer, DEFAULT_LAYER, MAX_LEN_LAYERNAME);
   gsc_strcpy(block, DEFAULT_BLOCK, MAX_LEN_BLOCKNAME);
   
   gsc_strcpy(hatch, DEFAULT_HATCH, MAX_LEN_HATCHNAME);
   gsc_strcpy(hatch_layer, DEFAULT_LAYER, MAX_LEN_LAYERNAME);
   hatch_color.setByLayer();
   hatch_scale    = 1;
   hatch_rotation = 0;
   dimension_style = DEFAULT_DIMSTYLE;

   file_ref_block = ref_block = NULL;
   file_graph_calc = fun_graph_calc = NULL;
}
C_FAS::~C_FAS() {}


int C_FAS::copy(C_FAS *out)
{
   if (!out) { GS_ERR_COD = eGSNotAllocVar; return GS_BAD; }
   gsc_strcpy(out->line,  line, MAX_LEN_LINETYPENAME);
   gsc_strcpy(out->style, style, MAX_LEN_TEXTSTYLENAME);
   gsc_strcpy(out->layer, layer, MAX_LEN_LAYERNAME);
   gsc_strcpy(out->block, block, MAX_LEN_BLOCKNAME);
   out->color     = color;
   out->width     = width;
   out->elevation = elevation;
   out->block_scale = block_scale;
   out->line_scale = line_scale;
   out->rotation  = rotation;
   out->h_text    = h_text;
   out->thickness = thickness;

   gsc_strcpy(out->hatch, hatch, MAX_LEN_HATCHNAME);
   gsc_strcpy(out->hatch_layer, hatch_layer, MAX_LEN_LAYERNAME);
   out->hatch_color    = hatch_color;
   out->hatch_scale    = hatch_scale;
   out->hatch_rotation = hatch_rotation;

   if (out->file_ref_block)
      { free(out->file_ref_block); out->file_ref_block = NULL; }
   if (file_ref_block)
      if ((out->file_ref_block = gsc_tostring(file_ref_block)) == NULL) return GS_BAD;

   if (out->ref_block)
      { free(out->ref_block); out->ref_block = NULL; }
   if (ref_block)
      if ((out->ref_block = gsc_tostring(ref_block)) == NULL) return GS_BAD;

   if (out->file_graph_calc)
      { free(out->file_graph_calc); out->file_graph_calc = NULL; }
   if (file_graph_calc)
      if ((out->file_graph_calc = gsc_tostring(file_graph_calc)) == NULL) return GS_BAD;

   if (out->fun_graph_calc)
      { free(out->fun_graph_calc); out->fun_graph_calc = NULL; }
   if (fun_graph_calc)
      if ((out->fun_graph_calc = gsc_tostring(fun_graph_calc)) == NULL) return GS_BAD;

   out->dimension_style = dimension_style;

   return GS_GOOD;
}


/*********************************************************/
/*.doc C_FAS::ToFile                            <internal> */
/*+
  Questa funzione salva su file i dati della C_FAS.
  Parametri:
  TCHAR *filename;      file in cui scrivere le informazioni
  const TCHAR *sez;     nome della sezione in cui scrivere

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_FAS::ToFile(C_STRING &filename, const TCHAR *sez)
{
   C_PROFILE_SECTION_BTREE ProfileSections;
   bool                    Unicode = false;

   if (gsc_path_exist(filename) == GS_GOOD)
      if (gsc_read_profile(filename, ProfileSections, &Unicode) == GS_BAD) return GS_BAD;

   if (ToFile(ProfileSections, sez) == GS_BAD) return GS_BAD;

   return gsc_write_profile(filename, ProfileSections, Unicode);
}
int C_FAS::ToFile(C_PROFILE_SECTION_BTREE &ProfileSections, const TCHAR *sez)
{
   C_BPROFILE_SECTION *ProfileSection;
   C_STRING           Buff;

   if (!(ProfileSection = (C_BPROFILE_SECTION *) ProfileSections.search(sez)))
   {
      if (ProfileSections.add(sez) == GS_BAD) return GS_BAD;
      ProfileSection = (C_BPROFILE_SECTION *) ProfileSections.get_cursor();
   }

   color.getString(Buff); // converto il valore in stringa
   ProfileSection->set_entry(_T("FAS.COLOR"), Buff.get_name());
   ProfileSection->set_entry(_T("FAS.HATCH"), hatch);
   ProfileSection->set_entry(_T("FAS.HATCH_LAYER"), hatch_layer);
   hatch_color.getString(Buff); // converto il valore in stringa
   ProfileSection->set_entry(_T("FAS.HATCH_COLOR"), Buff.get_name());
   ProfileSection->set_entry(_T("FAS.HATCH_SCALE"), hatch_scale);
   ProfileSection->set_entry(_T("FAS.HATCH_ROTATION"), hatch_rotation);
   ProfileSection->set_entry(_T("FAS.LINE_TYPE"), line);
   ProfileSection->set_entry(_T("FAS.TEXT_STYLE"), style);
   ProfileSection->set_entry(_T("FAS.LAYER"), layer);
   ProfileSection->set_entry(_T("FAS.BLOCK_NAME"), block);
   ProfileSection->set_entry(_T("FAS.WIDTH"), width);
   ProfileSection->set_entry(_T("FAS.ELEVATION"), elevation);
   ProfileSection->set_entry(_T("FAS.BLOCK_SCALE"), block_scale);
   ProfileSection->set_entry(_T("FAS.LINE_SCALE"), line_scale);
   ProfileSection->set_entry(_T("FAS.ROTATION"), rotation);
   ProfileSection->set_entry(_T("FAS.HEIGHT_TEXT"), h_text);
   ProfileSection->set_entry(_T("FAS.THICKNESS"), thickness);

   if (file_ref_block)
   {  // converto path con alias host
      Buff = file_ref_block;
      if (gsc_drive2nethost(Buff) == GS_BAD) return GS_BAD;
   }
   else Buff = GS_EMPTYSTR;
   ProfileSection->set_entry(_T("FAS.REF_BLOCK_FILE"), Buff.get_name());

   if (ref_block) Buff = ref_block;
   else Buff = GS_EMPTYSTR;
   ProfileSection->set_entry(_T("FAS.REF_BLOCK_NAME"), Buff.get_name());

   if (file_graph_calc)
   {  // converto path con alias host
      Buff = file_graph_calc;
      if (gsc_drive2nethost(Buff) == GS_BAD) return GS_BAD;
   }
   else Buff = GS_EMPTYSTR;
   ProfileSection->set_entry(_T("FAS.GRAPH_CALC_FILE"), Buff.get_name());

   if (fun_graph_calc) Buff = fun_graph_calc;
   else Buff = GS_EMPTYSTR;
   ProfileSection->set_entry(_T("FAS.GRAPH_CALC_FUNC"), Buff.get_name());

   if (dimension_style.get_name()) Buff = dimension_style;
   else Buff = GS_EMPTYSTR;
   ProfileSection->set_entry(_T("FAS.DIM_STYLE"), Buff.get_name());

   return GS_GOOD;
}
//-----------------------------------------------------------------------//
int C_FAS::load(C_STRING &filename, const TCHAR *sez)
{
   C_PROFILE_SECTION_BTREE ProfileSections;

   if (gsc_read_profile(filename, ProfileSections) == GS_BAD) return GS_BAD;
   return load(ProfileSections, sez);
}
int C_FAS::load(C_PROFILE_SECTION_BTREE &ProfileSections, const TCHAR *sez)
{
   C_BPROFILE_SECTION *ProfileSection;
   C_2STR_BTREE       *pProfileEntries;
   C_B2STR            *pProfileEntry;
   C_STRING           Buff;
   
   if (!(ProfileSection = (C_BPROFILE_SECTION *) ProfileSections.search(sez)))
      return GS_CAN;
   pProfileEntries = (C_2STR_BTREE *) ProfileSection->get_ptr_EntryList();

   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(_T("FAS.COLOR"))))
      color.setString(pProfileEntry->get_name2());
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(_T("FAS.HATCH"))))
      gsc_strcpy(hatch, pProfileEntry->get_name2(), MAX_LEN_HATCHNAME);
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(_T("FAS.HATCH_LAYER"))))
      gsc_strcpy(hatch_layer, pProfileEntry->get_name2(), MAX_LEN_LAYERNAME);
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(_T("FAS.HATCH_COLOR"))))
      hatch_color.setString(pProfileEntry->get_name2());
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(_T("FAS.HATCH_SCALE"))))
      hatch_scale = _wtof(pProfileEntry->get_name2());
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(_T("FAS.HATCH_ROTATION"))))
      hatch_rotation = _wtof(pProfileEntry->get_name2());
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(_T("FAS.LINE_TYPE"))))
      gsc_strcpy(line, pProfileEntry->get_name2(), MAX_LEN_LINETYPENAME);
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(_T("FAS.TEXT_STYLE"))))
      gsc_strcpy(style, pProfileEntry->get_name2(), MAX_LEN_TEXTSTYLENAME);
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(_T("FAS.LAYER"))))
      gsc_strcpy(layer, pProfileEntry->get_name2(), MAX_LEN_LAYERNAME);
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(_T("FAS.BLOCK_NAME"))))
      gsc_strcpy(block, pProfileEntry->get_name2(), MAX_LEN_BLOCKNAME);
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(_T("FAS.WIDTH"))))
      width = _wtof(pProfileEntry->get_name2());
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(_T("FAS.ELEVATION"))))
      elevation = _wtof(pProfileEntry->get_name2());
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(_T("FAS.BLOCK_SCALE"))))
      block_scale = _wtof(pProfileEntry->get_name2());
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(_T("FAS.LINE_SCALE"))))
      line_scale = _wtof(pProfileEntry->get_name2());
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(_T("FAS.HEIGHT_TEXT"))))
      h_text = _wtof(pProfileEntry->get_name2());
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(_T("FAS.THICKNESS"))))
      thickness = _wtof(pProfileEntry->get_name2());
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(_T("FAS.REF_BLOCK_FILE"))))
   {  // converto path con uno senza alias host
      Buff = pProfileEntry->get_name2();    
      if (gsc_nethost2drive(Buff) == GS_BAD) return GS_BAD;
      if (file_ref_block) free(file_ref_block);
      file_ref_block = Buff.cut();
   }
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(_T("FAS.REF_BLOCK_NAME"))))
   {
      Buff = pProfileEntry->get_name2();    
      if (ref_block) free(ref_block);
      ref_block = Buff.cut();
   }
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(_T("FAS.GRAPH_CALC_FILE"))))
   {  // converto path con uno senza alias host
      Buff = pProfileEntry->get_name2();    
      if (gsc_nethost2drive(Buff) == GS_BAD) return GS_BAD;
      if (file_graph_calc) free(file_graph_calc);
      file_graph_calc = Buff.cut();
   }
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(_T("FAS.GRAPH_CALC_FUNC"))))
   {
      Buff = pProfileEntry->get_name2();    
      if (fun_graph_calc) free(fun_graph_calc);
      fun_graph_calc = Buff.cut();
   }
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(_T("FAS.DIM_STYLE"))))
      dimension_style = pProfileEntry->get_name2();

   return GS_GOOD;
}
int C_FAS::load(ads_name ent)
{
   int       result;
   presbuf   pRbe;
   C_RB_LIST Rbe;
   C_STRING  entType;
   ads_point pPoint;

   do
   {
      pPoint[0] = 0.0; pPoint[1] = 0.0; pPoint[2] = 0.0; 
      result = GS_BAD;
      // Ricavo le caratteristiche della entità
      if ((Rbe << ads_entget(ent)) == NULL) break;
      // Ricavo il tipo di entità (0)
      if ((pRbe = Rbe.SearchType(0)) != NULL) entType = pRbe->resval.rstring;
      // Ricavo le coordinate (10)
      if ((pRbe = Rbe.SearchType(10)) != NULL) ads_point_set(pRbe->resval.rpoint, pPoint);
      // Se ent è un HATCH ricavo l'hatch 
      if (entType.comp(_T("HATCH")) == 0)
      {
         if ((pRbe = Rbe.SearchType(2)) != NULL) gsc_strcpy(hatch, pRbe->resval.rstring, MAX_LEN_HATCHNAME);
         gsc_get_color(ent, hatch_color);
         // Ricavo la scala (41)
         if ((pRbe = Rbe.SearchType(41)) != NULL) hatch_scale = pRbe->resval.rreal;
         // Ricavo il layer (8)
         if ((pRbe = Rbe.SearchType(8)) != NULL) gsc_strcpy(hatch_layer, pRbe->resval.rstring, MAX_LEN_LAYERNAME);
         // Ricavo la rotazione (52)
         if ((pRbe = Rbe.SearchType(52)) != NULL) hatch_rotation = pRbe->resval.rreal;
      }
      else
      {
         gsc_get_color(ent, color);
         // Se ent è INSERT ricavo la scala (41)
         if (entType.comp(_T("INSERT")) == 0)
            if ((pRbe = Rbe.SearchType(41)) != NULL) block_scale = pRbe->resval.rreal;
         // Ricavo il layer (8)
         if ((pRbe = Rbe.SearchType(8)) != NULL) gsc_strcpy(layer, pRbe->resval.rstring, MAX_LEN_LAYERNAME);
      }

      // Se ent è POLYLINE oppure LWPOLYLINE
      if (entType.comp(_T("POLYLINE")) == 0 || entType.comp(_T("LWPOLYLINE")) == 0)
      {
         // ricavo il tipo di linea (6)
         if ((pRbe = Rbe.SearchType(6)) != NULL) gsc_strcpy(line, pRbe->resval.rstring, MAX_LEN_LINETYPENAME);
         // ricavo la scala del tipo linea (48)
         if ((pRbe = Rbe.SearchType(48)) != NULL) line_scale = pRbe->resval.rreal;
         // ricavo la larghezza (40)
         if ((pRbe = Rbe.SearchType(40)) != NULL) width = pRbe->resval.rreal;
      }

      // Se ent è TEXT oppure MTEXT ricavo il nome dello stile (7)
      if (entType.comp( _T("TEXT")) == 0 || entType.comp(_T("MTEXT")) == 0)
         if ((pRbe = Rbe.SearchType(7)) != NULL) gsc_strcpy(style, pRbe->resval.rstring, MAX_LEN_TEXTSTYLENAME);

      // Se ent è INSERT ricavo il nome del blocco (2)
      if (entType.comp( _T("INSERT")) == 0)
         if ((pRbe = Rbe.SearchType(2)) != NULL) gsc_strcpy(block, pRbe->resval.rstring, MAX_LEN_BLOCKNAME);

      // Ricavo l'elevazione (cambia in base all'entità)
      if (entType.comp(_T("LWPOLYLINE")) == 0)
      {
         if ((pRbe = Rbe.SearchType(38)) != NULL) elevation = pRbe->resval.rreal;
      }
      else if (entType.comp(_T("POLYLINE")) == 0 || 
               entType.comp(_T("INSERT")) == 0 || 
               entType.comp(_T("TEXT")) == 0 ||
               entType.comp(_T("MTEXT")) == 0)
      {
         elevation = pPoint[2];
      }
      // Se ent è INSERT ricavo la rotazione (50)
      if (entType.comp(_T("INSERT")) == 0)
         if ((pRbe = Rbe.SearchType(50)) != NULL) rotation = pRbe->resval.rreal;
      // Se ent è TEXT oppure MTEXT ricavo l'altezza (40)
      if (entType.comp(_T("TEXT")) == 0 || 
          entType.comp(_T("MTEXT")) == 0)
         if ((pRbe = Rbe.SearchType(40)) != NULL) h_text = pRbe->resval.rreal;
      // Ricavo il thickness (Polyline, Text)
      if (entType.comp(_T("TEXT")) == 0 || 
          entType.comp(_T("POLYLINE")) == 0 || 
          entType.comp(_T("LWPOLYLINE")) == 0)
         if ((pRbe = Rbe.SearchType(39)) != NULL) thickness = pRbe->resval.rreal;
      // Ricavo lo stile di quotatura
      if (entType.comp(_T("DIMENSION")) == 0)
         if ((pRbe = Rbe.SearchType(3)) != NULL) dimension_style = pRbe->resval.rstring;

      result = GS_GOOD;
   }
   while (0);
   if (result == GS_BAD)
      GS_ERR_COD = eGSInvEntityOp;

   return result;
}


/*********************************************************/
/*.doc C_FAS::to_rb                            <internal> */
/*+
  Questa funzione restituisce la FAS sottoforma di lista
  di coppie di resbuf ((<proprietà> <valore>) ...).
  Parametri:
  bool ConvertDrive2nethost; Se = TRUE le path vengono convertite
                             con alias di rete (default = FALSE)

  Restituisce la lista in caso di successo altrimenti restituisce NULL.
-*/  
/*********************************************************/
presbuf C_FAS::to_rb(bool ConvertDrive2nethost)
{
   C_RB_LIST list;

   if ((list << acutBuildList(RTLB,
                                 RTSTR, _T("COLOR"),
                              0)) == NULL) return NULL;
   if ((list += color.getResbuf()) == NULL) return NULL;
   if ((list += acutBuildList(RTLE,
                              RTLB,
                                 RTSTR, _T("HATCH"),
                                 RTSTR, hatch,
                              RTLE,
                              RTLB,
                                 RTSTR, _T("HATCH_LAYER"),
                                 RTSTR, hatch_layer,
                              RTLE,
                              RTLB,
                                 RTSTR, _T("HATCH_COLOR"),
                              0)) == NULL) return NULL;
   if ((list += hatch_color.getResbuf()) == NULL) return NULL;
   if ((list += acutBuildList(RTLE,
                              RTLB,
                                 RTSTR, _T("HATCH_SCALE"),
                                 RTREAL, hatch_scale,
                              RTLE,
                              RTLB,
                                 RTSTR, _T("HATCH_ROTATION"),
                                 RTREAL, hatch_rotation,
                              RTLE,
                              RTLB,
                                 RTSTR, _T("LINE_TYPE"),
                                 RTSTR, line,
                              RTLE,
                              RTLB,
                                 RTSTR, _T("TEXT_STYLE"),
                                 RTSTR, style,
                              RTLE,
                              RTLB,
                                 RTSTR, _T("LAYER"),
                                 RTSTR, layer,
                              RTLE,
                              RTLB,
                                 RTSTR, _T("BLOCK"),
                                 RTSTR, block,
                              RTLE,
                              RTLB,
                                 RTSTR, _T("WIDTH"),
                                 RTREAL, width,
                              RTLE,
                              RTLB,
                                 RTSTR, _T("ELEVATION"),
                                 RTREAL, elevation,
                              RTLE,
                              RTLB,
                                 RTSTR, _T("BLOCK_SCALE"),
                                 RTREAL, block_scale,
                              RTLE,
                              RTLB,
                                 RTSTR, _T("LINE_TYPE_SCALE"),
                                 RTREAL, line_scale,
                              RTLE,
                              RTLB,
                                 RTSTR, _T("ROTATION"),
                                 RTREAL, rotation,
                              RTLE,
                              RTLB,
                                 RTSTR, _T("H_TEXT"),
                                 RTREAL, h_text,
                              RTLE,
                              RTLB,
                                 RTSTR, _T("THICKNESS"),
                                 RTREAL, thickness,
                              RTLE,
                              0)) == NULL) return NULL;

   // blocco di riferimento
   if ((list += acutBuildList(RTLB,
                                 RTSTR, _T("FILE_REFBL"),
                              0)) == NULL) return NULL;
   if (ConvertDrive2nethost)
   {
      C_STRING Path(file_ref_block);
      if (gsc_drive2nethost(Path) == GS_BAD) return NULL;
      if ((list += gsc_str2rb(Path)) == NULL) return NULL;
   }
   else
      if ((list += gsc_str2rb(file_ref_block)) == NULL) return NULL;
   if ((list += acutBuildList(RTLE,
                              RTLB,
                                 RTSTR, _T("REF_BLOCK"),
                              0)) == NULL) return NULL;
   if ((list += gsc_str2rb(ref_block)) == NULL) return NULL;
   // funzioni per modifica della grafica
   if ((list += acutBuildList(RTLE,
                              RTLB,
                                 RTSTR, _T("FILE_GPHCA"),
                              0)) == NULL) return NULL;
   if (ConvertDrive2nethost)
   {
      C_STRING Path(file_graph_calc);
      if (gsc_drive2nethost(Path) == GS_BAD) return NULL;
      if ((list += gsc_str2rb(Path)) == NULL) return NULL;
   }
   else
      if ((list += gsc_str2rb(file_graph_calc)) == NULL) return NULL;
   if ((list += acutBuildList(RTLE,
                              RTLB,
                                 RTSTR, _T("FUN_GPHCAL"),
                              0)) == NULL) return NULL;
   if ((list += gsc_str2rb(fun_graph_calc)) == NULL) return NULL;
   if ((list += acutBuildList(RTLE,
                              RTLB, 
                                 RTSTR, _T("DIM_STYLE"),
                              0)) == NULL) return NULL;  
      if ((list += gsc_str2rb(dimension_style)) == NULL) return NULL;
   if ((list += acutBuildList(RTLE, 0)) == NULL) return NULL;  

   list.ReleaseAllAtDistruction(GS_BAD);

   return list.get_head();
}


/*********************************************************/
/*.doc C_FAS::from_rb                         <internal> */
/*+
  Questa funzione legge le proprietà della FAS sottoforma di lista
  di coppie di resbuf ((<proprietà> <valore>) ...).
  Parametri:
  C_RB_LIST &ColValues; Lista di valori
  oppure
  resbuf *rb;           Lista di valori

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_FAS::from_rb(C_RB_LIST &ColValues)
{
   return from_rb(ColValues.get_head());
}
int C_FAS::from_rb(resbuf *rb)
{
   presbuf p;

   if ((p = gsc_CdrAssoc(_T("COLOR"), rb, FALSE)))
      if (color.setResbuf(p) == GS_BAD) color.setByLayer();

   if ((p = gsc_CdrAssoc(_T("HATCH"), rb, FALSE)))
      if (p->restype == RTSTR)
      {
         if (wcslen(p->resval.rstring) >= MAX_LEN_HATCHNAME)
            { GS_ERR_COD = eGSInvalidHatch; return GS_BAD; }
         gsc_strcpy(hatch, p->resval.rstring, MAX_LEN_HATCHNAME);
         gsc_alltrim(hatch);
      }
      else
         gsc_strcpy(hatch, GS_EMPTYSTR, MAX_LEN_HATCHNAME);

   if ((p = gsc_CdrAssoc(_T("HATCH_LAYER"), rb, FALSE)))
      if (p->restype == RTSTR)
      {
         if (wcslen(p->resval.rstring) >= MAX_LEN_LAYERNAME)
            { GS_ERR_COD = eGSInvalidLayer; return GS_BAD; }
         gsc_strcpy(hatch_layer, p->resval.rstring, MAX_LEN_LAYERNAME);
         gsc_alltrim(hatch_layer);
      }
      else
         gsc_strcpy(hatch_layer, GS_EMPTYSTR, MAX_LEN_LAYERNAME);

   if ((p = gsc_CdrAssoc(_T("HATCH_COLOR"), rb, FALSE)))
      if (hatch_color.setResbuf(p) == GS_BAD) hatch_color.setByLayer();

   if ((p = gsc_CdrAssoc(_T("HATCH_SCALE"), rb, FALSE)))
      if (gsc_rb2Dbl(p, &hatch_scale) == GS_BAD) hatch_scale = 0;

   if ((p = gsc_CdrAssoc(_T("HATCH_ROTATION"), rb, FALSE)))
      if (gsc_rb2Dbl(p, &hatch_rotation) == GS_BAD) hatch_rotation = 0;

   if ((p = gsc_CdrAssoc(_T("LINE_TYPE"), rb, FALSE)))
      if (p->restype == RTSTR)
      {
         if (wcslen(p->resval.rstring) >= MAX_LEN_LINETYPENAME)
            { GS_ERR_COD = eGSInvalidLineType; return GS_BAD; }
         gsc_strcpy(line, p->resval.rstring, MAX_LEN_LINETYPENAME);
         gsc_alltrim(line);
      }
      else
         gsc_strcpy(line, GS_EMPTYSTR, MAX_LEN_LINETYPENAME);

   if ((p = gsc_CdrAssoc(_T("LINE_TYPE_SCALE"), rb, FALSE)))
      if (gsc_rb2Dbl(p, &line_scale) == GS_BAD) line_scale = 1;

   if ((p = gsc_CdrAssoc(_T("TEXT_STYLE"), rb, FALSE)))
      if (p->restype == RTSTR)
      {
         if (wcslen(p->resval.rstring) >= MAX_LEN_TEXTSTYLENAME)
            { GS_ERR_COD = eGSInvalidTextStyle; return GS_BAD; }
         gsc_strcpy(style, p->resval.rstring, MAX_LEN_TEXTSTYLENAME);
         gsc_alltrim(style);
      }
      else
         gsc_strcpy(style, GS_EMPTYSTR, MAX_LEN_TEXTSTYLENAME);

   if ((p = gsc_CdrAssoc(_T("LAYER"), rb, FALSE)))
      if (p->restype == RTSTR)
      {
         if (wcslen(p->resval.rstring) >= MAX_LEN_LAYERNAME)
            { GS_ERR_COD = eGSInvalidLayer; return GS_BAD; }
         gsc_strcpy(layer, p->resval.rstring, MAX_LEN_LAYERNAME);
         gsc_alltrim(layer);
      }
      else
         gsc_strcpy(style, GS_EMPTYSTR, MAX_LEN_LAYERNAME);

   if ((p = gsc_CdrAssoc(_T("BLOCK"), rb, FALSE)))
      if (p->restype == RTSTR)
      {
         if (wcslen(p->resval.rstring) >= MAX_LEN_BLOCKNAME)
            { GS_ERR_COD = eGSInvalidBlock; return GS_BAD; }
         gsc_strcpy(block, p->resval.rstring, MAX_LEN_BLOCKNAME);
         gsc_alltrim(block);
      }
      else
         gsc_strcpy(block, GS_EMPTYSTR, MAX_LEN_BLOCKNAME);

   if ((p = gsc_CdrAssoc(_T("BLOCK_SCALE"), rb, FALSE)))
      if (gsc_rb2Dbl(p, &block_scale) == GS_BAD) block_scale = 1;

   if ((p = gsc_CdrAssoc(_T("WIDTH"), rb, FALSE)))
      if (gsc_rb2Dbl(p, &width) == GS_BAD) width = 0;

   if ((p = gsc_CdrAssoc(_T("ELEVATION"), rb, FALSE)))
      if (gsc_rb2Dbl(p, &elevation) == GS_BAD) elevation = 0;

   if ((p = gsc_CdrAssoc(_T("ROTATION"), rb, FALSE)))
      if (gsc_rb2Dbl(p, &rotation) == GS_BAD) rotation = 0;

   if ((p = gsc_CdrAssoc(_T("H_TEXT"), rb, FALSE)))
      if (gsc_rb2Dbl(p, &h_text) == GS_BAD) h_text = 0;

   if ((p = gsc_CdrAssoc(_T("THICKNESS"), rb, FALSE)))
      if (gsc_rb2Dbl(p, &thickness) == GS_BAD) thickness = 0;

   // blocco di riferimento
   if ((p = gsc_CdrAssoc(_T("FILE_REFBL"), rb, FALSE)))
   {
      if (file_ref_block) free(file_ref_block);

      if (p->restype == RTSTR)
      {
         C_STRING Path(p->resval.rstring);

         Path.alltrim();
         // traduco dir assoluto in dir relativo
         if (gsc_nethost2drive(Path) == GS_BAD) return GS_BAD;
         file_ref_block = Path.cut();
      }
      else
         file_ref_block = gsc_tostring(GS_EMPTYSTR);
   }

   if ((p = gsc_CdrAssoc(_T("REF_BLOCK"), rb, FALSE)))
   {
      if (ref_block) free(ref_block);

      if (p->restype == RTSTR)
      {
         ref_block = gsc_tostring(p->resval.rstring);
         gsc_alltrim(ref_block);
      }
      else
         ref_block = gsc_tostring(GS_EMPTYSTR);
   }
   // funzioni per modifica della grafica
   if ((p = gsc_CdrAssoc(_T("FILE_GPHCA"), rb, FALSE)))
   {
      if (file_graph_calc) free(file_graph_calc);

      if (p->restype == RTSTR)
      {
         C_STRING Path(p->resval.rstring);

         Path.alltrim();
         // traduco dir assoluto in dir relativo
         if (gsc_nethost2drive(Path) == GS_BAD) return GS_BAD;
         file_graph_calc = Path.cut();
      }
      else
         file_graph_calc = gsc_tostring(GS_EMPTYSTR);
   }

   if ((p = gsc_CdrAssoc(_T("FUN_GPHCAL"), rb, FALSE)))
   {
      if (fun_graph_calc) free(fun_graph_calc);

      if (p->restype == RTSTR)
      {
         fun_graph_calc = gsc_tostring(p->resval.rstring);
         gsc_alltrim(fun_graph_calc);
      }
      else
         fun_graph_calc = gsc_tostring(GS_EMPTYSTR);
   }

   if ((p = gsc_CdrAssoc(_T("DIM_STYLE"), rb, FALSE)))
      if (p->restype == RTSTR)
      {
         dimension_style = p->resval.rstring;
         dimension_style.alltrim();
      }
      else
         dimension_style = GS_EMPTYSTR;

   return GS_GOOD;
}
  

/*********************************************************/
/*.doc C_FAS::from_db                         <internal> */
/*+
  Questa funzione carica i dati di una C_FAS dalla
  lettura della tabella GS_CLASS_GRAPH.
  Parametri:
  C_NODE *pPrj;   Puntatore a progetto
  int    cls;     Codice classe
  int    sub;     Opzionale; codice sottoclasse (default = 0)
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_FAS::from_db(C_NODE *pPrj, int cls, int sub)
{
   C_DBCONNECTION *pConn;
   C_STRING       TableRef, statement;
   _RecordsetPtr  pRs;
   C_RB_LIST      ColValues;

   // setto il riferimento di GS_CLASS_GRAPH (<catalogo>.<schema>.<tabella>)
   if (((C_PROJECT *) pPrj)->getGraphClassesTabInfo(&pConn, &TableRef) == GS_BAD) return GS_BAD;

   statement = _T("SELECT * FROM ");
   statement += TableRef;
   statement += _T(" WHERE CLASS_ID=");
   statement += cls;
   statement += _T(" AND SUB_CL_ID=");
   statement += sub;

   // leggo la riga della tabella
   if (pConn->ExeCmd(statement, pRs) == GS_BAD) return GS_BAD;
   if (gsc_DBReadRow(pRs, ColValues) == GS_BAD) { gsc_DBCloseRs(pRs); return GS_BAD; }
   gsc_DBCloseRs(pRs);
   
   if (from_rb(ColValues) == GS_BAD) return GS_BAD;

   return GS_GOOD;
}
   

/*********************************************************/
/*.doc C_FAS::to_db                           <internal> */
/*+
  Questa funzione scrive i dati di una C_FAS nella
  tabella GS_CLASS_GRAPH.
  Parametri:
  C_NODE *pPrj;   Puntatore a progetto
  int    cls;     Codice classe
  int    sub;     Opzionale; codice sottoclasse (default = 0)
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_FAS::to_db(C_NODE *pPrj, int cls, int sub)
{
   C_DBCONNECTION *pConn;
   C_STRING       TableRef, statement;
   _RecordsetPtr  pRs;
   C_RB_LIST      ColValues;

   if ((ColValues << acutBuildList(RTLB,
                                   RTLB, RTSTR, _T("CLASS_ID"), RTSHORT, cls, RTLE, 
                                   RTLB, RTSTR, _T("SUB_CL_ID"), RTSHORT, sub, RTLE, 
                                   0)) == NULL) return GS_BAD;
   if ((ColValues += to_rb(TRUE)) == NULL) return GS_BAD;

   if ((ColValues += acutBuildList(RTLE, 0)) == NULL) return GS_BAD;

   // setto il riferimento di GS_CLASS_GRAPH (<catalogo>.<schema>.<tabella>)
   if (((C_PROJECT *) pPrj)->getGraphClassesTabInfo(&pConn, &TableRef) == GS_BAD) return GS_BAD;

   statement = _T("SELECT * FROM ");
   statement += TableRef;
   statement += _T(" WHERE CLASS_ID=");
   statement += cls;
   statement += _T(" AND SUB_CL_ID=");
   statement += sub;

   // leggo la riga della tabella bloccandola in modifica
   if (pConn->ExeCmd(statement, pRs, adOpenDynamic, adLockPessimistic) == GS_BAD) return GS_BAD;
   if (gsc_isEOF(pRs) == GS_GOOD)
   {
      gsc_DBCloseRs(pRs);
      // inserisco nuova riga
      if (pConn->InsRow(TableRef.get_name(), ColValues) == GS_BAD) return GS_BAD;
   }
   else
   {
      // modifico la riga del cursore
      if (gsc_DBUpdRow(pRs, ColValues) == GS_BAD) return GS_BAD;
      if (gsc_DBCloseRs(pRs) == GS_BAD) return GS_BAD;
   }

   return GS_GOOD;
}


/*********************************************************/
/*.doc C_FAS::del_db                          <internal> */
/*+
  Questa funzione cancella i dati di una C_FAS dalla tabella GS_CLASS_GRAPH.
  N.B. La funzione non controlla se la classe è in uso. Il controllo è 
  demandato alla funzione chiamante.
  Parametri:
  C_NODE *pPrj;       Puntatore a progetto
  int    cls;         Codice classe
  int    sub;         Opzionale; codice sottoclasse (default = 0)
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_FAS::del_db(C_NODE *pPrj, int cls, int sub)
{
   C_DBCONNECTION *pConn;
   C_STRING       statement, TableRef;

   // setto il riferimento di GS_CLASS_GRAPH (<catalogo>.<schema>.<tabella>)
   if (((C_PROJECT *) pPrj)->getGraphClassesTabInfo(&pConn, &TableRef) == GS_BAD) return GS_BAD;

   statement = _T("DELETE FROM ");
   statement += TableRef;
   statement += _T(" WHERE CLASS_ID=");
   statement += cls;
   if (sub > 0 )
   {
      statement += _T(" AND SUB_CL_ID=");
      statement += sub;
   }
   return pConn->ExeCmd(statement);
}


/*********************************************************/
/*.doc C_FAS::get_GraphDifferences            <internal> */
/*+
  Questa funzione compara le caratteristiche grafiche con un'altra C_FAS e
  restituisce le differenze attraverso un flag a bit (vedi GraphSettingsEnum).
  Parametri:
  C_FAS &fas2;    C_FAS da comparare
    
  Restituisce un flag a bit indicante le differenze di FAS.
-*/  
/*********************************************************/
long C_FAS::get_GraphDifferences(C_FAS &fas2)
{
   long Flag = GSNoneSetting;

   if (color != fas2.color)                       Flag |= GSColorSetting;   // colore
   if (gsc_strcmp(hatch, fas2.hatch, FALSE) != 0) Flag |= GSHatchNameSetting;  // nome riempimento
   if (gsc_strcmp(hatch_layer, fas2.hatch_layer, FALSE) != 0) Flag |= GSHatchLayerSetting;  // layer del riempimento
   if (hatch_color != fas2.hatch_color)           Flag |= GSHatchColorSetting;    // colore del riempimento
   if (hatch_scale != fas2.hatch_scale)           Flag |= GSHatchScaleSetting;    // scala del riempimento
   if (hatch_rotation != fas2.hatch_rotation)     Flag |= GSHatchRotationSetting; // scala del riempimento
   if (gsc_strcmp(line, fas2.line, FALSE) != 0)   Flag |= GSLineTypeSetting;   // tipo linea
   if (gsc_strcmp(style, fas2.style, FALSE) != 0) Flag |= GSTextStyleSetting;    // stile testo
   if (gsc_strcmp(layer, fas2.layer, FALSE) != 0) Flag |= GSLayerSetting;    // piano   
   if (gsc_strcmp(block, fas2.block, FALSE) != 0) Flag |= GSBlockNameSetting;    // nome blocco
   if (width != fas2.width)                       Flag |= GSWidthSetting;   // larghezza linea
   if (elevation != fas2.elevation)               Flag |= GSElevationSetting; // elevazione
   if (block_scale != fas2.block_scale)           Flag |= GSBlockScaleSetting;    // fattore di scala blocco
   if (line_scale != fas2.line_scale)             Flag |= GSLineTypeScaleSetting; // fattore di scala tipo-linea
   if (rotation != fas2.rotation)                 Flag |= GSRotationSetting; // angolo di rotazione
   if (h_text != fas2.h_text)                     Flag |= GSTextHeightSetting;  // altezza testo
   if (thickness != fas2.thickness)               Flag |= GSThicknessSetting;  // spessore
   if (dimension_style.comp(fas2.dimension_style, FALSE) != 0) Flag |= GSDimensionStyleSetting;  // stile quotatura

   return Flag;
}

 
/****************************************************************************/
/*.doc C_FAS::reportHTML                                         <external> */
/*+
  Questa funzione stampa su un file HTML i dati della C_FAS.
  Parametri:
  C_NODE *pCls;      Puntatore alla classe
  FILE *file;        Puntatore a file
  const TCHAR *Path; Path del file HTML in cui si sta scrivendo. Server unicamente
                     per poter scrivere le bitmap dei blocchi nello stesso direttorio
                     del file HTML (default = NULL).
  bool SynthMode;    Opzionale. Flag di modalità di report.
                     Se = true attiva il report sintetico (default = false)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/
/****************************************************************************/
int C_FAS::reportHTML(C_NODE *pCls, FILE *file, const TCHAR *Path, bool SynthMode)
{  
   C_STRING TitleBorderColor("#808080"), TitleBgColor("#c0c0c0");
   C_STRING BorderColor("#00CCCC"), BgColor("#99FFFF");
   long     flag_set = gsc_WhatFas4Evid((C_CLASS *) pCls);
   C_STRING StrColor;

   if (fwprintf(file, _T("\n<table bordercolor=\"%s\" bgcolor=\"%s\" width=\"100%%\" border=\"1\">"),
                TitleBorderColor.get_name(), TitleBgColor.get_name()) < 0)
      { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

   // "Caratteristiche Grafiche"
   if (fwprintf(file, _T("\n<tr><td align=\"center\"><b><font size=\"3\">%s</font></b></td></tr></table><br>"),
                gsc_msg(752)) < 0)
      { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

   // intestazione tabella
   if (fwprintf(file, _T("\n<table bordercolor=\"%s\" cellspacing=\"2\" cellpadding=\"2\" border=\"1\">"), 
                BorderColor.get_name()) < 0)
      { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

   if (flag_set & GSColorSetting)
      // "Colore"
      if (color.getColorMethod() == C_COLOR::ByLayer || color.getColorMethod() == C_COLOR::ByBlock)
      {
         StrColor = (color.getColorMethod() == C_COLOR::ByLayer) ? gsc_msg(23) : gsc_msg(24); // DALAYER, DABLOCCO
         if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\" width=\"30%%\"><b>%s:</b></td><td width=\"70%%\">%s</td></tr>"),
                      BgColor.get_name(), gsc_msg(629), StrColor.get_name()) < 0)
            { GS_ERR_COD = eGSWriteFile; return GS_BAD; }
      }
      else
      {
         if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\" width=\"30%%\"><b>%s:</b></td><td width=\"70%%\">"),
                      BgColor.get_name(), gsc_msg(629)) < 0)
            { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

         // riquadro colorato
         color.getHTMLColor(StrColor);
         if (fwprintf(file, _T("\n<table cellpadding=\"0\" cellspacing=\"0\" width=\"100%%\"> <tr><td width=\"10%%\">%s&nbsp;&nbsp; </td><td bgcolor=\"%s\">&nbsp;</td></tr></table></td></tr>"),
                      StrColor.get_name(), StrColor.get_name()) < 0)
            { GS_ERR_COD = eGSWriteFile; return GS_BAD; }
      }

   if (flag_set & GSHatchNameSetting)
      // "Riempimento"
      if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%s</td></tr>"),
                   BgColor.get_name(), gsc_msg(630),
                   (gsc_strlen(hatch) == 0) ? _T("&nbsp;") : hatch) < 0)
         { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

   if (!SynthMode)
   {
      if (flag_set & GSHatchLayerSetting)
         // "Piano riempimento"
         if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%s</td></tr>"),
                      BgColor.get_name(), gsc_msg(231),
                      (gsc_strlen(hatch_layer) == 0) ? _T("&nbsp;") : hatch_layer) < 0)
            { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

      if (flag_set & GSHatchColorSetting)
         // "Colore riempimento"
         if (hatch_color.getColorMethod() == C_COLOR::ByLayer || hatch_color.getColorMethod() == C_COLOR::ByBlock)
         {
            StrColor = (hatch_color.getColorMethod() == C_COLOR::ByLayer) ? gsc_msg(23) : gsc_msg(24); // DALAYER, DABLOCCO
            if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\" width=\"30%%\"><b>%s:</b></td><td width=\"70%%\">%s</td></tr>"),
                         BgColor.get_name(), gsc_msg(229), StrColor.get_name()) < 0)
               { GS_ERR_COD = eGSWriteFile; return GS_BAD; }
         }
         else
         {
            if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\" width=\"30%%\"><b>%s:</b></td><td width=\"70%%\">"),
                         BgColor.get_name(), gsc_msg(229)) < 0)
               { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

            // riquadro colorato
            hatch_color.getHTMLColor(StrColor);
            if (fwprintf(file, _T("\n<table cellpadding=\"0\" cellspacing=\"0\" width=\"100%%\"> <tr><td width=\"10%%\">%s&nbsp;&nbsp; </td><td bgcolor=\"%s\">&nbsp;</td></tr></table></td></tr>"),
                         StrColor.get_name(), StrColor.get_name()) < 0)
               { GS_ERR_COD = eGSWriteFile; return GS_BAD; }
         }

      if (flag_set & GSHatchScaleSetting)
         // "Scala riempimento"
         if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%f</td></tr>"),
                      BgColor.get_name(), gsc_msg(464), hatch_scale) < 0)
            { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

      if (flag_set & GSHatchRotationSetting)
         // "Rotazione riempimento (gradi)"
         if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%f</td></tr>"),
                      BgColor.get_name(), gsc_msg(465), hatch_rotation) < 0)
            { GS_ERR_COD = eGSWriteFile; return GS_BAD; }
   }

   if (flag_set & GSLineTypeSetting)
      // "Tipolinea"
      if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%s</td></tr>"),
                   BgColor.get_name(), gsc_msg(631),
                   (gsc_strlen(line) == 0) ? _T("&nbsp;") : line) < 0)
         { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

   if (!SynthMode)
   {
      if (flag_set & GSTextStyleSetting)
         // "Stile testo"
         if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%s</td></tr>"),
                      BgColor.get_name(), gsc_msg(632),
                      (gsc_strlen(style) == 0) ? _T("&nbsp;") : style) < 0)
            { GS_ERR_COD = eGSWriteFile; return GS_BAD; }
   }

   if (flag_set & GSLayerSetting)
      // "Piano"
      if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%s</td></tr>"),
                   BgColor.get_name(), gsc_msg(633),
                   (gsc_strlen(layer) == 0) ? _T("&nbsp;") : layer) < 0)
         { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

   if (flag_set & GSBlockNameSetting)
   {
      // "Nome blocco"
      if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td>"),
                   BgColor.get_name(), gsc_msg(714)) < 0)
         { GS_ERR_COD = eGSWriteFile; return GS_BAD; }
      // Leggo eventuale DIB di preview
      HANDLE hDib   = gsc_extractDIBBlock(block);
      int    InsBlk = FALSE;
      if (hDib)
      {
         C_STRING BlkPath;
          
         if (gsc_dir_from_path(Path, BlkPath) == GS_GOOD)
         {
            BlkPath += _T('\\');
            BlkPath += block;
            BlkPath += _T(".BMP");
            if (gsc_WriteDIB(BlkPath.get_name(), hDib) == GS_GOOD) InsBlk = TRUE;
         }

         GlobalFree(hDib);
      }

      if (!InsBlk)
      {
         if (fwprintf(file, _T("<td>%s</td></tr>"),
                      (gsc_strlen(block) == 0) ? _T("&nbsp;") : block) < 0)
            { GS_ERR_COD = eGSWriteFile; return GS_BAD; }
      }
      else
      {
         if (fwprintf(file, _T("<td><table width=\"100%%\" cellspacing=\"0\" cellpadding=\"0\"><tr><td valign=\"top\" align=\"left\">%s</td>"),
                     (gsc_strlen(block) == 0) ? _T("&nbsp;") : block) < 0)
            { GS_ERR_COD = eGSWriteFile; return GS_BAD; }
         if (fwprintf(file, _T("<td align=\"right\"><img src=\"%s.bmp\" height=\"32\" width\"32\"></td></tr></table></td></tr>"),
                     (gsc_strlen(block) == 0) ? _T("&nbsp;") : block) < 0)
            { GS_ERR_COD = eGSWriteFile; return GS_BAD; }
      }
   }

   if (flag_set & GSDimensionStyleSetting)
      // "Stile quotatura"
      if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%s</td></tr>"),
                   BgColor.get_name(), gsc_msg(466),
                   (dimension_style.len() == 0) ? _T("&nbsp;") : dimension_style.get_name()) < 0)
         { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

   if (!SynthMode)
   {
      if (flag_set & GSWidthSetting)
         // "Larghezza linea"
         if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%f</td></tr>"),
                      BgColor.get_name(), gsc_msg(715), width) < 0)
            { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

      if (flag_set & GSElevationSetting)
         // "Elevazione"
         if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%f</td></tr>"),
                      BgColor.get_name(), gsc_msg(716), elevation) < 0)
            { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

      if (flag_set & GSBlockScaleSetting)
         // "Scala"
         if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%f</td></tr>"),
                      BgColor.get_name(), gsc_msg(467), block_scale) < 0)
            { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

      if (flag_set & GSLineTypeScaleSetting)
         // "Scala tipolinea"
         if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%f</td></tr>"),
                      BgColor.get_name(), gsc_msg(428), line_scale) < 0)
            { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

      if (flag_set & GSRotationSetting)
         // "Rotazione (gradi)"
         if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%f</td></tr>"),
                      BgColor.get_name(), gsc_msg(717), rotation) < 0)
            { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

      if (flag_set & GSTextHeightSetting)
         // "Altezza testo"
         if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%f</td></tr>"),
                      BgColor.get_name(), gsc_msg(718), h_text) < 0)
            { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

      if (flag_set & GSThicknessSetting)
         // "Spessore"
         if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%f</td></tr>"),
                      BgColor.get_name(), gsc_msg(719), thickness) < 0)
            { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

      // "File blocco rif."
      if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%s</td></tr>"),
                   BgColor.get_name(), gsc_msg(723),
                   (file_ref_block) ? _T("&nbsp;") : file_ref_block) < 0)
         { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

      // "Blocco riferimento"
      if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%s</td></tr>"),
                   BgColor.get_name(), gsc_msg(724),
                   (ref_block) ? _T("&nbsp;") : ref_block) < 0)
         { GS_ERR_COD = eGSWriteFile; return GS_BAD; }
   }

   // "File funz. grafiche"
   if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%s</td></tr>"),
                BgColor.get_name(), gsc_msg(725),
                (file_graph_calc) ? _T("&nbsp;") : file_graph_calc) < 0)
      { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

   // "Funzione grafica"
   if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%s</td></tr>"),
                BgColor.get_name(), gsc_msg(726),
                (fun_graph_calc) ? _T("&nbsp;") : fun_graph_calc) < 0)
      { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

   // fine tabella
   if (fwprintf(file, _T("\n</table><br><br>")) < 0)
      { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

   return GS_GOOD;
}

 
/****************************************************************************/
/*.doc C_FAS::is_graph_calculated                                <external> */
/*+
  Questa funzione valuta se le caratteristiche grafiche sono calcolate.

  Restituisce GS_GOOD in caso affermativo altrimenti restituisce GS_BAD. 
-*/
/****************************************************************************/
int C_FAS::is_graph_calculated(void)
{  
   return (fun_graph_calc && wcslen(fun_graph_calc) > 0) ? GS_GOOD : GS_BAD;
}

 
/****************************************************************************/
/*.doc C_FAS::convertUnit                               <external> */
/*+
  Questa funzione converte i valori di FAs che sono dipendenti dalle unità di misura 
  da un sistema all'altro: hatch_scale, line_scale, block_scale, width, elevation,
  h_text, thickness.
  Parametri:
  double UnitConvFactor;   Fattore di correzione per le unità di misura

  Restituisce GS_GOOD in caso affermativo altrimenti restituisce GS_BAD. 
-*/
/****************************************************************************/
void C_FAS::convertUnit(double UnitConvFactor)
{
   if (UnitConvFactor != 0 && UnitConvFactor != 1) // se valido e diverso da 1
   {
      hatch_scale = hatch_scale * UnitConvFactor;
      line_scale  = line_scale * UnitConvFactor;
      block_scale = block_scale * UnitConvFactor;
      width       = width * UnitConvFactor;
      elevation   = elevation * UnitConvFactor;
      h_text      = h_text * UnitConvFactor;
      thickness   = thickness * UnitConvFactor;
   }
}


/****************************************************************************/
/*.doc C_FAS::dd_create_LayerModel                               <external> */
/*+
  Questa funzione chiede e in caso affermativo crea
  con interfaccia grafica i modelli di layer per la tipologia di classe.
  Parametri:
  int prj;     Codice progetto
  int type;    tipologia di classe

  Restituisce GS_GOOD in caso affermativo altrimenti restituisce GS_BAD. 
-*/
/****************************************************************************/
int C_FAS::dd_create_LayerModel(int prj, int type)
{
   // case insensitive
   if (gsc_strcmp(line, gsc_msg(23), FALSE) == 0) // "DALAYER"
      gsc_strcpy(line, LINETYPE_BYLAYER, MAX_LEN_LINETYPENAME);
   else if (gsc_strcmp(line, gsc_msg(24), FALSE) == 0) // "DABLOCCO"
      gsc_strcpy(line, LINETYPE_BYBLOCK, MAX_LEN_LINETYPENAME);

   // Se esiste almeno una proprietà grafica ereditata dal piano (colore, tipolinea)
   if (color.getColorMethod() == C_COLOR::ByLayer ||
       ((type == TYPE_POLYLINE || type == TYPE_SURFACE || type == TYPE_SPAGHETTI) &&
         gsc_strcmp(line, LINETYPE_BYLAYER, FALSE) == 0))
   {
      C_LAYER_MODEL LayerRec;

      // verifico se esiste un modello di piano per layer
	   LayerRec.set_name(layer);
      if (gsc_getLayerModel(prj, LayerRec) == GS_CAN)
      {  // nel caso non esista chiedo se si vuole creare il modello
         TCHAR    dummy[MAX_LEN_MSG];
         C_STRING Msg;
         int      conf;

         // "Alcune proprietà grafica sono ereditate dal piano %s."
         swprintf(dummy, MAX_LEN_MSG, gsc_msg(213), layer);
         Msg = dummy;
         Msg += GS_LFSTR;
         Msg += gsc_msg(214); // "Creare il modello di questo piano ?"
         if (gsc_ddgetconfirm(Msg.get_name(), &conf, GS_GOOD) == GS_GOOD && 
             conf == GS_GOOD)
         {
            // provo a caricare le caratteristiche dal layer autocad (se esiste)
            LayerRec.from_LayerTableRecord(layer);
            if (gsc_ddLayerModel(LayerRec) == GS_GOOD)
               gsc_addLayerModel(prj, LayerRec);
         }
      }
   }

   // Se esiste almeno una proprietà grafica ereditata dal piano (colore riempimento)
   if ((type == TYPE_SURFACE || type == TYPE_SPAGHETTI) &&
        hatch_color.getColorMethod() == C_COLOR::ByLayer)
   {
      C_LAYER_MODEL LayerRec;

      // verifico se esiste un modello di piano per hatch_layer
	   LayerRec.set_name(hatch_layer);
      if (gsc_getLayerModel(prj, LayerRec) == GS_CAN)
      {  // nel caso non esista chiedo se si vuole creare il modello
         TCHAR    dummy[MAX_LEN_MSG];
         C_STRING Msg;
         int      conf;

         // "Alcune proprietà grafica sono ereditate dal piano %s."
         swprintf(dummy, MAX_LEN_MSG, gsc_msg(213), hatch_layer);
         Msg = dummy;
         Msg += GS_LFSTR;
         Msg += gsc_msg(214); // "Creare il modello di questo piano ?"
         if (gsc_ddgetconfirm(Msg.get_name(), &conf, GS_GOOD) == GS_GOOD && 
             conf == GS_GOOD)
         {
            // provo a caricare le caratteristiche dal layer autocad (se esiste)
            LayerRec.from_LayerTableRecord(layer);
            if (gsc_ddLayerModel(LayerRec) == GS_GOOD)
               gsc_addLayerModel(prj, LayerRec);
         }
      }
   }

   return GS_GOOD;
}


/*********************************************************/
/*.doc gs_ddSetLayerModelOnFAS                <external> */
/*+
  Questa funzione LISP setta tramite interfaccia grafica
  le proprietà dei modelli di piano di GEOsim di una FAS.
  Parametri:
  (<prj><type><FAS>)

  Restituisce T in caso di successo altrimenti nil.
-*/  
/*********************************************************/
int gs_ddSetLayerModelOnFAS(void)
{
   C_RB_LIST List;
   presbuf   arg = acedGetArgs();
   int       prj, type;
   C_FAS     FAS;

   acedRetNil();
   
   if (!arg || gsc_rb2Int(arg, &prj) == GS_BAD) // leggo il codice del progetto
      { GS_ERR_COD = eGSInvalidArg; return RTERROR; }
   if (!(arg = arg->rbnext) || gsc_rb2Int(arg, &type) == GS_BAD) // leggo il tipo di classe
      { GS_ERR_COD = eGSInvalidArg; return RTERROR; }
   if (!(arg = arg->rbnext) || FAS.from_rb(arg) == GS_BAD) // set dati C_FAS
      { GS_ERR_COD = eGSInvalidArg; return RTERROR; }

   if (FAS.dd_create_LayerModel(prj, type) == GS_BAD) return RTERROR;

   acedRetT();

   return RTNORM;
}


//---------------------------------------------------------------------//
////////////////   C_FAS  FINE    ///////////////////////////////////////
////////////////   C_FAS_LIST  INIZIO  //////////////////////////////////
//---------------------------------------------------------------------//

// costruttore
C_FAS_LIST::C_FAS_LIST():C_LIST() {}


// distruttore
C_FAS_LIST::~C_FAS_LIST() {}


int C_FAS_LIST::copy(C_FAS_LIST &out)
{
	C_FAS *new_fas, *punt;

	out.remove_all();
	punt = (C_FAS *) get_head();  
	while (punt)
	{
		if ((new_fas = new C_FAS) == NULL) { GS_ERR_COD = eGSOutOfMem; return GS_BAD; }
		out.add_tail(new_fas);
      punt->copy(new_fas);
	  
		punt = (C_FAS *) get_next();
	}

	return GS_GOOD;
}

int C_FAS_LIST::from_rb(resbuf *rb_faslist)
{
   C_FAS    *currentpFas;

   remove_all();

   if(!rb_faslist) { GS_ERR_COD = eGSInvRBType; return GS_BAD; }
   rb_faslist = rb_faslist->rbnext;

   while (rb_faslist->restype != RTLE)
   {
      if (rb_faslist->restype != RTLB)  { GS_ERR_COD = eGSInvRBType; return GS_BAD; }

      if ((currentpFas = new C_FAS) == NULL)
         { GS_ERR_COD = eGSOutOfMem; remove_all(); return GS_BAD; }
   
      if (currentpFas->from_rb(rb_faslist) == GS_BAD)
         { delete currentpFas; remove_all(); return GS_BAD; }
  
      add_tail(currentpFas);

      // avanzo all'elemento successivo
		if ((rb_faslist = gsc_scorri(rb_faslist)) == NULL) 
			{ GS_ERR_COD = eGSInvalidArg; return GS_BAD; }
      rb_faslist = rb_faslist->rbnext;
   }                      
      
   return GS_GOOD;
} 

presbuf C_FAS_LIST::to_rb(void)
{
   C_RB_LIST List;
   C_FAS     *pfas;  

	pfas = (C_FAS *) get_head();

	List << acutBuildList(RTLB, 0);
   if (!pfas) List << acutBuildList(RTNIL, 0);

   while (pfas)
   {
      List += acutBuildList(RTLB, 0);
      if ((List += pfas->to_rb()) == NULL) return NULL;
      List += acutBuildList(RTLE, 0);
      pfas = (C_FAS *) get_next();
   }

   List += acutBuildList(RTLE, 0);

   List.ReleaseAllAtDistruction(GS_BAD);

   return List.get_head();
}

double C_FAS_LIST::getValue(C_FAS *pFAS, GraphSettingsEnum GraphSettingEnum)
{
   switch (GraphSettingEnum)
   {
      case GSBlockScaleSetting:
         return pFAS->block_scale;
      case GSWidthSetting:
         return pFAS->width;
      case GSTextHeightSetting:
         return pFAS->h_text;
      case GSThicknessSetting:
         return pFAS->thickness;
      case GSElevationSetting:
         return pFAS->elevation;
      case GSRotationSetting:
         return pFAS->rotation;
      case GSHatchScaleSetting:
         return pFAS->hatch_scale;
      case GSHatchRotationSetting:
         return pFAS->hatch_rotation;
   }
   return (std::numeric_limits<double>::min)(); // valore non valido che significa non settato
}


/*********************************************************/
/*.doc C_FAS_LIST::sortByNum                       <external> */
/*+
  Questa funzione ordina una lista C_FAS_LIST in base ad una caratteristica
  grafica di tipo numerico.
  GraphSettingsEnum GraphSettingEnum;  Caratteristica grafica
  int ascending;                       se = TRUE ordina in modo crescente (default = TRUE)
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
void C_FAS_LIST::sortByNum(GraphSettingsEnum GraphSettingEnum, int ascending)
{
   int    i, j = 0, stop = FALSE;
   C_NODE *p_item1, *p_item2, *p_next;
   double Num1, Num2;

   if (!head) return;

   if (ascending) // ordine crescente
      while (!stop)
      {
         stop    = TRUE;
         i       = 1;
         p_item1 = head;
         p_item2 = p_item1->next;
      
         while (p_item2 && i < count - j)
         {
            Num1 = getValue((C_FAS *) p_item1, GraphSettingEnum);
            Num2 = getValue((C_FAS *) p_item2, GraphSettingEnum);
            if (Num1 > Num2)
            { // inverto la posizione dei 2 C_NODE
               stop = FALSE;
               // precedente di p_item1
               p_item2->prev = p_item1->prev;
               p_next = p_item2->next;
               p_item2->next = p_item1;
               // successivo di p_item2
               p_item1->next = p_next;
               p_item1->prev = p_item2;
            
               if (p_item1->next) p_item1->next->prev = p_item1;
               if (p_item2->prev) p_item2->prev->next = p_item2;
               else head = p_item2; // scambio del primo elemento
            }
            else p_item1 = p_item2;

            p_item2 = p_item1->next;
            i++;
         }
         j++;
      }
   else // ordine decrescente
      while (!stop)
      {
         stop    = TRUE;
         i       = 1;
         p_item1 = head;
         p_item2 = p_item1->next;
      
         while (p_item2 && i < count - j)
         {
            Num1 = getValue((C_FAS *) p_item1, GraphSettingEnum);
            Num2 = getValue((C_FAS *) p_item2, GraphSettingEnum);
            if (Num1 < Num2)
            { // inverto la posizione dei 2 C_NODE
               stop = FALSE;
               // precedente di p_item1
               p_item2->prev = p_item1->prev;
               p_next = p_item2->next;
               p_item2->next = p_item1;
               // successivo di p_item2
               p_item1->next = p_next;
               p_item1->prev = p_item2;
            
               if (p_item1->next) p_item1->next->prev = p_item1;
               if (p_item2->prev) p_item2->prev->next = p_item2;
               else head = p_item2; // scambio del primo elemento
            }
            else p_item1 = p_item2;

            p_item2 = p_item1->next;
            i++;
         }
         j++;
      }

   // setto fine lista
   p_item2 = head;
   while (p_item2->next) p_item2 = p_item2->next;
   tail = p_item2;
}


/*********************************************************/
/*.doc C_FAS_LIST::Save                       <external> */
/*+
  Questa funzione salva su file i dati della C_FAS_LIST.
  Parametri:
  C_STRING &filename;               file in cui scrivere le informazioni
  const TCHAR *SectionPrefix;       prefisso del nome della sezione in cui scrivere

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_FAS_LIST::Save(C_STRING &filename, const TCHAR *SectionPrefix)
{
   C_FAS                   *pFAS = (C_FAS *) get_head();
   C_STRING                SectionName;
   int                     i = 1;
   C_PROFILE_SECTION_BTREE ProfileSections;
   bool                    Unicode = false;

   if (gsc_path_exist(filename) == GS_GOOD)
      if (gsc_read_profile(filename, ProfileSections, &Unicode) == GS_BAD) return GS_BAD;

   while (pFAS)
   {
      SectionName = SectionPrefix;
      SectionName += _T("_");
      SectionName += i++;

      if (pFAS->ToFile(ProfileSections, SectionName.get_name()) == GS_BAD)
         return GS_BAD;

      pFAS = (C_FAS *) get_next();
   }

   return gsc_write_profile(filename, ProfileSections, Unicode);
}


/*********************************************************/
/*.doc C_FAS_LIST::Load                       <external> */
/*+
  Questa funzione carica da file i dati della C_FAS_LIST.
  Parametri:
  C_STRING &filename;            file da cui leggere le informazioni
  const TCHAR *SectionPrefix;    prefisso del nome della sezione da cui leggere

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_FAS_LIST::Load(C_STRING &filename, const TCHAR *SectionPrefix)
{
   C_PROFILE_SECTION_BTREE ProfileSections;

   if (gsc_read_profile(filename, ProfileSections) == GS_BAD) return GS_BAD;
   return Load(ProfileSections, SectionPrefix);
}
int C_FAS_LIST::Load(C_PROFILE_SECTION_BTREE &ProfileSections, const TCHAR *SectionPrefix)
{
   C_FAS    *pFAS;
   C_STRING SectionName;
   int      i = 1, Result;

   remove_all();
   if ((pFAS = new C_FAS) == NULL) { GS_ERR_COD = eGSOutOfMem; return GS_BAD; }

   SectionName = SectionPrefix;
   SectionName += _T("_");
   SectionName += i++;

   while ((Result = pFAS->load(ProfileSections, SectionName.get_name())) == GS_GOOD) 
   {
      add_tail(pFAS);
      if ((pFAS = new C_FAS) == NULL)
         { remove_all(); GS_ERR_COD = eGSOutOfMem; return GS_BAD; }

      SectionName = SectionPrefix;
      SectionName += _T("_");
      SectionName += i++;
   }
   delete pFAS;

   // se sono uscito dal ciclo per un motivo diverso da GS_CAN (info non trovata)
   if (Result != GS_CAN) { remove_all(); return GS_BAD; }
   
   return GS_GOOD;      
}


//---------------------------------------------------------------------//
////////////////   C_FAS_LIST  FINE    //////////////////////////////////
//---------------------------------------------------------------------//


/*********************************************************/
/*.doc gs_getdefaultFAS <external> */
/*+
  Questa funzione restituisce una lista dei valori di default
  della Feature Alteration Set.
-*/  
/*********************************************************/
int gs_getdefaultFAS(void)
{
   C_FAS     fas;
   C_RB_LIST ret;

   acedRetNil();
   
   if (gsc_getdefaultFAS(fas) != GS_GOOD) return RTERROR;
   
   ret << fas.to_rb();
   ret.LspRetList();

   return RTNORM;
}


/*********************************************************/
/*.doc gsc_getdefaultFAS <external> */
/*+
  Questa funzione restituisce una lista dei valori di default 
  della Feature Alteration Set.
  Parametri:
  C_FAS &fas;

  Ritorna GS_GOOD in caso di successo altrimenti GS_BAD
-*/  
/*********************************************************/
int gsc_getdefaultFAS(C_FAS &fas)
{
   C_FAS dummy_fas;
   dummy_fas.copy(&fas);
   
   return GS_GOOD;
}


/*********************************************************/
/*.doc gs_get_fas                             <external> */
/*+
  Questa funzione LISP restituisce una lista dei valori 
  della Feature Alteration Set di una classe.
  Parametri:
  (<prj><cls>[<sub>])
  
  Ritorna la lista resbuf in caso di successo altrimenti NULL;
-*/  
/*********************************************************/
int gs_get_fas(void)
{
   C_CLASS   *pCls;
   C_FAS     *fas;
   resbuf    *arg;
   C_RB_LIST ret;
   int       prj, cls, sub;

   acedRetNil();
   arg = acedGetArgs();

   // Legge nella lista dei parametri: progetto classe e sub
   if (arg_to_prj_cls_sub(&arg, &prj, &cls, &sub) == GS_BAD) return RTERROR;

   // Ritorna il puntatore alla classe cercata
   if ((pCls = gsc_find_class(prj, cls, sub)) == NULL) return RTERROR;

   // Ritorna il puntatore a C_FAS della classe
   if ((fas = pCls->ptr_fas()) == NULL) return RTNORM;

   // Ritorna lista resbuf
   if ((ret << fas->to_rb()) == NULL) return RTERROR;
   ret.LspRetList();

   return RTNORM;
}


/*********************************************************/
/*.doc gs_get_gph_info                        <external> */
/*+
  Questa funzione LISP restituisce una lista dei valori 
  di informazione sulla sorgente dati grafica di una classe.
  Parametri:
  (<prj><cls>[<sub>])
  
  Ritorna la lista resbuf in caso di successo altrimenti NULL;
-*/  
/*********************************************************/
int gs_get_gph_info(void)
{
   C_CLASS    *pCls;
   C_GPH_INFO *pGraphInfo;
   resbuf     *arg;
   C_RB_LIST  ret;
   int        prj, cls, sub;

   acedRetNil();
   arg = acedGetArgs();

   // Legge nella lista dei parametri: progetto classe e sub
   if (arg_to_prj_cls_sub(&arg, &prj, &cls, &sub) == GS_BAD) return RTERROR;

   // Ritorna il puntatore alla classe cercata
   if ((pCls = gsc_find_class(prj, cls, sub)) == NULL) return RTERROR;

   // Ritorna il puntatore a C_FAS della classe
   if ((pGraphInfo = pCls->ptr_GphInfo()) == NULL) return RTNORM;

   // Ritorna lista resbuf
   if ((ret << pGraphInfo->to_rb()) == NULL) return RTERROR;
   ret.LspRetList();

   return RTNORM;
}
           

int gsc_validclassname(const TCHAR *name)
{
   // importante che il nome non contenga delle virgole !!
   TCHAR  insieme_valido[] = _T(". $-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyzÇüéâäåçêëèìæÆôûÖøØáíóÑãÐiÏÓÔÒõÕÞý()");
   size_t i, len;
   
   if (!name) { GS_ERR_COD = eGSInvClassName; return GS_BAD; }
   len = wcslen(name);   
   if (len == 0 || len >= MAX_LEN_CLASSNAME)
      { GS_ERR_COD = eGSInvClassName; return GS_BAD; }   
   
   for (i = 0; i < len; i++)
      if (wcschr(insieme_valido, name[i]) == NULL)
         { GS_ERR_COD = eGSInvClassName; return GS_BAD; }
   
   return GS_GOOD;
}  
//-----------------------------------------------------------------------//
int gsc_validwidth(double width)
{
   if (width < 0) { GS_ERR_COD = eGSInvalidWidth; return GS_BAD; }

   return GS_GOOD;
}  
//-----------------------------------------------------------------------//
int gsc_validelevation(double elevation)
{
   return GS_GOOD;
}  
//-----------------------------------------------------------------------//
int gsc_validscale(double scale)
{
   if (scale <= 0) { GS_ERR_COD = eGSInvalidScale; return GS_BAD; }

   return GS_GOOD;
}  
//-----------------------------------------------------------------------//
int gsc_validrotation(double rotation)
{
   return GS_GOOD;
}  
//-----------------------------------------------------------------------//
int gsc_validhtext(double h_text)
{
   if (h_text <= 0) { GS_ERR_COD = eGSInvalidH_text; return GS_BAD; }

   return GS_GOOD;
}  
//-----------------------------------------------------------------------//
int gsc_validWidhtFactorText(double WidhtFactor)
{
   if (WidhtFactor <= 0) { GS_ERR_COD = eGSInvalidWidth; return GS_BAD; }

   return GS_GOOD;
}  
//-----------------------------------------------------------------------//
int gsc_validthickness(double thickness)
{
   return GS_GOOD;
}  
//-----------------------------------------------------------------------//
int gsc_validdirdwg(C_STRING &dir)
{
   if (gsc_validdir(dir) == GS_BAD) return GS_BAD;
   if (gsc_nethost2drive(dir) == GS_BAD) return GS_BAD;
   
   return GS_GOOD;
}  
//-----------------------------------------------------------------------//
int gsc_validdirdwg(TCHAR *dir, int maxlen)
{
   C_STRING dummy(dir);
   return gsc_validdirdwg(dummy);
}  


/*********************************************************/
/*.doc gsc_validgphcalc <internal> */
/*+
  Questa funzione verifica la validità del file contenente la 
  funzione di calcolo per la grafica.
  Parametri:
  TCHAR *file_graph_calc;        nome del file contenente il blocco di riferimento
                                 (ALLOCATO DINAMICAMENTE)
  TCHAR *fun_graph_calc;         nome del blocco di riferimento
  C_ATTRIB_LIST *p_attrib_list;  lista degli attributi

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
  N.B. : Deve essere già stato caricato un eventuale GSL.GSL dal progetto della classe
-*/  
/*********************************************************/
int gsc_validgphcalc(TCHAR **file_graph_calc, TCHAR *const fun_graph_calc,
                     C_ATTRIB_LIST *p_attrib_list)
{
   if (!p_attrib_list) { GS_ERR_COD = eGSInvalidArg; return GS_BAD; }

   // se non c'è il nome della funzione anche il file deve essere NULL
   if ((!fun_graph_calc || wcslen(fun_graph_calc) == 0) && 
       (file_graph_calc && (*file_graph_calc) && wcslen(*file_graph_calc) > 0))
      { GS_ERR_COD = eGSInvalidGraphCalc; return GS_BAD; }   

   if (file_graph_calc && (*file_graph_calc))
   {
      if (wcslen(*file_graph_calc) > 0)
      {
         C_STRING path;

         path = *file_graph_calc;
         if (gsc_nethost2drive(path) == GS_BAD) return GS_BAD;
         free(*file_graph_calc);
         if ((*file_graph_calc = gsc_tostring(path.get_name())) == NULL) return GS_BAD;
      }
   }

   if (fun_graph_calc)
   {
      C_ATTRIB *p_attrib;
      long      Flag;       // Flag per tipo di modifica effettuata dalla funzione

      if (wcslen(fun_graph_calc) >= MAX_LSP_FUNCNAME)
         { GS_ERR_COD = eGSInvalidGraphCalc; return GS_BAD; }

      // Questa funzione  esamina il corpo della funzione di calcolo grafico 
      // restituendo quali caratteristiche grafiche che vengono modificate (solo per
      // le principali) sotto forma di un codice a bit codificato
      // come GraphSettingsEnum:
      if ((Flag = gsc_WhatIsGraphModified(fun_graph_calc, *file_graph_calc)) == -1)
         return GS_BAD;

      // se ci sono dei valori calcolati da grafica, ATTENZIONE alla funz. di calcolo
      // su grafica che non deve modificare le caratteristiche grafiche lette da altre 
      // funzioni di calcolo (es. cambio colore quando il valore di un attributo è .COLOR)
      p_attrib = (C_ATTRIB *) p_attrib_list->get_head();
      while (p_attrib)
      {  
         if (p_attrib->is_from_graph() == GS_GOOD)
         {
            // queste funzioni sono esentate dal controllo
            // GS_LISP_LENGTH, GS_LISP_AREA, GS_LISP_INITIAL_NODE, GS_LISP_FINAL_NODE
            // GS_LISP_INS_POINT, GS_LISP_X_INS_POINT, GS_LISP_Y_INS_POINT,
            // GS_LISP_Z_INS_POINT, GS_LISP_CENTROID
            if (gsc_strcmp(p_attrib->calc_func, GS_LISP_COLOR, FALSE) == 0) 
               // non si può modificare il colore
               if (Flag & GSColorSetting) { GS_ERR_COD = eGSInvalidGraphCalc; return GS_BAD; }
                  
            if (gsc_strcmp(p_attrib->calc_func, GS_LISP_START_WIDTH, FALSE) == 0 ||
                gsc_strcmp(p_attrib->calc_func, GS_LISP_END_WIDTH, FALSE) == 0)
               // non si può modificare l'ampiezza della polilinea
               if (Flag & GSWidthSetting) { GS_ERR_COD = eGSInvalidGraphCalc; return GS_BAD; }
         }
         p_attrib = (C_ATTRIB *) p_attrib->get_next();
      }
   }   

   return GS_GOOD;
}


//-----------------------------------------------------------------------//
//////////////////  C_FAS   FINE    ///////////////////////////////////////
//////////////////  C_INFO  INIZIO  ///////////////////////////////////////
//-----------------------------------------------------------------------//


C_INFO::C_INFO() 
{
   key_attrib    = DEFAULT_KEY_ATTR;
   TempLastId    = 0;
   OldLastId     = 0;
   pOldTabConn   = NULL;
   pTempTabConn  = NULL;
   SeekSupportedOnTemp = true;
   SeekSupportedOnOld  = true;
   LinkedTable         = false;
}

//-----------------------------------------------------------------------//

C_DBCONNECTION* C_INFO::getDBConnection(int Type)
{
   if (Type == OLD) // Connessione alla tabella OLD
   {
      if (pOldTabConn) return pOldTabConn;
      pOldTabConn = GEOsimAppl::DBCONNECTION_LIST.get_Connection(ConnStrUDLFile.get_name(), &UDLProperties);
      
      return pOldTabConn;
   }
   else
   {  // Connessione alla tabella TEMP
      if (pTempTabConn) return pTempTabConn;
      if (!GS_CURRENT_WRK_SESSION) { GS_ERR_COD = eGSNotCurrentSession; return NULL; }
      pTempTabConn = GS_CURRENT_WRK_SESSION->getDBConnection();
      
      return pTempTabConn;
   }
}

//-----------------------------------------------------------------------//

int C_INFO::copy(C_INFO *out)
{
   if (!out) { GS_ERR_COD = eGSInvalidArg; return GS_BAD; }
   
   out->OldTableRef     = OldTableRef;
   out->OldLnkTableRef  = OldLnkTableRef;
   out->TempTableRef    = TempTableRef;
   out->TempLnkTableRef = TempLnkTableRef;
   out->ConnStrUDLFile  = ConnStrUDLFile;
   UDLProperties.copy(out->UDLProperties);
   out->key_attrib     = key_attrib;
   out->TempLastId     = TempLastId;
   out->OldLastId      = OldLastId;
   out->SqlCondOnTable = SqlCondOnTable;
   out->LinkedTable    = LinkedTable;

   // roby le connessioni vengono ricavate sempre dalle opportuune funzioni
   // quindi le connessioni non devono essere copiate (es. copia classi 
   // copia la C_INFO e poi ne varia ConnStrUDLFile ma la connessione si riferisce sempre alla
   // classe di origine facendo casino...)
   //out->pTempTabConn        = pTempTabConn;
   //out->pOldTabConn         = pOldTabConn;
   out->SeekSupportedOnTemp = SeekSupportedOnTemp;
   out->SeekSupportedOnOld  = SeekSupportedOnOld;
   
   return GS_GOOD;
}  

//-----------------------------------------------------------------------//

int C_INFO::ToFile(C_STRING &filename, const TCHAR *sez)
{
   C_PROFILE_SECTION_BTREE ProfileSections;
   bool                    Unicode = false;

   if (gsc_path_exist(filename) == GS_GOOD)
      if (gsc_read_profile(filename, ProfileSections, &Unicode) == GS_BAD) return GS_BAD;

   if (ToFile(ProfileSections, sez) == GS_BAD) return GS_BAD;

   return gsc_write_profile(filename, ProfileSections, Unicode);
}
int C_INFO::ToFile(C_PROFILE_SECTION_BTREE &ProfileSections, const TCHAR *sez)
{  
   C_BPROFILE_SECTION *ProfileSection;
   TCHAR    buf[INFO_PROFILE_LEN];
   C_STRING Buffer;

   if (!(ProfileSection = (C_BPROFILE_SECTION *) ProfileSections.search(sez)))
   {
      if (ProfileSections.add(sez) == GS_BAD) return GS_BAD;
      ProfileSection = (C_BPROFILE_SECTION *) ProfileSections.get_cursor();
   }

   if (ConnStrUDLFile.len() == 0)
      Buffer = GS_EMPTYSTR;
   else
   {
      Buffer = ConnStrUDLFile;
      if (gsc_path_exist(Buffer) == GS_GOOD)
         if (gsc_drive2nethost(Buffer) == GS_BAD) return GS_BAD;
   }
   ProfileSection->set_entry(_T("INFO_CONNSTRUDLFILE"), Buffer.get_name());

   Buffer.paste(gsc_PropListToConnStr(UDLProperties));
   if (Buffer.len() > 0)
   {
      // Conversione path UDLProperties da dir relativo in assoluto
      if (getDBConnection(OLD) == NULL) return GS_BAD;
      if (pOldTabConn->UDLProperties_drive2nethost(Buffer) == GS_BAD) return GS_BAD;
   }
   ProfileSection->set_entry(_T("INFO_UDLPROPERTIES"), (Buffer.len() == 0) ? GS_EMPTYSTR : Buffer.get_name());

   Buffer = OldTableRef;
   if (Buffer.len() > 0)
   {
      if (getDBConnection(OLD) == NULL) return GS_BAD;
      if (Buffer.paste(pOldTabConn->FullRefTable_drive2nethost(Buffer.get_name())) == NULL)
         return GS_BAD;
   }
   ProfileSection->set_entry(_T("INFO_TABLEREF"), (Buffer.len() == 0) ? GS_EMPTYSTR : Buffer.get_name());

   swprintf(buf, INFO_PROFILE_LEN, _T("%s,%ld,%ld"), (key_attrib.len() == 0) ? GS_EMPTYSTR : key_attrib.get_name(),
            TempLastId, OldLastId);   
   ProfileSection->set_entry(_T("INFO"), buf);

   ProfileSection->set_entry(_T("INFO_LINKED_TABLE"), LinkedTable);

   ProfileSection->set_entry(_T("INFO_SQL_COND_ON_TABLE"), (SqlCondOnTable.len() == 0) ? GS_EMPTYSTR : SqlCondOnTable.get_name());

   return GS_GOOD;
}
//-----------------------------------------------------------------------//
int C_INFO::load(TCHAR *filename, const TCHAR *sez)
{
   C_PROFILE_SECTION_BTREE ProfileSections;

   if (gsc_read_profile(filename, ProfileSections) == GS_BAD) return GS_BAD;
   return load(ProfileSections, sez);
}
//-----------------------------------------------------------------------//
int C_INFO::load(C_PROFILE_SECTION_BTREE &ProfileSections, const TCHAR *sez)
{
   C_BPROFILE_SECTION *ProfileSection;
   C_2STR_BTREE       *pProfileEntries;
   C_B2STR            *pProfileEntry;
   C_STRING           buffer;
   TCHAR              *str;
   int                n_campi;
   
   if (!(ProfileSection = (C_BPROFILE_SECTION *) ProfileSections.search(sez)))
      return GS_CAN;
   pProfileEntries = (C_2STR_BTREE *) ProfileSection->get_ptr_EntryList();

   // UDL_FILE (obbligatorio)
   if (!(pProfileEntry = (C_B2STR *) pProfileEntries->search(_T("INFO_CONNSTRUDLFILE")))) return GS_CAN;
   ConnStrUDLFile = pProfileEntry->get_name2();
   ConnStrUDLFile.alltrim();
   if (gsc_path_exist(ConnStrUDLFile) == GS_GOOD)
      // se si tratta di un file e NON di una stringa di connessione
      gsc_nethost2drive(ConnStrUDLFile); // lo converto

   // UDL_PROP (obbligatorio)
   if (!(pProfileEntry = (C_B2STR *) pProfileEntries->search(_T("INFO_UDLPROPERTIES")))) return GS_CAN;
   buffer = pProfileEntry->get_name2();
   buffer.alltrim();
   if (buffer.len() > 0)
   {
      // Conversione path UDLProperties da assoluto in dir relativo
      if (gsc_UDLProperties_nethost2drive(ConnStrUDLFile.get_name(), buffer) == GS_BAD)
         return GS_BAD;
      if (gsc_PropListFromConnStr(buffer.get_name(), UDLProperties) == GS_BAD)
         return GS_BAD;
   }

   if (getDBConnection(OLD) == NULL) return GS_BAD;

   // TABLE_REF obbligatorio
   if (!(pProfileEntry = (C_B2STR *) pProfileEntries->search(_T("INFO_TABLEREF")))) return GS_CAN;
   buffer = pProfileEntry->get_name2();
   buffer.alltrim();
   // Conversione riferimento tabella da dir assoluto in relativo
   if (OldTableRef.paste(pOldTabConn->FullRefTable_nethost2drive(buffer.get_name())) == NULL)
      return GS_BAD;
   
   // INFO obbligatorio
   if (!(pProfileEntry = (C_B2STR *) pProfileEntries->search(_T("INFO")))) return GS_CAN;
   buffer  = pProfileEntry->get_name2();
   str     = buffer.get_name();
   n_campi = gsc_strsep(str, _T('\0')) + 1;

   if (n_campi < 1) // numero insufficiente di informazioni
      { GS_ERR_COD = eGSInvalidArg; return GS_BAD; }

   key_attrib = str;

   if (n_campi > 1)
   {
      while(*str != _T('\0')) str++; str++;
      TempLastId = _wtol(str);
      
      if (n_campi > 2)
      {
         while(*str != _T('\0')) str++; str++;
         OldLastId = _wtol(str);
      }
   }

   // INFO_LINKED_TABLE
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(_T("INFO_LINKED_TABLE"))))
      LinkedTable = (_wtoi(pProfileEntry->get_name2()) == 0) ? false : true;

   // INFO_SQL_COND_ON_TABLE
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(_T("INFO_SQL_COND_ON_TABLE"))))
   {
      SqlCondOnTable = pProfileEntry->get_name2();
      SqlCondOnTable.alltrim();
   }

   return GS_GOOD;
}


/*********************************************************/
/*.doc C_INFO::to_rb                          <internal> */
/*+
  Questa funzione scrive i dati di una C_INFO in una lista di resbuf.
  Lista in uscita: (("UDL_FILE" <value>)
                    ("UDL_PROP" <value>)
                    ("TABLE_REF" <value>)
                    [("KEY_ATTRIB" <value>)]
                    [("LAST" <value>)]
                    [("ORIGINAL_LAST" <value>)]
                    [("LINKED_TABLE" <value>)]
                    [("SQL_COND_ON_TABLE" <value>)])
 
  Parametri:
  bool ConvertDrive2nethost; Se = TRUE le path vengono convertite
                             con alias di rete (default = false)
  bool ToDB;                 Se = true vengono considerate anche le
                             informazioni per la scrittura in DB (default = false)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
resbuf *C_INFO::to_rb(bool ConvertDrive2nethost, bool ToDB)
{
   C_RB_LIST List;
   C_STRING  Buffer;

   if ((List += acutBuildList(RTLB,
                                 RTSTR, _T("UDL_FILE"),
                              0)) == NULL) return NULL;
   Buffer = ConnStrUDLFile;
   if (Buffer.len() > 0 && ConvertDrive2nethost)
         if (gsc_drive2nethost(Buffer) == GS_BAD) return NULL;
   if ((List += gsc_str2rb(Buffer)) == NULL) return NULL;

   if ((List += acutBuildList(RTLE,
                              RTLB,
                                 RTSTR, _T("UDL_PROP"),
                              0)) == NULL) return NULL;
   Buffer.paste(gsc_PropListToConnStr(UDLProperties));
   if (Buffer.len() > 0 && ConvertDrive2nethost)
   {
      // Conversione path UDLProperties da dir relativo in assoluto
      if (getDBConnection(OLD) == NULL) return NULL;
      if (getDBConnection(OLD)->UDLProperties_drive2nethost(Buffer) == GS_BAD) return NULL;
   }
   if ((List += gsc_str2rb(Buffer)) == NULL) return NULL;

   if ((List += acutBuildList(RTLE, RTLB,
                                 RTSTR, _T("TABLE_REF"),
                              0)) == NULL) return NULL;
   Buffer = OldTableRef;
   if (Buffer.len() > 0 && ConvertDrive2nethost)
   {
      // Conversione riferimento tabella da dir relativo in assoluto
      if (getDBConnection(OLD) == NULL) return NULL;
      if (Buffer.paste(getDBConnection(OLD)->FullRefTable_drive2nethost(Buffer.get_name())) == NULL)
         return NULL;
   }
   if ((List += gsc_str2rb(Buffer)) == NULL) return NULL;

   if ((List += acutBuildList(RTLE, RTLB, RTSTR, _T("KEY_ATTRIB"), 0)) == NULL) return NULL;
   if ((List += gsc_str2rb(key_attrib)) == NULL) return NULL;
   if ((List += acutBuildList(RTLE, 0)) == NULL) return NULL;
   if (!ToDB)
      if ((List += acutBuildList(RTLB, 
                                    RTSTR, _T("LAST"), RTREAL, (double) TempLastId, // trattato come numero reale
                                 RTLE,
                                 RTLB,
                                    RTSTR, _T("ORIGINAL_LAST"), RTREAL, (double) OldLastId, // trattato come numero reale
                                 RTLE, 0)) == NULL) return NULL;
   if (LinkedTable) 
      { if ((List += acutBuildList(RTLB, RTSTR, _T("LINKED_TABLE"), RTT, RTLE, 0)) == NULL) return NULL; }
   else
      { if ((List += acutBuildList(RTLB, RTSTR, _T("LINKED_TABLE"), RTNIL, RTLE, 0)) == NULL) return NULL; }

   if ((List += acutBuildList(RTLB, RTSTR, _T("SQL_COND_ON_TABLE"), 0)) == NULL) return NULL;
   if ((List += gsc_str2rb(SqlCondOnTable)) == NULL) return NULL;
   if ((List += acutBuildList(RTLE, 0)) == NULL) return NULL;

   List.ReleaseAllAtDistruction(GS_BAD);
   return List.get_head();
}

//-----------------------------------------------------------------------//

int C_INFO::from_rb(resbuf *rb)
{
   C_DBCONNECTION *pConn;
   C_STRING       Catalog, Schema, Table;
   presbuf        p, pVal;
 
   // Lista in input: (("UDL_FILE" <Connection>)
   //                  ("UDL_PROP" <Properties>)
   //                  ("TABLE_REF" <TableRef>)
   //                  [("KEY_ATTRIB" <value>)]
   //                  [("LAST" <value>)]
   //                  [("ORIGINAL_LAST" <value>)]
   //                  [("LINKED_TABLE" <value>)]
   //                  [("SQL_COND_ON_TABLE" <value>)])
   // dove
   // <Connection> = <file UDL> | <stringa di connessione>
   // <Properties> = stringa delle proprietà | ((<prop1><value>)(<prop1><value>)...)
   // <TableRef>   = riferimento completo tabella | (<cat><schema><tabella>)

   if (!rb) { GS_ERR_COD = eGSInvalidArg; return GS_BAD; }

   if ((p = gsc_CdrAssoc(_T("UDL_FILE"), rb, FALSE)))
      if (p->restype == RTSTR)
      {
         ConnStrUDLFile = p->resval.rstring;
         ConnStrUDLFile.alltrim();
         // traduco dir assoluto in dir relativo
         if (gsc_nethost2drive(ConnStrUDLFile) == GS_BAD) return GS_BAD;
      }
      else
         ConnStrUDLFile.clear();

   // UDL Props
   if ((p = gsc_CdrAssoc(_T("UDL_PROP"), rb, FALSE)))
      if (p->restype == RTSTR) // Le proprietà sono in forma di stringa
      {
         if (gsc_PropListFromConnStr(p->resval.rstring, UDLProperties) == GS_BAD)
            return GS_BAD;
      }
      else
      if (p->restype == RTLB) // Le proprietà sono in forma di lista
      {
         if (gsc_getUDLProperties(&p, UDLProperties) == GS_BAD) return GS_BAD;
      }
      else
         UDLProperties.remove_all();

   // Conversione path UDLProperties da assoluto in dir relativo
   if (gsc_UDLProperties_nethost2drive(ConnStrUDLFile.get_name(), UDLProperties) == GS_BAD)
      return GS_BAD;

   if ((pConn = getDBConnection(OLD)) == NULL) return GS_BAD;

   // Table reference (opzionale)
   if ((p = gsc_CdrAssoc(_T("TABLE_REF"), rb, FALSE)))
      if (p->restype == RTSTR)
      {
         // Conversione riferimento tabella da dir relativo in assoluto
         if (OldTableRef.paste(pConn->FullRefTable_nethost2drive(p->resval.rstring)) == NULL)
            return GS_BAD;
      }
      else
      if (p->restype == RTLB)
      {  // (<cat><sch><tab>)
         C_STRING Catalog, Schema, Table;

         if (!(p = p->rbnext)) { GS_ERR_COD = eGSInvalidArg; return GS_BAD; }
         if (p->restype == RTSTR) Catalog = p->resval.rstring;
         if (!(p = p->rbnext)) { GS_ERR_COD = eGSInvalidArg; return GS_BAD; }
         if (p->restype == RTSTR) Schema = p->resval.rstring;
         if (!(p = p->rbnext)) { GS_ERR_COD = eGSInvalidArg; return GS_BAD; }
         if (p->restype == RTSTR) Table = p->resval.rstring;
         if (OldTableRef.paste(pConn->get_FullRefTable(Catalog, Schema, Table)) == NULL)
            return GS_BAD;
      }
      else
         OldTableRef.clear();

   // Conversione path UDLProperties da assoluto in dir relativo
   if (pConn->UDLProperties_nethost2drive(UDLProperties) == GS_BAD) return GS_BAD;

   // key_attrib (opzionale)
   if ((pVal = gsc_CdrAssoc(_T("KEY_ATTRIB"), rb, FALSE)))
      if (pVal->restype == RTSTR)
      {
         key_attrib = pVal->resval.rstring;
         key_attrib.alltrim();
      }
      else if (pVal->restype == RTNIL || pVal->restype == RTNONE) key_attrib.clear();
      else { GS_ERR_COD = eGSInvRBType; return GS_BAD; }
   
   // last (opzionale)
   if ((pVal = gsc_CdrAssoc(_T("LAST"), rb, FALSE)))
      if (gsc_rb2Lng(pVal, &TempLastId) == GS_BAD)
         if (pVal->restype == RTNIL || pVal->restype == RTNONE) TempLastId = 0;
         else { GS_ERR_COD = eGSInvRBType; return GS_BAD; }

   // original_last (opzionale)
   if ((pVal = gsc_CdrAssoc(_T("ORIGINAL_LAST"), rb, FALSE)))
      if (gsc_rb2Lng(pVal, &OldLastId) == GS_BAD)
         if (pVal->restype == RTNIL || pVal->restype == RTNONE) OldLastId = 0;
         else { GS_ERR_COD = eGSInvRBType; return GS_BAD; }

   // LinkedTable (opzionale)
   if ((pVal = gsc_CdrAssoc(_T("LINKED_TABLE"), rb, FALSE)))
      if (gsc_rb2Bool(pVal, &LinkedTable) == GS_BAD)
         { GS_ERR_COD = eGSInvRBType; return GS_BAD; }

   // SqlCondOnTable (opzionale)
   if ((pVal = gsc_CdrAssoc(_T("SQL_COND_ON_TABLE"), rb, FALSE)))
      if (pVal->restype == RTSTR)
      {
         SqlCondOnTable = pVal->resval.rstring;
         SqlCondOnTable.alltrim();
      }
      else if (pVal->restype == RTNIL || pVal->restype == RTNONE) SqlCondOnTable.clear();
      else { GS_ERR_COD = eGSInvRBType; return GS_BAD; }

   return GS_GOOD;
} 
   

/*********************************************************/
/*.doc C_INFO::from_rb_db                     <internal> */
/*+
  Questa funzione carica i dati di una C_INFO da un resbuf generato dalla
  lettura su tabella GS_CLASS.
  Parametri:
  C_RB_LIST &ColValues;    lista colonna-valore della riga di GS_CLASS
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_INFO::from_rb_db(C_RB_LIST &ColValues)
{
   C_DBCONNECTION *pConn;
   presbuf        p_cls;

   // UDL_FILE
   if ((p_cls = ColValues.CdrAssoc(_T("UDL_FILE"))) == NULL)
      { GS_ERR_COD = eGSInvRBType; return GS_BAD; }
   if (p_cls->restype != RTSTR) ConnStrUDLFile.clear();
   else
   {
      ConnStrUDLFile = gsc_alltrim(p_cls->resval.rstring);
      if (gsc_path_exist(ConnStrUDLFile) == GS_GOOD)
         // traduco dir da assoluto in dir relativo
         if (gsc_nethost2drive(ConnStrUDLFile) == GS_BAD) return GS_BAD;
   }

   // UDL_PROP
   if ((p_cls = ColValues.CdrAssoc(_T("UDL_PROP"))) == NULL)
      { GS_ERR_COD = eGSInvRBType; return GS_BAD; }
   if (p_cls->restype != RTSTR) UDLProperties.remove_all();
   else
   {
      C_STRING Buffer(gsc_alltrim(p_cls->resval.rstring));
      
      // Conversione path UDLProperties da assoluto in dir relativo
      if (gsc_UDLProperties_nethost2drive(ConnStrUDLFile.get_name(), Buffer) == GS_BAD)
         return GS_BAD;
      if (gsc_PropListFromConnStr(Buffer.get_name(), UDLProperties) == GS_BAD)
         return GS_BAD;
   }

   if ((pConn = getDBConnection(OLD)) == NULL) return GS_BAD;

   // TABLE_REF
   if ((p_cls = ColValues.CdrAssoc(_T("TABLE_REF"))) == NULL || p_cls->restype != RTSTR)
      { GS_ERR_COD = eGSInvRBType; return GS_BAD; } 
   // Conversione riferimento tabella da dir assoluto in relativo
   if (OldTableRef.paste(pConn->FullRefTable_nethost2drive(gsc_alltrim(p_cls->resval.rstring))) == NULL)
      return GS_BAD;

   // KEY_ATTRIB
   if ((p_cls = ColValues.CdrAssoc(_T("KEY_ATTRIB"))) == NULL || p_cls->restype != RTSTR)
      { GS_ERR_COD = eGSInvRBType; return GS_BAD; }
   else key_attrib = gsc_alltrim(p_cls->resval.rstring);

   // LAST_ENT
   if ((p_cls = ColValues.CdrAssoc(_T("LAST_ENT"))) == NULL)
      { GS_ERR_COD = eGSInvRBType; return GS_BAD; }
   if (gsc_rb2Lng(p_cls, &OldLastId) == GS_BAD) OldLastId = 0;
   TempLastId = OldLastId;

   // LINKED_TABLE
   if ((p_cls = ColValues.CdrAssoc(_T("LINKED_TABLE"))))
      if (gsc_rb2Bool(p_cls, &LinkedTable) == GS_BAD) LinkedTable = false;

   // SQL_COND_ON_TABLE
   if ((p_cls = ColValues.CdrAssoc(_T("SQL_COND_ON_TABLE"))))
   {
      if (p_cls->restype == RTSTR) SqlCondOnTable = p_cls->resval.rstring;
      else SqlCondOnTable.clear();
   }

   return GS_GOOD;
}  

        
int gs_get_info(void)
{
   C_CLASS   *pCls;
   C_INFO    *info;
   resbuf    *arg;
   C_RB_LIST ret;
   int       prj, cls, sub;

   acedRetNil();
   // Legge nella lista dei parametri: progetto classe e sub
   arg = acedGetArgs();
   if (arg_to_prj_cls_sub(&arg, &prj, &cls, &sub) == GS_BAD) return RTERROR;

   // Ritorna il puntatore alla classe cercata
   if ((pCls = gsc_find_class(prj, cls, sub)) == NULL) return RTERROR;

   // Ritorna il puntatore a C_INFO della classe
   if ((info = pCls->ptr_info()) == NULL) return RTNORM;

   // Ritorna lista resbuf
   if ((ret << info->to_rb()) == NULL) return RTERROR;
   ret.LspRetList();

   return RTNORM;
}


/*********************************************************/
/*.doc gsc_valid_attrib_name                    <external> */
/*+
  Questa funzione controlla che il key_attrib sia corretto.
  Parametri:
  C_STRING &key_attrib;          Nome attributo chiave di ricerca
  C_DBCONNECTION *pConn;         Connessione OLE-DB
  C_ATTRIB_LIST *pattrib_list;   Lista degli attributi
    
  Restituisce GS_GOOD in caso di successo altrimenti GS_BAD.
-*/  
/*********************************************************/
int gsc_valid_attrib_name(C_STRING &key_attrib, C_DBCONNECTION *pConn, 
                          C_ATTRIB_LIST *pattrib_list)
{
   if (pConn->IsValidFieldName(key_attrib) == 0)
      { GS_ERR_COD = eGSInvalidKey; return GS_BAD; }
   if (pattrib_list == NULL) return GS_GOOD;
   if (pattrib_list->search_name(key_attrib.get_name(), FALSE) == NULL)
      { GS_ERR_COD = eGSInvalidKey; return GS_BAD; }

   return GS_GOOD;
}  

 
/****************************************************************************/
/*.doc C_INFO:reportHTML                                         <external> */
/*+
  Questa funzione stampa su un file HTML i dati della C_INFO.
  Parametri:
  FILE *file;     Puntatore a file
  bool SynthMode; Opzionale. Flag di modalità di report.
                  Se = true attiva il report sintetico (default = false)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/
/****************************************************************************/
int C_INFO::reportHTML(FILE *file, bool SynthMode)
{  
   C_STRING Buffer;
   C_STRING TitleBorderColor("#808080"), TitleBgColor("#c0c0c0");
   C_STRING BorderColor("#00CCCC"), BgColor("#99FFFF");

   if (SynthMode) return GS_GOOD;

   if (fwprintf(file, _T("\n<table bordercolor=\"%s\" bgcolor=\"%s\" width=\"100%%\" border=\"1\">"),
                TitleBorderColor.get_name(), TitleBgColor.get_name()) < 0)
      { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

   // "Collegamento a Database"
   if (fwprintf(file, _T("\n<tr><td align=\"center\"><b><font size=\"3\">%s</font></b></td></tr></table><br>"),
                gsc_msg(753)) < 0)
      { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

   // intestazione tabella
   if (fwprintf(file, _T("\n<table bordercolor=\"%s\" cellspacing=\"2\" cellpadding=\"2\" border=\"1\">"), 
                BorderColor.get_name()) < 0)
      { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

   Buffer.paste(gsc_PropListToConnStr(UDLProperties));

   // "Riferimento tabella"
   if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\" width=\"30%%\"><b>%s:</b></td><td width=\"70%%\">%s</td></tr>"),
                BgColor.get_name(), gsc_msg(727),
                (OldTableRef.len() == 0) ? _T("&nbsp;") : OldTableRef.get_name()) < 0)
      { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

   // "Connessione UDL"
   if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%s</td></tr>"),
                BgColor.get_name(), gsc_msg(728),
                (ConnStrUDLFile.len() == 0) ? _T("&nbsp;") : ConnStrUDLFile.get_name()) < 0)
      { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

   // "Proprietà UDL"
   if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%s</td></tr>"),
                BgColor.get_name(), gsc_msg(790),
                (Buffer.len() == 0) ? _T("&nbsp;") : Buffer.get_name()) < 0)
      { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

   // "Attributo chiave"
   if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%s</td></tr>"),
                BgColor.get_name(), gsc_msg(729),
                (key_attrib.len() == 0) ? _T("&nbsp;") : key_attrib.get_name()) < 0)
      { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

   // "Ultimo codice"
   if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%ld</td></tr>"),
                BgColor.get_name(), gsc_msg(730), OldLastId) < 0)
      { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

   // fine tabella
   if (fwprintf(file, _T("\n</table><br><br>")) < 0)
      { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

   return GS_GOOD;
}


/****************************************************************************/
/*.doc C_INFO::getOldLastIdFromDB                                <external> */
/*+ 
  Questa funzione legge il codice massimo delle entità usato per la tabella OLD
  senza aggiornare alcun membro della classe C_INFO.

  Restituisce il codice massimo in caso di successo altrimenti restituisce -1.
-*/
/****************************************************************************/
long C_INFO::getOldLastIdFromDB(void)
{ 
   C_DBCONNECTION *pConn;
   ads_real       Value;

   // ricavo connessione OLE-DB con tabelle OLD
   if ((pConn = getDBConnection(OLD)) == NULL) return GS_BAD;
   // ricavo il codice maggiore
   if (pConn->GetNumAggrValue(OldTableRef.get_name(),
                              key_attrib.get_name(), _T("MAX"), &Value) == GS_GOOD)
      return (long) Value;

   return -1;
}


/****************************************************************************/
/*.doc C_INFO::RefreshLastId                                     <external> */
/*+
  Questa funzione aggiorna il membro OldLastId che rappresenta il
  codice massimo delle entità usato per la tabella OLD.
  Parametri:
  bool SetTempLastIdEqualToOldLastId; Opzionale; Flag per impostare il
                                      codice massimo delle tabelle
                                      TEMP uguale a quello OLD (default = true)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
  N.B. Non chiamare questa funzione se la classe a cui appartiene la C_INFO
       è usata nella sessione di lavoro corrente a meno che si stia salvando.
-*/
/****************************************************************************/
int C_INFO::RefreshOldLastId(bool SetTempLastIdEqualToOldLastId)
{ 
   long Res;

   // ricavo il codice maggiore
   if ((Res = getOldLastIdFromDB()) == -1) return GS_BAD;
   OldLastId = Res;
   if (SetTempLastIdEqualToOldLastId) TempLastId = Res;

   return GS_GOOD;
}


/*********************************************************/
/*.doc C_INFO::TerminateSQL                   <internal> */
/*+
  Questa funzione annulla la connessione OLE-DB da terminare.
  Parametri:
  C_DBCONNECTION *pConnToTerminate; Opzionale; connessione da terminare,
                                    se non passata termina tutte le connessioni
                                    (default = NULL)
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
void C_INFO::TerminateSQL(C_DBCONNECTION *pConnToTerminate)
{
   bool Terminate = true;

   if (pConnToTerminate && pConnToTerminate != pTempTabConn) Terminate = false;
   if (Terminate) pTempTabConn = NULL;

   Terminate = true;
   if (pConnToTerminate && pConnToTerminate != pOldTabConn) Terminate = false;
   if (Terminate) pOldTabConn = NULL;
}


/*********************************************************/
/*.doc C_INFO::get_PrimaryKeyName             <external> */
/*+
  Questa funzione restituisce il nome della chiave primaria 
  della tabella alfanumerica.
  Parametri:
  C_STRING &PriKeyName; Nome chiave primaria
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_INFO::get_PrimaryKeyName(C_STRING &PriKeyName)
{
   C_DBCONNECTION *pConn;
   C_STRING       Catalog, Schema, Name;

   // ricavo connessione OLE-DB con tabelle OLD
   if ((pConn = getDBConnection(OLD)) == NULL) return GS_BAD;
   // Ricavo il nome della tabella
   if (pConn->split_FullRefTable(OldTableRef, Catalog, Schema, Name) == GS_BAD)
      return GS_BAD;
   // Nome della chiave primaria + attributo chiave
   PriKeyName = Name;
   PriKeyName += key_attrib;

   return GS_GOOD;
}


/*********************************************************/
/*.doc C_INFO::AdjTableParams                 <external> */
/*+
  Questa funzione corregge la tabella OLD nel caso sia una funzione
  con parametri come nel caso della tabella storica in cui il parametro è
  una data ("select * from myfunction(NULL::timestamp)"). Il parametro è
  espresso fra parentesi tonde ed è seguito da :: e dal tipo SQL
  (es. timestamp, numeric, varchar...)
  Parametri:
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_INFO::AdjTableParams(void)
{
   // se non si tratta di una tabella esterna
   if (!LinkedTable) return GS_GOOD;
   // Se la tabella OLD è una funzione con parametri
   if (getDBConnection(OLD)->AdjTableParams(OldTableRef) != GS_GOOD) return GS_BAD;

   return GS_GOOD;
}


//-----------------------------------------------------------------------//
//////////////////  C_INFO  FINE    ///////////////////////////////////////
//////////////////  C_GRID  INIZIO  ///////////////////////////////////////
//-----------------------------------------------------------------------//


int C_GRID::copy(C_GRID *out)
{
   if (out == NULL) { GS_ERR_COD = eGSNotAllocVar; return GS_BAD; }
   out->x  = x;
   out->y  = y;
   out->dx = dx;
   out->dy = dy;
   out->nx = nx;
   out->ny = ny;

   return GS_GOOD;
}  
//-----------------------------------------------------------------------//
int C_GRID::ToFile(C_STRING &filename, const TCHAR *sez)
{  
   C_PROFILE_SECTION_BTREE ProfileSections;
   bool                    Unicode = false;

   if (gsc_path_exist(filename) == GS_GOOD)
      if (gsc_read_profile(filename, ProfileSections, &Unicode) == GS_BAD) return GS_BAD;

   if (ToFile(ProfileSections, sez) == GS_BAD) return GS_BAD;

   return gsc_write_profile(filename, ProfileSections, Unicode);
}
int C_GRID::ToFile(C_PROFILE_SECTION_BTREE &ProfileSections, const TCHAR *sez)
{  
   TCHAR buf[GRID_PROFILE_LEN];

   swprintf(buf, GRID_PROFILE_LEN, _T("%lf,%lf,%lf,%lf,%ld,%ld"), x, y, dx, dy, nx, ny);
   
   return ProfileSections.set_entry(sez, _T("GRID"), buf);
}
//-----------------------------------------------------------------------//
int C_GRID::load(TCHAR *filename, const TCHAR *sez)
{
   C_PROFILE_SECTION_BTREE ProfileSections;

   if (gsc_read_profile(filename, ProfileSections) == GS_BAD) return GS_BAD;
   return load(ProfileSections, sez);
}
int C_GRID::load(C_PROFILE_SECTION_BTREE &ProfileSections, const TCHAR *sez)
{
   C_B2STR *pProfileEntry;

   if (!(pProfileEntry = ProfileSections.get_entry(sez, _T("GRID")))) return GS_CAN;
   swscanf(pProfileEntry->get_name2(), _T("%lf,%lf,%lf,%lf,%ld,%ld"), &x, &y, &dx, &dy, &nx, &ny);      
   
   return GS_GOOD;
}
//-----------------------------------------------------------------------//
resbuf *C_GRID::to_rb()
{
   return acutBuildList(RTREAL,x,
                        RTREAL,y,
                        RTREAL,dx,
                        RTREAL,dy,
                        RTSHORT,nx,
                        RTSHORT,ny,0);
} 
//-----------------------------------------------------------------------//
int C_GRID::from_rb(resbuf *rb)
{  
   while (1)
   {
      if (rb == NULL) break;
      if (rb->restype != RTLB) break;

      if ((rb = rb->rbnext) == NULL) break;
      if (gsc_rb2Dbl(rb, &x) == GS_BAD) break;

      if ((rb = rb->rbnext) == NULL) break;
      if (gsc_rb2Dbl(rb, &y) == GS_BAD) break;

      if ((rb = rb->rbnext) == NULL) break;
      if (gsc_rb2Dbl(rb, &dx) == GS_BAD) break;

      if ((rb = rb->rbnext) == NULL) break;
      if (gsc_rb2Dbl(rb, &dy) == GS_BAD) break;

      if ((rb = rb->rbnext) == NULL) break;
      if (gsc_rb2Lng(rb, &nx) == GS_BAD) break;

      if ((rb = rb->rbnext) == NULL) break;
      if (gsc_rb2Lng(rb, &ny) == GS_BAD) break;

      return GS_GOOD;
   }

   GS_ERR_COD = eGSInvRBType;
   
   return GS_BAD; 
} 
   

/*********************************************************/
/*.doc C_GRID::from_rb_db <internal> */
/*+
  Questa funzione carica i dati di una C_INFO da un resbuf generato dalla
  lettura su tabella GS_CLASS.
  Parametri:
  C_RB_LIST &ColValues;    lista colonna-valore della riga di GS_CLASS
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_GRID::from_rb_db(C_RB_LIST &ColValues)
{  
   presbuf p_cls;
   
   if ((p_cls = ColValues.CdrAssoc(_T("ORIG_X"))) == NULL)  // ORIG_X
      { GS_ERR_COD = eGSInvalidArg; return GS_BAD; }
   if (gsc_rb2Dbl(p_cls, &x) == GS_BAD) x = 0;

   if ((p_cls = ColValues.CdrAssoc(_T("ORIG_Y"))) == NULL)  // ORIG_Y
      { GS_ERR_COD = eGSInvalidArg; return GS_BAD; }
   if (gsc_rb2Dbl(p_cls, &y) == GS_BAD) y = 0;

   if ((p_cls = ColValues.CdrAssoc(_T("DELTA_X"))) == NULL)  // DELTA_X
      { GS_ERR_COD = eGSInvalidArg; return GS_BAD; }
   if (gsc_rb2Dbl(p_cls, &dx) == GS_BAD) dx = 0;

   if ((p_cls = ColValues.CdrAssoc(_T("DELTA_Y"))) == NULL)  // DELTA_Y
      { GS_ERR_COD = eGSInvalidArg; return GS_BAD; }
   if (gsc_rb2Dbl(p_cls, &dy) == GS_BAD) dy = 0;

   if ((p_cls = ColValues.CdrAssoc(_T("ELEMENTS_X"))) == NULL)  // ELEMENTS_X
      { GS_ERR_COD = eGSInvalidArg; return GS_BAD; }
   if (gsc_rb2Lng(p_cls, &nx) == GS_BAD) nx = 0;

   if ((p_cls = ColValues.CdrAssoc(_T("ELEMENTS_Y"))) == NULL)  // ELEMENTS_Y
      { GS_ERR_COD = eGSInvalidArg; return GS_BAD; }
   if (gsc_rb2Lng(p_cls, &ny) == GS_BAD) ny = 0;
   
   return GS_GOOD;
}  
   

/*********************************************************/
/*.doc to_rb_db <internal> */
/*+
  Questa funzione scarica i dati di una GRID in un resbuf per scrivere
  nella tabella GS_CLASS.
  Parametri:
  presbuf *colvalues;    lista colonna-valore della riga di GS_CLASS
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_GRID::to_rb_db(presbuf *colvalues)
{
   if ((*colvalues = acutBuildList(RTLB, RTSTR, _T("ORIG_X"), RTREAL, x, RTLE, 
                                   RTLB, RTSTR, _T("ORIG_Y"), RTREAL, y, RTLE,
                                   RTLB, RTSTR, _T("DELTA_X"), RTREAL, dx, RTLE,
                                   RTLB, RTSTR, _T("DELTA_Y"), RTREAL, dy, RTLE,
                                   RTLB, RTSTR, _T("ELEMENTS_X"), RTREAL, (double) nx, RTLE,
                                   RTLB, RTSTR, _T("ELEMENTS_Y"), RTREAL, (double) ny, RTLE,
                                   0)) == NULL)
      { GS_ERR_COD = eGSOutOfMem; return GS_BAD; }
   
   return GS_GOOD;
}  

                           
/*********************************************************/
/*.doc is_valid <internal> */
/*+
  Questa funzione verifica la correttezza della C_GRID.
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_GRID::is_valid(void)
{               
   if (dx <= 0) { GS_ERR_COD = eGSInvalidGrid; return GS_BAD; }
   if (dy <= 0) { GS_ERR_COD = eGSInvalidGrid; return GS_BAD; }
   if (nx < 1) { GS_ERR_COD = eGSInvalidGrid; return GS_BAD; }
   if (ny < 1) { GS_ERR_COD = eGSInvalidGrid; return GS_BAD; }
   
   return GS_GOOD;
}  


/****************************************************************************/
/*.doc C_GRID::reportHTML                                        <external> */
/*+
  Questa funzione stampa su un file HTML i dati della C_GRID.
  Parametri:
  FILE *file;     Puntatore a file
  bool SynthMode; Opzionale. Flag di modalità di report.
                  Se = true attiva il report sintetico (default = false)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/
/****************************************************************************/
int C_GRID::reportHTML(FILE *file, bool SynthMode)
{  
   C_STRING TitleBorderColor("#808080"), TitleBgColor("#c0c0c0");
   C_STRING BorderColor("#00CCCC"), BgColor("#99FFFF");

   if (SynthMode) return GS_GOOD;

   if (fwprintf(file, _T("\n<table bordercolor=\"%s\" bgcolor=\"%s\" width=\"100%%\" border=\"1\">"),
                TitleBorderColor.get_name(), TitleBgColor.get_name()) < 0)
      { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

   // "Caratteristiche Griglia"
   if (fwprintf(file, _T("\n<tr><td align=\"center\"><b><font size=\"3\">%s</font></b></td></tr></table><br>"),
                gsc_msg(754)) < 0)
      { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

   // intestazione tabella
   if (fwprintf(file, _T("\n<table bordercolor=\"%s\" cellspacing=\"2\" cellpadding=\"2\" border=\"1\">"),
                BorderColor.get_name()) < 0)
      { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

   // "Punto di origine"
   if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\" width=\"30%%\"><b>%s:</b></td><td width=\"70%%\">%f,%f</td></tr>"),
                BgColor.get_name(), gsc_msg(731), x, y) < 0)
      { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

   // "Dim.X della cella"
   if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%f</td></tr>"),
                BgColor.get_name(), gsc_msg(732), dx) < 0)
      { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

   // "Dim.Y della cella"
   if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%f</td></tr>"),
                BgColor.get_name(), gsc_msg(733), dy) < 0)
      { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

   // "Numero celle asse X"
   if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%ld</td></tr>"),
                BgColor.get_name(), gsc_msg(734), nx) < 0)
      { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

   // "Numero celle asse Y"
   if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%ld</td></tr>"),
                BgColor.get_name(), gsc_msg(735), ny) < 0)
      { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

   // fine tabella
   if (fwprintf(file, _T("\n</table><br><br>")) < 0)
      { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

   return GS_GOOD;
}


//-----------------------------------------------------------------------//
//////////////////  C_GRID  FINE    ///////////////////////////////////////
//////////////////  C_CONNECT_LIST  INIZIO  ///////////////////////////////
//-----------------------------------------------------------------------//


int C_CONNECT_LIST::ToFile(C_STRING &filename, const TCHAR *sez)
{
   C_PROFILE_SECTION_BTREE ProfileSections;
   bool                    Unicode = false;

   if (gsc_path_exist(filename) == GS_GOOD)
      if (gsc_read_profile(filename, ProfileSections, &Unicode) == GS_BAD) return GS_BAD;

   if (ToFile(ProfileSections, sez) == GS_BAD) return GS_BAD;

   return gsc_write_profile(filename, ProfileSections, Unicode);
}
int C_CONNECT_LIST::ToFile(C_PROFILE_SECTION_BTREE &ProfileSections, const TCHAR *sez)
{
   TCHAR     buf[INT_INT_PROFILE_LEN], *list; 
   C_INT_INT *punt;
   int       num;

   punt = (C_INT_INT*) get_head();
   num = get_count();

   if ((list = (TCHAR *) malloc(sizeof (TCHAR) * (num * INT_INT_PROFILE_LEN + 1))) == NULL)
      { GS_ERR_COD = eGSOutOfMem; return GS_BAD; }
   list[0] = _T('\0');
   
   while (punt != NULL)
   {
      swprintf(buf, INT_INT_PROFILE_LEN, _T("%d %d "), punt->get_key(), punt->get_type());
      wcscat(list, buf);
      punt = (C_INT_INT *) get_next();
   }                             

   num = ProfileSections.set_entry(sez, _T("CONNECT"), list);
   free(list);
   
   return num;
}
//-----------------------------------------------------------------------//
int C_CONNECT_LIST::load(TCHAR *filename, const TCHAR *sez)
{
   C_PROFILE_SECTION_BTREE ProfileSections;

   if (gsc_read_profile(filename, ProfileSections) == GS_BAD) return GS_BAD;
   return load(ProfileSections, sez);
}
int C_CONNECT_LIST::load(C_PROFILE_SECTION_BTREE &ProfileSections, const TCHAR *sez)
{
   C_STRING  list;
   int       cl, type, nn, cont = 0;
   C_INT_INT *punt;
   C_B2STR   *pProfileEntry;

   if (!(pProfileEntry = ProfileSections.get_entry(sez, _T("CONNECT")))) return GS_CAN;
   list = pProfileEntry->get_name2();
   remove_all();
   gsc_strsep(list.get_name(), _T(' '));
   while (swscanf(list.get_name() + cont, _T("%d%d%n"), &cl, &type, &nn) != EOF)
   {
      punt = new C_INT_INT(cl, type);
      cont += nn; 
      add_tail(punt);
   }
   
   return GS_GOOD;      
}

                           
/*********************************************************/
/*.doc C_CONNECT_LIST::mod <internal> */
/*+
  Questa funzione modifica una C_CONNECT_LIST con i dati di un'altra
  C_CONNECT_LIST.
  Parametri:
  C_CONNECT_LIST *in;     C_CONNECT_LIST sorgente
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_CONNECT_LIST::mod(C_CONNECT_LIST *in)
{  
   C_INT_INT *pconct, *pnewconct;
   
   if (in==NULL) { GS_ERR_COD=eGSNotAllocVar; return GS_BAD; }
   
   remove_all();
   pconct = (C_INT_INT *) in->get_head();
   while (pconct != NULL)
   {  
      if ((pnewconct = new C_INT_INT) == NULL) return GS_BAD;
      pnewconct->set_key(pconct->get_key());
      pnewconct->set_type(pconct->get_type());
      if (add_tail(pnewconct) == GS_BAD) return GS_BAD;
      pconct = (C_INT_INT *) in->get_next();
   }

   return GS_GOOD;
}  


/*********************************************************/
/*.doc C_CONNECT_LIST::once_selclass <internal> */
/*+
  Questa funzione controlla che ciascuna classe sia presente una sola
  volta nella lista delle connessioni
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_CONNECT_LIST::once_selclass(void)
{  
   C_INT_INT *pconct;
   int indice = 1;

   if (is_empty() == TRUE) return GS_GOOD;

   pconct = (C_INT_INT *) getptr_at(indice);
   while (pconct != NULL)
   {  
      if (search_next_key(pconct->get_key()) != NULL)
         { GS_ERR_COD = eGSInvalidConct; return GS_BAD; }
      pconct = (C_INT_INT *) getptr_at(++indice);
   }   
 
   return GS_GOOD;
}


/*********************************************************/
/*.doc gsc_is_validconnect <internal> */
/*+
  Questa funzione controlla la validita' della connessione con la classe
  identificata da categoria e tipo.
  Parametri:
  int conct_code;      codice connessione
  int cat;             categoria classe con cui connetersi
  int Type;            Tipo classe con cui connetersi
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int gsc_is_validconnect(int conct_code, int cat, int Type)
{
   if (conct_code & CONCT_START_END) // solo per polilinea o superficie
      if (!(cat == CAT_SIMPLEX && (Type == TYPE_POLYLINE || Type == TYPE_SURFACE)))
         { GS_ERR_COD = eGSInvalidConct; return GS_BAD; }

   if (conct_code & CONCT_MIDDLE)    // solo per polilinea o superficie
      if (!(cat == CAT_SIMPLEX && (Type == TYPE_POLYLINE || Type == TYPE_SURFACE)))
         { GS_ERR_COD = eGSInvalidConct; return GS_BAD; }

   if (conct_code & CONCT_POINT)     // solo per testo o nodo
      if (!(cat == CAT_SIMPLEX && (Type == TYPE_TEXT || Type == TYPE_NODE)))
         { GS_ERR_COD = eGSInvalidConct; return GS_BAD; }

   if (conct_code & CONCT_VERTEX)    // solo per polilinea o superficie
      if (!(cat == CAT_SIMPLEX && (Type == TYPE_POLYLINE || Type == TYPE_SURFACE)))
         { GS_ERR_COD = eGSInvalidConct; return GS_BAD; }

   if (conct_code & CONCT_ANY_POINT) // solo per polilinea o superficie
      if (!(cat == CAT_SIMPLEX && (Type == TYPE_POLYLINE || Type == TYPE_SURFACE)))
         { GS_ERR_COD = eGSInvalidConct; return GS_BAD; }

   if (conct_code & CONCT_CENTROID)  // solo per superficie
      if (!(cat == CAT_SIMPLEX && Type == TYPE_SURFACE))
         { GS_ERR_COD = eGSInvalidConct; return GS_BAD; }

   if (conct_code & NO_OVERLAP)   // solo per testo o nodo
      if (!(cat == CAT_SIMPLEX && (Type == TYPE_TEXT || Type == TYPE_NODE)))
         { GS_ERR_COD = eGSInvalidConct; return GS_BAD; }

   if (conct_code & SOFT_SPLIT) // solo per polilinea
      if (!(cat == CAT_SIMPLEX && Type == TYPE_POLYLINE))
         { GS_ERR_COD = eGSInvalidConct; return GS_BAD; }
      
   if (conct_code & HARD_SPLIT) // solo per polilinea
      if (!(cat == CAT_SIMPLEX && Type == TYPE_POLYLINE))
         { GS_ERR_COD = eGSInvalidConct; return GS_BAD; }     

   // connessioni ammesse solo per classi di categoria CAT_SIMPLEX
   if (cat != CAT_SIMPLEX) { GS_ERR_COD = eGSInvalidConct; return GS_BAD; }

   return GS_GOOD;
}


/*********************************************************/
/*.doc gsc_del_memconnect <internal> */
/*+
  Questa funzione cancella le connessioni relative ad una classe da cancellare
  agendo solo sulle classi già caricate in memoria.
  Parametri:
  C_NODE *pFather;   puntatore a progetto padre
  int cls;           classe da cancellare
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int gsc_del_memconnect(C_NODE *pFather, int cls)
{
   C_PROJECT      *pFatherPrj = (C_PROJECT *) pFather;
   C_CLASS_LIST   *class_list;
   C_CLASS        *pclass;
   C_CONNECT_LIST *p_connect_list;
   C_INT_INT      *p_connect;

   class_list = pFatherPrj->ptr_classlist();
   pclass = (C_CLASS *) class_list->get_head();
   while (pclass)
   {
      if ((p_connect_list = pclass->ptr_connect_list()) != NULL)
         if ((p_connect = (C_INT_INT *) p_connect_list->search_key(cls)) != NULL)
            p_connect_list->remove_at(); // cancella la connessione riferita alla classe <cls>

      pclass = (C_CLASS *) class_list->get_next();
   }

   return GS_GOOD;
}


/****************************************************************************/
/*.doc C_CONNECT_LIST::reportHTML                                <external> */
/*+
  Questa funzione stampa su un file HTML i dati della C_CONNECT_LIST.
  Parametri:
  FILE *file;     puntatore a file
  C_NODE *pPrj;   puntatore a progetto
  int cls;        codice classe di appartenenza
  int sub;        codice sottoclasse di appartenenza
  bool SynthMode; Opzionale. Flag di modalità di report.
                  Se = true attiva il report sintetico (default = false)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/
/****************************************************************************/
int C_CONNECT_LIST::reportHTML(FILE *file, C_NODE *pPrj, int cls, int sub,
                               bool SynthMode)
{  
   C_INT_INT *punt;
   C_CLASS   *pCls;
   C_STRING  ClassName, StrConnect;
   C_STRING  TitleBorderColor("#808080"), TitleBgColor("#c0c0c0");
   C_STRING  BorderColor("#00CCCC"), BgColor("#99FFFF");

   if (SynthMode) return GS_GOOD;

   if (fwprintf(file, _T("\n<table bordercolor=\"%s\" bgcolor=\"%s\" width=\"100%%\" border=\"1\">"),
                TitleBorderColor.get_name(), TitleBgColor.get_name()) < 0)
      { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

   // "Lista delle Connessioni"
   if (fwprintf(file, _T("\n<tr><td align=\"center\"><b><font size=\"3\">%s</font></b></td></tr></table><br>"),
                gsc_msg(755)) < 0)
      { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

   punt  = (C_INT_INT *) get_head();

   if (!punt)
   {
      if (fwprintf(file, _T("<br>%s\n"), gsc_msg(32)) < 0) // "Nessuna"
         { GS_ERR_COD = eGSWriteFile; return GS_BAD; }
      return GS_GOOD;
   }

   // intestazione tabella
   if (fwprintf(file, _T("\n<table bordercolor=\"%s\" cellspacing=\"2\" cellpadding=\"2\" border=\"1\">"), 
                BorderColor.get_name()) < 0)
      { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

   // "Connessione con" "Modalità"
   ClassName = gsc_msg(737);
   if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\" width=\"50%%\"><b>%s</b></td><td bgcolor=\"%s\" width=\"50%%\"><b>%s</b></td></tr>"),
                BgColor.get_name(), gsc_msg(736), BgColor.get_name(), ClassName.get_name()) < 0)
      { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

   while (punt)
   {
      if (sub > 0)
      {  // Ritorna il puntatore alla classe cercata
         if ((pCls = ((C_PROJECT *) pPrj)->find_class(cls)) == NULL) return GS_BAD;
         ClassName = pCls->get_name();
         if ((pCls = ((C_PROJECT *) pPrj)->find_class(cls, punt->get_key())) == NULL) return GS_BAD;
         ClassName += _T("-");
         ClassName += pCls->get_name();
      }
      else
      {  // Ritorna il puntatore alla classe cercata
         if ((pCls = ((C_PROJECT *) pPrj)->find_class(punt->get_key())) == NULL) return GS_BAD;
         ClassName = pCls->get_name();
      }

      gsc_getConnectDescr(punt->get_type(), StrConnect);

      if (fwprintf(file, _T("\n<tr><td align=\"right\" valign=\"top\">%s</td><td>%s</td></tr>"),
                   ClassName.get_name(), StrConnect.get_name()) < 0)
         { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

      punt = (C_INT_INT *) get_next();
   }

   // fine tabella
   if (fwprintf(file, _T("\n</table><br><br>")) < 0)
      { GS_ERR_COD = eGSWriteFile; return GS_BAD; }
   
   return GS_GOOD;
}


//-----------------------------------------------------------------------//
//////////////////  C_CONNECT_LIST  FINE    ///////////////////////////////
//////////////////  C_GROUP_LIST  INIZIO  ///////////////////////////////
//-----------------------------------------------------------------------//


int C_GROUP_LIST::ToFile(C_STRING &filename, const TCHAR *sez)
{
   C_PROFILE_SECTION_BTREE ProfileSections;
   bool                    Unicode = false;

   if (gsc_path_exist(filename) == GS_GOOD)
      if (gsc_read_profile(filename, ProfileSections, &Unicode) == GS_BAD) return GS_BAD;

   if (ToFile(ProfileSections, sez) == GS_BAD) return GS_BAD;

   return gsc_write_profile(filename, ProfileSections, Unicode);
}
int C_GROUP_LIST::ToFile(C_PROFILE_SECTION_BTREE &ProfileSections, const TCHAR *sez)
{
   TCHAR     buf[INT_INT_PROFILE_LEN], *list; 
   C_INT_INT *punt;
   int       num;

   punt = (C_INT_INT *) get_head();
   num  = get_count();

   if ((list = (TCHAR *) malloc(sizeof (TCHAR) * (num * INT_INT_PROFILE_LEN + 1))) == NULL)
      { GS_ERR_COD = eGSOutOfMem; return GS_BAD; }
   list[0] = _T('\0');
   
   while (punt != NULL)
   {
      swprintf(buf, INT_INT_PROFILE_LEN, _T("%d %d "), punt->get_key(), punt->get_type());
      wcscat(list, buf);
      punt = (C_INT_INT *) get_next();
   }                             

   num = ProfileSections.set_entry(sez, _T("GROUP"), list);
   free(list);
   
   return num;
}
//-----------------------------------------------------------------------//
int C_GROUP_LIST::load(TCHAR *filename, const TCHAR *sez)
{
   C_PROFILE_SECTION_BTREE ProfileSections;

   if (gsc_read_profile(filename, ProfileSections) == GS_BAD) return GS_BAD;
   return load(ProfileSections, sez);
}
int C_GROUP_LIST::load(C_PROFILE_SECTION_BTREE &ProfileSections, const TCHAR *sez)
{
   C_STRING  list; 
   int       cl, type, nn, cont = 0;
   C_INT_INT *punt;
   C_B2STR   *pProfileEntry;

   if (!(pProfileEntry = ProfileSections.get_entry(sez, _T("GROUP")))) return GS_CAN;
   list = pProfileEntry->get_name2();
   remove_all();
   gsc_strsep(list.get_name(), _T(' '));
   while (swscanf(list.get_name() + cont, _T("%d%d%n"), &cl, &type, &nn) != EOF)
   {
      punt = new C_INT_INT(cl, type);
      cont+=nn; 
      add_tail(punt);
   }
   
   return GS_GOOD;      
}

                           
/*********************************************************/
/*.doc C_GROUP_LIST::is_valid <internal> */
/*+
  Questa funzione verifica la correttezza della C_GROUP_LIST.
  Parametri:
  C_NODE *pPrj;         puntatore a progetto
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_GROUP_LIST::is_valid(C_NODE *pPrj)
{  
   C_INT_INT *pGroup;
   int indice = 1;
   C_CLASS *pCls;
   
   if (is_empty() == TRUE) { GS_ERR_COD = eGSInvalidGroup; return GS_BAD; }

   // verifico che una classe sia selezionata una volta sola
   pGroup = (C_INT_INT*) getptr_at(1);
   while (pGroup != NULL)
   {  
      if (search_next_key(pGroup->get_key()) != NULL)
         { GS_ERR_COD = eGSInvalidGroup; return GS_BAD; }
      pGroup = (C_INT_INT*) getptr_at(++indice);
   }   
   
   pGroup = (C_INT_INT*) get_head();
   while (pGroup != NULL)
   {                 
      // Ritorna il puntatore alla classe cercata
      if ((pCls = ((C_PROJECT *) pPrj)->find_class(pGroup->get_key())) == NULL)
         { GS_ERR_COD = eGSInvalidGroup; return GS_BAD; }
      // verifico che la categoria sia corretta
      if (pCls->get_category() != CAT_SIMPLEX)
         { GS_ERR_COD = eGSInvalidGroup; return GS_BAD; }
      pGroup = (C_INT_INT *) get_next();
   }
   
   return GS_GOOD;
}  


/****************************************************************************/
/*.doc C_GROUP_LIST::reportHTML                                  <external> */
/*+
  Questa funzione stampa su un file HTML i dati della C_GROUP_LIST.
  Parametri:
  FILE *file;     puntatore a file
  C_NODE *pPrj;   puntatore a progetto
  bool SynthMode; Opzionale. Flag di modalità di report.
                  Se = true attiva il report sintetico (default = false)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/
/****************************************************************************/
int C_GROUP_LIST::reportHTML(FILE *file, C_NODE *pPrj, bool SynthMode)
{  
   C_INT_INT *punt = (C_INT_INT *) get_head();
   C_CLASS   *pCls;
   C_STRING  TitleBorderColor("#808080"), TitleBgColor("#c0c0c0");
   C_STRING  BorderColor("#00CCCC"), BgColor("#99FFFF");
   C_STRING  dummy;

   if (SynthMode) return GS_GOOD;

   if (fwprintf(file, _T("\n<table bordercolor=\"%s\" bgcolor=\"%s\" width=\"100%%\" border=\"1\">"),
                TitleBorderColor.get_name(), TitleBgColor.get_name()) < 0)
      { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

   // "Composizione della Classe"
   if (fwprintf(file, _T("\n<tr><td align=\"center\"><b><font size=\"3\">%s</font></b></td></tr></table><br>"),
                gsc_msg(756)) < 0)
      { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

   // intestazione tabella
   if (fwprintf(file, _T("\n<table bordercolor=\"%s\" cellspacing=\"2\" cellpadding=\"2\" border=\"1\">"), 
                BorderColor.get_name()) < 0)
      { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

   // "Classe composta da" "N. entità"
   dummy = gsc_msg(739);
   if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\" width=\"50%%\"><b>%s</b></td><td bgcolor=\"%s\" width=\"50%%\"><b>%s</b></td></tr>"),
                BgColor.get_name(), gsc_msg(738), BgColor.get_name(), dummy.get_name()) < 0)
      { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

   while (punt)
   {
      // Ritorna il puntatore alla classe cercata
      if ((pCls = ((C_PROJECT *) pPrj)->find_class(punt->get_key(), 0)) == NULL) return GS_BAD;

      if (fwprintf(file, _T("\n<tr><td align=\"right\">%s</td><td>%ld</td></tr>"),
                  pCls->get_name(), punt->get_type()) < 0)
         { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

      punt = (C_INT_INT *) get_next();
   }

   // fine tabella
   if (fwprintf(file, _T("\n</table><br><br>")) < 0)
      { GS_ERR_COD = eGSWriteFile; return GS_BAD; }
   
   return GS_GOOD;
}


//-----------------------------------------------------------------------//
//////////////////  C_GROUP_LIST  FINE    ///////////////////////////////                          
//////////////////  C_ATTRIB_LIST  INIZIO  ////////////////////////////////
//-----------------------------------------------------------------------//


// costruttore
C_ATTRIB_LIST::C_ATTRIB_LIST():C_LIST() {}


// distruttore
C_ATTRIB_LIST::~C_ATTRIB_LIST() {}


/*********************************************************/
/*.doc C_ATTRIB_LIST::sort_by_orderpos        <internal> */
/*+
  Questa funzione ordina la lista C_LIST in base al numero
  di posizione degli attributi.
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int CALLBACK gsc_C_ATTRIB_compare_by_OrderPos_asc(C_NODE *p1, C_NODE *p2)
{
   int n1 = ((C_ATTRIB *) p1)->OrderPos;
   int n2 = ((C_ATTRIB *) p2)->OrderPos;

   if (n1 == n2)
      return 0;
   else
      return (n1 > n2) ? 1 : -1; 
}
void C_ATTRIB_LIST::sort_by_orderpos(void)
{
   fCompPtr = &gsc_C_ATTRIB_compare_by_OrderPos_asc;
   sort();
}


/*********************************************************/
/*.doc C_ATTRIB_LIST::ToFile                  <internal> */
/*+
  Questa funzione salva su file la lista degli attributi.
  Parametri:
  C_STRING &filename;   File in cui scrivere le informazioni
  const TCHAR *sez;     Nome della sezione in cui scrivere

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_ATTRIB_LIST::ToFile(C_STRING &filename, const TCHAR *sez)
{
   C_PROFILE_SECTION_BTREE ProfileSections;
   bool                    Unicode = false;

   if (gsc_path_exist(filename) == GS_GOOD)
      if (gsc_read_profile(filename, ProfileSections, &Unicode) == GS_BAD) return GS_BAD;

   if (ToFile(ProfileSections, sez) == GS_BAD) return GS_BAD;

   return gsc_write_profile(filename, ProfileSections, Unicode);
}
int C_ATTRIB_LIST::ToFile(C_PROFILE_SECTION_BTREE &ProfileSections, const TCHAR *sez)
{
   C_ATTRIB *punt;
   int      num = 0;

   punt = (C_ATTRIB *) get_head();
   while (punt != NULL)
   {
      num++;
      if (punt->ToFile(ProfileSections, sez, num) == GS_BAD) return GS_BAD;
         
      punt = (C_ATTRIB *) get_next();
   }                             

   return GS_GOOD;
}
                  

/*********************************************************/
/*.doc C_ATTRIB_LIST::load <internal> */
/*+
  Questa funzione legge da file la lista degli attributi.
  Parametri:
  TCHAR *filename;                   file in cui leggere le informazioni
  const TCHAR *sez;                  nome della sezione in cui scrivere
  C_DBCONNECTION *pConn;             Connessione OLE-DB

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_ATTRIB_LIST::load(TCHAR *filename, const TCHAR *sez, C_DBCONNECTION *pConn)
{
   C_PROFILE_SECTION_BTREE ProfileSections;

   if (gsc_read_profile(filename, ProfileSections) == GS_BAD) return GS_BAD;
   return load(ProfileSections, sez, pConn);
}
//-----------------------------------------------------------------------//
int C_ATTRIB_LIST::load(C_PROFILE_SECTION_BTREE &ProfileSections, const TCHAR *sez, C_DBCONNECTION *pConn)
{
   C_ATTRIB *punt;
   int      num = 1, Result;

   remove_all();

   if (ProfileSections.search(sez) == NULL) return GS_CAN;

   if ((punt = new C_ATTRIB) == NULL) { GS_ERR_COD = eGSOutOfMem; return GS_BAD; }

   while ((Result = punt->load(ProfileSections, sez, pConn, num)) == GS_GOOD) 
   {
      add_tail(punt);
      num++;
      if ((punt = new C_ATTRIB) == NULL)
         { remove_all(); GS_ERR_COD = eGSOutOfMem; return GS_BAD; }
   }
   delete punt;

   // se sono uscito dal ciclo per un motivo diverso da GS_CAN
   if (Result != GS_CAN) { remove_all(); return GS_BAD; }

   // Ordino gli attributi per OrderPos
   sort_by_orderpos();

   // Inizializzo ordine di calcolo per eventuali attributi calcolati
   if (InitCalcOrderPos() == GS_BAD) return GS_BAD;
   
   return GS_GOOD;      
}
//-----------------------------------------------------------------------//
int C_ATTRIB_LIST::copy(C_ATTRIB_LIST *out)
{
   C_ATTRIB *new_attr, *punt;

   if (!out) { GS_ERR_COD = eGSNotAllocVar; return GS_BAD; }

   punt = (C_ATTRIB *) get_head();
   out->remove_all();
   
   while (punt)
   {
      if ((new_attr = new C_ATTRIB()) == NULL)
         { out->remove_all(); GS_ERR_COD = eGSOutOfMem; return GS_BAD; }
      if (new_attr->set(punt) == GS_BAD) { out->remove_all(); return GS_BAD; }
      out->add_tail(new_attr);

      punt = (C_ATTRIB *) get_next();
   }

   // Inizializzo ordine di calcolo per eventuali attributi calcolati
   if (out->InitCalcOrderPos() == GS_BAD) return GS_BAD;

   return GS_GOOD;
}
//-----------------------------------------------------------------------//
resbuf *C_ATTRIB_LIST::to_rb(void)
{
   C_RB_LIST List;
   C_ATTRIB  *punt;
            
   punt = (C_ATTRIB *) get_head();
   if (!punt) List << acutBuildList(RTNIL,0);

   while (punt)
   {
      if ((List += punt->to_rb()) == NULL) return NULL;
      punt = (C_ATTRIB *) get_next();
   }

   List.ReleaseAllAtDistruction(GS_BAD);

   return List.get_head();      
}
//-----------------------------------------------------------------------//
int C_ATTRIB_LIST::from_rb(resbuf *rb_list)
{
   C_ATTRIB *nod;
   int      ndx = 0;
   presbuf  rb;

   remove_all();

   if(!rb_list) { GS_ERR_COD=eGSInvRBType; return GS_BAD; }
   if(rb_list->restype!=RTLB)  { GS_ERR_COD=eGSInvRBType; return GS_BAD; }

   remove_all();
   while ((rb=gsc_nth(ndx++, rb_list)) != NULL)
   {
      if ((nod = new C_ATTRIB) == NULL)
         { GS_ERR_COD = eGSOutOfMem; remove_all(); return GS_BAD; }
   
      if (nod->from_rb(rb) == GS_BAD)
         { delete nod; remove_all(); return GS_BAD; }
              
      add_tail(nod);
   }                      

   // Ordino gli attributi per OrderPos
   sort_by_orderpos();

   // Inizializzo ordine di calcolo per eventuali attributi calcolati
   if (InitCalcOrderPos() == GS_BAD) return GS_BAD;

   return GS_GOOD;
}

                           
/*********************************************************/
/*.doc C_ATTRIB_LIST::mod <internal> */
/*+
  Questa funzione modifica una C_ATTRIB_LIST con i dati di un'altra
  C_ATTRIB_LIST.
  Parametri:
  C_ATTRIB_LIST *in;     C_ATTRIB_LIST sorgente
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_ATTRIB_LIST::mod(C_ATTRIB_LIST *in)
{  
   C_ATTRIB *pattrib, *pnewattrib;
   
   if (in==NULL) { GS_ERR_COD=eGSNotAllocVar; return GS_BAD; }
   
   remove_all();
   pattrib = (C_ATTRIB *) in->get_head();
   while (pattrib != NULL)
   {  
      if ((pnewattrib = new C_ATTRIB()) == NULL)
         { remove_all(); GS_ERR_COD = eGSOutOfMem; return GS_BAD; }
      if (pnewattrib->set(pattrib) == GS_BAD) { remove_all(); return GS_BAD; }

      if (add_tail(pnewattrib) == GS_BAD) { remove_all(); return GS_BAD; }
      pattrib = (C_ATTRIB *) in->get_next();
   }

   // Ordino gli attributi per OrderPos
   sort_by_orderpos();
   // Inizializzo ordine di calcolo per eventuali attributi calcolati
   if (InitCalcOrderPos() == GS_BAD) return GS_BAD;

   return GS_GOOD;
}  

                           
/*********************************************************/
/*.doc C_ATTRIB_LIST::mod_def <internal> */
/*+
  Questa funzione modifica i valori di default di una C_ATTRIB_LIST con i
  dati di un'altra C_ATTRIB_LIST.
  Parametri:
  C_ATTRIB_LIST *in;     C_ATTRIB_LIST sorgente
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_ATTRIB_LIST::mod_def(C_ATTRIB_LIST *in)
{
   C_ATTRIB *pattrib_sorg, *pattrib_dest;
   presbuf default_val, _def;
   
   if (in==NULL) { GS_ERR_COD=eGSNotAllocVar; return GS_BAD; }
   
   pattrib_sorg = (C_ATTRIB *) in->get_head();
   while (pattrib_sorg != NULL)
   {  
      if ((pattrib_dest = (C_ATTRIB *) search_name(pattrib_sorg->get_name(), FALSE)) == NULL)
         { GS_ERR_COD = eGSInvAttribName; return GS_BAD; }

      // se si vuole modificare il default verifico flag di modificabilità
      if (gsc_equal(pattrib_sorg->def, pattrib_dest->def) == GS_BAD)
         if (gsc_check_mod_attr(pattrib_dest->mod_attr, BIT_MOD_DEF) == GS_BAD)
            _def = pattrib_dest->def;
         else _def = pattrib_sorg->def;

      if ((default_val = gsc_copybuf(_def)) == NULL) return GS_BAD;

      pattrib_dest->def = default_val;
      pattrib_sorg      = (C_ATTRIB *) in->get_next();
   }

   return GS_GOOD;
}  


/*********************************************************/
/*.doc C_ATTRIB_LIST::mod_charact <internal> */
/*+
  Questa funzione modifica le caratteristiche degli attributi di una 
  C_ATTRIB_LIST con i dati di un'altra C_ATTRIB_LIST.
  Parametri:
  C_ATTRIB_LIST *in;     C_ATTRIB_LIST sorgente
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_ATTRIB_LIST::mod_charact(C_ATTRIB_LIST *in)
{
   C_ATTRIB *pattrib_sorg, *pattrib_dest;
   int      _OrderPos, _vis, _VisOnTooltip, _man, _IsDefCalc;
   TCHAR    *_calc_file, *_calc_func, *_valid_file, *_valid_func;
   C_STRING _Caption, _Descr, _ValidErrMsg;
   C_STRING _GphPrefix, _GphSuffix, _InputMask;
   
   if (in == NULL) { GS_ERR_COD = eGSNotAllocVar; return GS_BAD; }
   
   pattrib_sorg = (C_ATTRIB *) in->get_head();
   while (pattrib_sorg != NULL)
   {  
      if ((pattrib_dest = (C_ATTRIB *) search_name(pattrib_sorg->get_name(), FALSE)) == NULL)
         { GS_ERR_COD = eGSInvAttribName; return GS_BAD; }

      _OrderPos = pattrib_sorg->OrderPos;

      // se si vuole modificare l'etichetta verifico flag di modificabilità
      if ((pattrib_sorg->Caption.len() > 0 || pattrib_dest->Caption.len() > 0) &&
          pattrib_sorg->Caption.comp(pattrib_dest->Caption) != 0)
         if (gsc_check_mod_attr(pattrib_dest->mod_attr, BIT_MOD_CAPTION) == GS_BAD)
            _Caption = pattrib_dest->Caption;
         else _Caption = pattrib_sorg->Caption;
      else _Caption = pattrib_sorg->Caption;

      // se si vuole modificare la visibilità verifico flag di modificabilità
      if (pattrib_sorg->vis != pattrib_dest->vis)
         if (gsc_check_mod_attr(pattrib_dest->mod_attr, BIT_MOD_VIS) == GS_BAD)
            _vis = pattrib_dest->vis;
         else _vis = pattrib_sorg->vis;
      else _vis = pattrib_sorg->vis;

      // se si vuole modificare la visibilità in tooltip verifico flag di modificabilità
      if (pattrib_sorg->VisOnTooltip != pattrib_dest->VisOnTooltip)
         if (gsc_check_mod_attr(pattrib_dest->mod_attr, BIT_MOD_VIS_ON_TOOLTIP) == GS_BAD)
            _VisOnTooltip = pattrib_dest->VisOnTooltip;
         else _VisOnTooltip = pattrib_sorg->VisOnTooltip;
      else _VisOnTooltip = pattrib_sorg->VisOnTooltip;

      // se si vuole modificare la obbligatorietà verifico flag di modificabilità
      if (pattrib_sorg->man != pattrib_dest->man)
         if (gsc_check_mod_attr(pattrib_dest->mod_attr, BIT_MOD_MAND) == GS_BAD)
            _man = pattrib_sorg->man;
         else _man = pattrib_sorg->man; 
      else _man = pattrib_sorg->man;
         
      // se si vuole modificare la calcolabilità o il flag indicante
      // se la funzione di calcolo è riferita al valore di default
      // allora verifico flag di modificabilità
      if (gsc_strcmp(pattrib_sorg->calc_file, pattrib_dest->calc_file) != 0 ||
          gsc_strcmp(pattrib_sorg->calc_func, pattrib_dest->calc_func) != 0 ||
          pattrib_sorg->IsDefCalc != pattrib_dest->IsDefCalc)
         if (gsc_check_mod_attr(pattrib_dest->mod_attr, BIT_MOD_CALC) == GS_BAD)
         {
            _calc_file = pattrib_dest->calc_file;
            _calc_func = pattrib_dest->calc_func;
            _IsDefCalc = pattrib_dest->IsDefCalc;
         }
         else
         {
            _calc_file = pattrib_sorg->calc_file; 
            _calc_func = pattrib_sorg->calc_func;
            _IsDefCalc = pattrib_sorg->IsDefCalc;
         }
      else
      {
         _calc_file = pattrib_sorg->calc_file;
         _calc_func = pattrib_sorg->calc_func;
         _IsDefCalc = pattrib_sorg->IsDefCalc;
      }
         
      // se si vuole modificare la validità verifico flag di modificabilità
      if (gsc_strcmp(pattrib_sorg->valid_file, pattrib_dest->valid_file) != 0 ||
          gsc_strcmp(pattrib_sorg->valid_func, pattrib_dest->valid_func) != 0)
         if (gsc_check_mod_attr(pattrib_dest->mod_attr, BIT_MOD_VALID) == GS_BAD)
            { _valid_file = pattrib_dest->valid_file; _valid_func = pattrib_dest->calc_func; }
         else { _valid_file = pattrib_sorg->valid_file; _valid_func = pattrib_sorg->valid_func; }
      else { _valid_file = pattrib_sorg->valid_file; _valid_func = pattrib_sorg->valid_func; }

      // se si vuole modificare la descrizione verifico flag di modificabilità
      if ((pattrib_sorg->Descr.len() > 0 || pattrib_dest->Descr.len() > 0) &&
          pattrib_sorg->Descr.comp(pattrib_dest->Descr) != 0)
         if (gsc_check_mod_attr(pattrib_dest->mod_attr, BIT_MOD_DESCR) == GS_BAD)
            _Descr = pattrib_dest->Descr;
         else _Descr = pattrib_sorg->Descr;
      else _Descr = pattrib_sorg->Descr;
      
      // se si vuole modificare la descrizione verifico flag di modificabilità
      if ((pattrib_sorg->ValidErrMsg.len() > 0 || pattrib_dest->ValidErrMsg.len() > 0) &&
          pattrib_sorg->ValidErrMsg.comp(pattrib_dest->ValidErrMsg) != 0)
         if (gsc_check_mod_attr(pattrib_dest->mod_attr, BIT_MOD_VALIDATION_ERR_MSG) == GS_BAD)
            _ValidErrMsg = pattrib_dest->ValidErrMsg;
         else _ValidErrMsg = pattrib_sorg->ValidErrMsg;
      else _ValidErrMsg = pattrib_sorg->ValidErrMsg;

      // se si vuole modificare il prefisso grafico verifico flag di modificabilità
      if ((pattrib_sorg->GphPrefix.len() > 0 || pattrib_dest->GphPrefix.len() > 0) &&
          pattrib_sorg->GphPrefix.comp(pattrib_dest->GphPrefix) != 0)
         if (gsc_check_mod_attr(pattrib_dest->mod_attr, BIT_MOD_GPH_PREFIX_SUFFIX) == GS_BAD)
            _GphPrefix = pattrib_dest->GphPrefix;
         else _GphPrefix = pattrib_sorg->GphPrefix;
      else _GphPrefix = pattrib_sorg->GphPrefix;

      // se si vuole modificare il suffisso grafico verifico flag di modificabilità
      if ((pattrib_sorg->GphSuffix.len() > 0 || pattrib_dest->GphSuffix.len() > 0) &&
          pattrib_sorg->GphSuffix.comp(pattrib_dest->GphSuffix) != 0)
         if (gsc_check_mod_attr(pattrib_dest->mod_attr, BIT_MOD_GPH_PREFIX_SUFFIX) == GS_BAD)
            _GphSuffix = pattrib_dest->GphSuffix;
         else _GphSuffix = pattrib_sorg->GphSuffix;
      else _GphSuffix = pattrib_sorg->GphSuffix;

      // se si vuole modificare la maschera di input verifico flag di modificabilità
      if ((pattrib_sorg->InputMask.len() > 0 || pattrib_dest->InputMask.len() > 0) &&
          pattrib_sorg->InputMask.comp(pattrib_dest->InputMask) != 0)
         if (gsc_check_mod_attr(pattrib_dest->mod_attr, BIT_MOD_INPUT_MASK) == GS_BAD)
            _InputMask = pattrib_dest->InputMask;
         else _InputMask = pattrib_sorg->InputMask;
      else _InputMask = pattrib_sorg->InputMask;

      if (pattrib_dest->set_charact(_OrderPos, _Caption, _vis, _VisOnTooltip, _man,
                                    _calc_file, _calc_func, _IsDefCalc,
                                    _valid_file, _valid_func, _ValidErrMsg, _Descr,
                                    _GphPrefix, _GphSuffix, _InputMask) == GS_BAD)
         return GS_BAD;

      pattrib_sorg = (C_ATTRIB *) in->get_next();
   }

   return GS_GOOD;
}  


/*********************************************************/
/*.doc C_ATTRIB_LIST::get_vis_values <internal> */
/*+
  Questa funzione inizializza una lista di resbuf contenenti
  i valori trasformati in stringa dei soli attributi visibili.
  Parametri:
  C_RB_LIST ColValues;        Lista valori degli attributi
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
presbuf C_ATTRIB_LIST::get_vis_values(C_RB_LIST &ColValues)
{
   C_ATTRIB  *pAttrib;
   C_RB_LIST result;
   C_STRING  str;
   presbuf   p_rb;

   if ((result << acutBuildList(RTLB, 0)) == NULL) return NULL;

   pAttrib = (C_ATTRIB *) get_head();
   while (pAttrib)
   {
      if (pAttrib->is_visible() == GS_GOOD)
      {  
         if ((p_rb = ColValues.CdrAssoc(pAttrib->get_name())) != NULL)
         {
            if ((result += acutBuildList(RTLB, RTSTR, pAttrib->get_name(), 0)) == NULL) return NULL;

            // converto gli attributi numerici con lo standard (123.456 e NON con le impostazioni di window)
            if (gsc_DBIsNumeric(pAttrib->ADOType) == GS_GOOD)
            {
               if (p_rb->restype == RTNIL || p_rb->restype == RTNONE)
               {
                  if ((result += acutBuildList(RTNIL, 0)) == NULL) return NULL;
               }
               else
               {
                  str.paste(gsc_rb2str(p_rb, pAttrib->len, pAttrib->dec));
                  if ((result += gsc_str2rb(str)) == NULL) return NULL;
               }
            }
            else
            // converto gli attributi data con lo standard (dd/mm/yyyy e NON con le impostazioni di window)
            if (gsc_DBIsDate(pAttrib->ADOType) == GS_GOOD ||
                gsc_DBIsTimestamp(pAttrib->ADOType) == GS_GOOD)
            {
               if (p_rb->restype == RTNIL || p_rb->restype == RTNONE)
               {
                  if ((result += acutBuildList(RTNIL, 0)) == NULL) return NULL;
               }
               else
               {
                  if (gsc_getGEOsimDateTime(p_rb->resval.rstring, str) == GS_BAD)
                     return GS_BAD;
                  if ((result += gsc_str2rb(str)) == NULL) return NULL;
               }
            }
            else
            // converto gli attributi data con lo standard (hh:mm:ss e NON con le impostazioni di window)
            if (gsc_DBIsTime(pAttrib->ADOType) == GS_GOOD)
            {
               if (p_rb->restype == RTNIL || p_rb->restype == RTNONE)
               {
                  if ((result += acutBuildList(RTNIL, 0)) == NULL) return NULL;
               }
               else
               {
                  if (gsc_getSQLTime(p_rb->resval.rstring, str) == GS_BAD)
                     return GS_BAD;
                  if ((result += gsc_str2rb(str)) == NULL) return NULL;
               }
            }
            else
            // converto gli attributi logici
            if (gsc_DBIsBoolean(pAttrib->ADOType) == GS_GOOD)
            {
               str = (p_rb->restype == RTT) ? gsc_msg(774) : gsc_msg(775); // Sì No
               if ((result += gsc_str2rb(str)) == NULL) return NULL;
            }
            else
              if ((result += gsc_copybuf(p_rb)) == NULL) return NULL;

            if ((result += acutBuildList(RTLE, 0)) == NULL) return NULL;
         }
      }
      pAttrib = (C_ATTRIB *) get_next();
   }

   if ((result += acutBuildList(RTLE, 0)) == NULL) return NULL;
   result.ReleaseAllAtDistruction(GS_BAD);

   return result.get_head();
}  


/*********************************************************/
/*.doc C_ATTRIB_LIST::is_calculated <internal> */
/*+
  Restituisce GS_GOOD se la lista ha almeno un attributo da calcolare
  altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_ATTRIB_LIST::is_calculated(void)
{
   C_ATTRIB *p_attrib = (C_ATTRIB *) get_head();
   while (p_attrib)
   {  
      if (p_attrib->is_calculated() == GS_GOOD) return GS_GOOD;
      p_attrib = (C_ATTRIB *) get_next();
   }

   return GS_BAD;
}  


/*********************************************************/
/*.doc C_ATTRIB_LIST::is_DefCalculated        <internal> */
/*+
  Restituisce GS_GOOD se la lista ha almeno un attributo con valore di
  default da calcolare altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_ATTRIB_LIST::is_DefCalculated(void)
{
   C_ATTRIB *p_attrib = (C_ATTRIB *) get_head();
   while (p_attrib)
   {  
      if (p_attrib->is_DefCalculated() == GS_GOOD) return GS_GOOD;
      p_attrib = (C_ATTRIB *) get_next();
   }

   return GS_BAD;
}  


/*********************************************************/
/*.doc C_ATTRIB_LIST::is_validated <internal> */
/*+
  Restituisce GS_GOOD se la lista ha almeno un attributo da verificare
  altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_ATTRIB_LIST::is_validated()
{
   C_ATTRIB *p_attrib = (C_ATTRIB *) get_head();
   while (p_attrib)
   {  
      if (p_attrib->is_validated() == GS_GOOD) return GS_GOOD;
      p_attrib = (C_ATTRIB *) get_next();
   }

   return GS_BAD;
}  


/*********************************************************/
/*.doc C_ATTRIB_LIST::is_mandatory            <internal> */
/*+
  Restituisce GS_GOOD se la lista ha almeno un attributo obbligatorio
  altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_ATTRIB_LIST::is_mandatory(void)
{
   C_ATTRIB *p_attrib = (C_ATTRIB *) get_head();
   while (p_attrib)
   {  
      if (p_attrib->is_mandatory() == GS_GOOD) return GS_GOOD;
      p_attrib = (C_ATTRIB *) get_next();
   }

   return GS_BAD;
}  


/*********************************************************/
/*.doc C_ATTRIB_LIST::is_visible <internal> */
/*+
  Restituisce GS_GOOD se la lista ha almeno un attributo visibile
  altrimenti restituisce GS_BAD.
  Parametri:
  int *Qty;    Opzionale, puntatore al numero di attributi visibili
               (default = NULL)
-*/  
/*********************************************************/
int C_ATTRIB_LIST::is_visible(int *Qty)
{
   C_ATTRIB *p_attrib;
   
   if (Qty) *Qty = 0;

   p_attrib = (C_ATTRIB *) get_head();
   while (p_attrib != NULL)
   {  
      if (p_attrib->is_visible() == GS_GOOD)
      {
         if (Qty) *Qty = *Qty + 1;
         else return GS_GOOD;
      }
      p_attrib = (C_ATTRIB *) get_next();
   }

   if (Qty) return (*Qty > 0) ? GS_GOOD : GS_BAD;
   else return GS_BAD;
}  


/*********************************************************/
/*.doc C_ATTRIB_LIST::getFirstVisibleAttrib   <internal> */
/*+
  Restituisce il puntatore al primo attributo visibile nella lista
  altrimenti restituisce NULL.
-*/  
/*********************************************************/
C_ATTRIB* C_ATTRIB_LIST::getFirstVisibleAttrib()
{
   C_ATTRIB *pAttrib, *pPrev;
   
   pPrev = (C_ATTRIB *) get_cursor();
   pAttrib = (C_ATTRIB *) get_head();
   while (pAttrib != NULL)
   {  
      if (pAttrib->is_visible() == GS_GOOD) break;
      pAttrib = (C_ATTRIB *) pAttrib->get_next();
   }
   set_cursor(pPrev);

   return pAttrib;
}  


/*********************************************************/
/*.doc C_ATTRIB_LIST::is_from_graph <internal> */
/*+
  Restituisce GS_GOOD se la lista ha almeno un attributo che proviene
  dalla grafica (lunghezza, area ...) altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_ATTRIB_LIST::is_from_graph()
{
   C_ATTRIB *p_attrib;
   
   p_attrib = (C_ATTRIB *) get_head();
   while (p_attrib != NULL)
   {  
      if (p_attrib->is_from_graph() == GS_GOOD) return GS_GOOD;
      p_attrib = (C_ATTRIB *) get_next();
   }

   return GS_BAD;
}  


/*********************************************************/
/*.doc C_ATTRIB_LIST::getVisPos_name          <internal> */
/*+
  Restituisce la posizione di un determinato attributo 
  considerando i soli attributi visibili.
  Parametri:
  const TCHAR *in;    Nome attributo
-*/  
/*********************************************************/
int C_ATTRIB_LIST::getVisPos_name(const TCHAR *in)
{
   C_ATTRIB *p_attrib;
   int      i = 0;
   
   p_attrib = (C_ATTRIB *) get_head();
   while (p_attrib != NULL)
   {  
      if (p_attrib->is_visible() == GS_GOOD) i++;
      if (gsc_strcmp(p_attrib->get_name(), in, FALSE) == 0) return i;

      p_attrib = (C_ATTRIB *) get_next();
   }

   return GS_BAD;
}  


/*********************************************************/
/*.doc C_ATTRIB_LIST::WhatIsChanged <internal> */
/*+
  Data una nuova lista di attributi, questa funzione verifica se è cambiata
  la struttura della tabella oppure qualche caratteristica degli attributi 
  oppure qualche valore di default o se è cambiato qualcosa riguardante la 
  visibilità degli attributi.
  Parametri:
  C_ATTRIB_LIST *p_NewAttrib_list; nuova lista attributi
  presbuf       link             lista di coppie ((<nome1 nuovo><nome1 vecchio>)...)
  int           *stru;           se GS_GOOD è cambiata la struttura altrimenti GS_BAD
  int           *charact;        se GS_GOOD sono cambiate le caratteristiche degli attibuti
                                 (OrderPos, Caption, VisOnTooltip, Descr, ValidErrMsg, InputMask)
                                 altrimenti GS_BAD
  int           *def;            se GS_GOOD sono cambiati i valori di default degli attibuti
                                 altrimenti GS_BAD
  int           *vis;            se GS_GOOD è cambiata una caratteristica relativa
                                 alla grafica (es. un attributo visibile o un attributo 
                                 non visibile con funzione di calcolo da grafica)
                                 altrimenti GS_BAD
  int           *calc;           se GS_GOOD è cambiata la funzione di calcolo degli attributi
                                 altrimenti GS_BAD
  int           *valid;          se GS_GOOD è cambiata la funzione di validità degli attributi
                                 altrimenti GS_BAD
  int           *mand;           se GS_GOOD è cambiata l'obbligatorietà degli attributi
                                 altrimenti GS_BAD

  Restituisce GS_GOOD se la funzione ha dato esito positivo 
  altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_ATTRIB_LIST::WhatIsChanged(C_ATTRIB_LIST *p_NewAttrib_list, presbuf link,
                                 int *stru, int *charact, int *def, int *vis,
                                 int *calc, int *valid, int *mand)
{
   C_ATTRIB *p_NewAttrib, *p_OldAttrib, *pPrev;
   presbuf  p;
   int      ndx = 1;
   bool     CheckisInCalcOnVisibAttr;

   *stru    = GS_BAD;
   *def     = GS_BAD;
   *charact = GS_BAD;
   *vis     = GS_BAD;
   *calc    = GS_BAD;
   *valid   = GS_BAD;
   *mand    = GS_BAD;

   p_NewAttrib = (C_ATTRIB *) p_NewAttrib_list->get_head();
   while (p_NewAttrib)
   {
      CheckisInCalcOnVisibAttr = FALSE;

      // cerco nella lista di link
      if ((p = gsc_assoc(p_NewAttrib->get_name(), link)) == NULL) // attributo nuovo
      {
         CheckisInCalcOnVisibAttr = TRUE;

         *stru    = GS_GOOD; // è cambiata la struttura
         *def     = GS_GOOD; // è cambiato il valore di default

         // nuovo attributo visibile
         if (p_NewAttrib->is_visible() == GS_GOOD)
            *vis = GS_GOOD;

         // nuovo attributo ricavato dalla grafica
         if (p_NewAttrib->is_from_graph() == GS_GOOD)
            *vis = GS_GOOD;

         // nuovo attributo calcolato (solo valore) o
         // parametro di una funzione di calcolo
         if (p_NewAttrib->is_calculated() == GS_GOOD ||
             is_in_calc(p_NewAttrib->get_name()) == GS_GOOD)
            *calc = GS_GOOD;

         // nuovo attributo con verifica o parametro di una funzione di validità
         if (p_NewAttrib->is_validated() == GS_GOOD ||
             is_in_valid(p_NewAttrib->get_name()) == GS_GOOD)
            *valid = GS_GOOD;
         
         // nuovo attributo con obbligatorietà
         if (p_NewAttrib->is_mandatory() == GS_GOOD)
            *mand = GS_GOOD;
      }
      else // attributo proveniente da uno esistente
      {
         if ((p_OldAttrib = (C_ATTRIB *) search_name(gsc_nth(1, p)->resval.rstring, FALSE)) == NULL)
            { GS_ERR_COD = eGSInvAttribName; return GS_BAD; }
         
         // i 2 attributi non sono nella stessa posizione
         if (getpos_name(p_OldAttrib->get_name()) != ndx)
         {
            *stru = GS_GOOD; // è cambiata la struttura
         
            // è cambiato l'ordine della visibilità degli attributi           
            if (p_NewAttrib->is_visible() == GS_GOOD &&
                getVisPos_name(p_OldAttrib->get_name()) != 
                p_NewAttrib_list->getVisPos_name(p_OldAttrib->get_name()))
               *vis = GS_GOOD;
         }

         // controllo se il nome è uguale
         if (p_OldAttrib->name.comp(p_NewAttrib->name, FALSE) != 0)
         {
            CheckisInCalcOnVisibAttr = TRUE;

            *stru = GS_GOOD; // è cambiata la struttura

            // è cambiato l'ordine della visibilità degli attributi
            if (p_NewAttrib->is_visible() == GS_GOOD)
               *vis = GS_GOOD;

            // è cambiato un attributo parametro di una funzione di calcolo
            if (is_in_calc(p_NewAttrib->get_name()) == GS_GOOD) *calc = GS_GOOD;
            
            // è cambiato un attributo parametro di una funzione di validità
            if (is_in_valid(p_NewAttrib->get_name()) == GS_GOOD) *valid = GS_GOOD;
         }

         // controllo se la posizione nell'ordine di visualizzazione è uguale
         if (p_OldAttrib->OrderPos != p_NewAttrib->OrderPos)
            *charact = GS_GOOD; // è cambiata una caratteristica dell'attributo
         
         // controllo se l'etichetta è uguale
         if (p_OldAttrib->Caption.comp(p_NewAttrib->Caption) != 0)
            *charact = GS_GOOD; // è cambiata una caratteristica dell'attributo

         // controllo se il tipo è uguale
         if (gsc_strcmp(p_OldAttrib->type, p_NewAttrib->type) != 0)
         {
            CheckisInCalcOnVisibAttr = TRUE;

            *stru    = GS_GOOD; // è cambiata la struttura
         
            // è cambiato l'ordine della visibilità degli attributi
            if (p_NewAttrib->is_visible() == GS_GOOD)
               *vis = GS_GOOD;

            // è cambiato un attributo parametro di una funzione di calcolo
            if (is_in_calc(p_NewAttrib->get_name()) == GS_GOOD) *calc = GS_GOOD;
            
            // è cambiato un attributo parametro di una funzione di validità
            if (is_in_valid(p_NewAttrib->get_name()) == GS_GOOD) *valid = GS_GOOD;
         }

         // controllo se le dimensioni sono uguali
         if (p_OldAttrib->len != p_NewAttrib->len ||
             p_OldAttrib->dec != p_NewAttrib->dec)
         {
            CheckisInCalcOnVisibAttr = TRUE;

            *stru = GS_GOOD; // è cambiata la struttura
         
            // è cambiata la visibilità dell'attributo
            if (p_NewAttrib->is_visible() == GS_GOOD)
               *vis = GS_GOOD;

            // è cambiato un attributo parametro di una funzione di calcolo
            if (is_in_calc(p_NewAttrib->get_name()) == GS_GOOD) *calc = GS_GOOD;
            
            // è cambiato un attributo parametro di una funzione di validità
            if (is_in_valid(p_NewAttrib->get_name()) == GS_GOOD) *valid = GS_GOOD;
         }

         // controllo se l'obbligatorietà è uguale
         if (p_OldAttrib->man != p_NewAttrib->man)
            *mand = GS_GOOD; // è cambiata l'obbligatorietà dell'attributo

         // controllo se la funzione di validità è uguale
         if (gsc_strcmp(p_OldAttrib->valid_file, p_NewAttrib->valid_file) != 0 ||
             gsc_strcmp(p_OldAttrib->valid_func, p_NewAttrib->valid_func) != 0)
            *valid = GS_GOOD;
         
         // controllo se le funzioni di calcolo del valore sono uguali
         // se il calcolo del valore è cambiato
         if ((p_OldAttrib->is_calculated() != p_NewAttrib->is_calculated()) ||
             (p_NewAttrib->is_calculated() == GS_GOOD &&
              // la funzione di calcolo del valore è cambiata
              gsc_strcmp(p_OldAttrib->calc_file, p_NewAttrib->calc_file) != 0 ||
              gsc_strcmp(p_OldAttrib->calc_func, p_NewAttrib->calc_func) != 0))
         {
            CheckisInCalcOnVisibAttr = TRUE;

            *calc = GS_GOOD;

            // Se esiste una nuova funzione di calcolo
            if (gsc_strlen(p_NewAttrib->calc_func) > 0)
            {
               // attributo visibile
               if (p_NewAttrib->is_visible() == GS_GOOD)
                  *vis = GS_GOOD; 

               // attributo ricavato dalla grafica
               if (p_NewAttrib->is_from_graph() == GS_GOOD)
                  *vis = GS_GOOD; 
            }
         }
         
         // controllo se la visibilità è uguale
         if (p_OldAttrib->vis != p_NewAttrib->vis)
            *vis = GS_GOOD; // è cambiata la visibilità dell'attributo

         // controllo se la visibilità in tooltip è uguale
         if (p_OldAttrib->VisOnTooltip != p_NewAttrib->VisOnTooltip)
            *charact = GS_GOOD; // è cambiata una caratteristica dell'attributo

         // controllo se il valore di default è uguale
         if (!gsc_equal(p_OldAttrib->def, p_NewAttrib->def) ||
             // se il calcolo del valore di default è cambiato
             (p_OldAttrib->is_DefCalculated() != p_NewAttrib->is_DefCalculated()) ||
             // la funzione di calcolo del valore di default è cambiata
             (p_NewAttrib->is_DefCalculated() == GS_GOOD &&
              (gsc_strcmp(p_OldAttrib->calc_file, p_NewAttrib->calc_file) != 0 ||
              gsc_strcmp(p_OldAttrib->calc_func, p_NewAttrib->calc_func) != 0)))
            *def = GS_GOOD; // è cambiato il valore di default

         // controllo se la descrizione è uguale
         if (p_OldAttrib->Descr.comp(p_NewAttrib->Descr) != 0)
            *charact = GS_GOOD; // è cambiata una caratteristica dell'attributo

         // controllo se il messaggio di errore per validazione non rispettata è uguale
         if (p_OldAttrib->ValidErrMsg.comp(p_NewAttrib->ValidErrMsg) != 0)
            *charact = GS_GOOD; // è cambiata una caratteristica dell'attributo

         // controllo se il prefisso o il suffisso grafico sono uguali
         if (p_OldAttrib->GphPrefix.comp(p_NewAttrib->GphPrefix) != 0 ||
             p_OldAttrib->GphSuffix.comp(p_NewAttrib->GphSuffix) != 0)
            *vis = GS_GOOD; // è cambiata la visibilità dell'attributo

         // controllo se la maschera di input dati è uguale
         if (p_OldAttrib->InputMask.comp(p_NewAttrib->InputMask) != 0)
            *charact = GS_GOOD; // è cambiata una caratteristica dell'attributo
      }

      if (CheckisInCalcOnVisibAttr)
      {
         pPrev = p_NewAttrib;
         // se è usato come calcolo per un attributo visibile
         if (p_NewAttrib_list->is_in_calc(p_NewAttrib->get_name(), GS_GOOD) == GS_GOOD)
            *vis = GS_GOOD;

         p_NewAttrib_list->set_cursor(pPrev);
      }

      ndx++;
      p_NewAttrib = (C_ATTRIB *) p_NewAttrib->get_next();
   }

   // verifico attributi cancellati
   p_OldAttrib = (C_ATTRIB *) get_head();
   while (p_OldAttrib)
   {
      ndx = 0;
      // cerco nella lista di link
      while ((p = gsc_nth(ndx++, link)) != NULL)
         if (p_OldAttrib->name.comp(p->rbnext->rbnext->resval.rstring, FALSE) == 0) break;

      if (!p) // attributo cancellato
      {
         *stru    = GS_GOOD; // è cambiata la struttura
         *def     = GS_GOOD; // è cambiato il valore di default
         if (p_OldAttrib->is_visible() == GS_GOOD)
            *vis     = GS_GOOD; // è cambiata la visibilità dell'attributo
      }

      p_OldAttrib = (C_ATTRIB *) p_OldAttrib->get_next();
   }

   return GS_GOOD;
}


/****************************************************************************/
/*.doc C_ATTRIB_LIST::reportHTML                                 <external> */
/*+
  Questa funzione stampa su un file HTML i dati della C_ATTRIB_LIST.
  Parametri:
  FILE *file;     puntatore a file
  int prj;        codice progetto
  int cls;        codice classe
  int sub;        codice sottoclasse
  int sec;        codice tab. secondaria
  bool SynthMode; Opzionale. Flag di modalità di report.
                  Se = true attiva il report sintetico (default = false)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/
/****************************************************************************/
int C_ATTRIB_LIST::reportHTML(FILE *file, int prj, int cls, int sub, int sec,
                              bool SynthMode)
{  
   C_STRING TitleBorderColor("#808080"), TitleBgColor("#c0c0c0");
   C_STRING BorderColor("#00CCCC"), BgColor("#99FFFF");
   C_ATTRIB *punt;

   if (fwprintf(file, _T("\n<table bordercolor=\"%s\" bgcolor=\"%s\" width=\"100%%\" border=\"1\">"),
                TitleBorderColor.get_name(), TitleBgColor.get_name()) < 0)
      { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

   // "Composizione Tabella"
   if (fwprintf(file, _T("\n<tr><td align=\"center\"><b><font size=\"3\">%s</font></b></td></tr></table><br>"),
                gsc_msg(757)) < 0)
      { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

   if (SynthMode) // report sintetico
   {
      // inizio formato tabellare
      if (fwprintf(file, _T("\n<table bordercolor=\"%s\" cellspacing=\"2\" cellpadding=\"2\" border=\"1\">"), 
                   BorderColor.get_name()) < 0)
         { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

      // "Nome attributo"
      if (fwprintf(file, _T("\n<tr><td bgcolor=\"%s\"><b>%s</b></td>"),
                   BgColor.get_name(), gsc_msg(740)) < 0)
         { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

      // "Tipo attributo"
      if (fwprintf(file, _T("<td bgcolor=\"%s\"><b>%s</b></td>"),
                   BgColor.get_name(), gsc_msg(741)) < 0)
         { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

      // "Lunghezza" e decimali
      if (fwprintf(file, _T("<td bgcolor=\"%s\"><b>%s</b></td>"),
                   BgColor.get_name(), gsc_msg(742)) < 0)
         { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

      // "Valore di default"
      if (fwprintf(file, _T("<td bgcolor=\"%s\"><b>%s</b></td>"),
                   BgColor.get_name(), gsc_msg(750)) < 0)
         { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

      // "Calcolato"
      if (fwprintf(file, _T("<td bgcolor=\"%s\"><b>%s</b></td>"),
                   BgColor.get_name(), gsc_msg(477)) < 0)
         { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

      // "Lista di scelta"
      if (fwprintf(file, _T("<td bgcolor=\"%s\"><b>%s</b></td>"),
                   BgColor.get_name(), gsc_msg(382)) < 0)
         { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

      // fina riga
      if (fwprintf(file, _T("</tr>")) < 0)
         { GS_ERR_COD = eGSWriteFile; return GS_BAD; }
   }

   punt = (C_ATTRIB *) get_head();
   while (punt)
   {
      if (punt->reportHTML(file, prj, cls, sub, sec, SynthMode) == GS_BAD) return GS_BAD;

      punt = (C_ATTRIB *) get_next();
   }                             

   if (SynthMode) // report sintetico
   {
      // fine formato tabellare
      if (fwprintf(file, _T("\n</table><br><br>")) < 0)
         { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

      // stampa dettagliata per attributi calcolati o con liste di scelta
      C_STRING           SupportFile;
      ValuesListTypeEnum FileType;
      int                What;

      punt = (C_ATTRIB *) get_head();
      while (punt)
      {
         // Tutto tranne BIT_MOD_NAME e BIT_MOD_VIS (nome dell'attributo e visibilità)
         What = BIT_MOD_VALUES_LIST + BIT_MOD_CAPTION + BIT_MOD_VIS_ON_TOOLTIP +
                BIT_MOD_INPUT_MASK + BIT_MOD_GPH_PREFIX_SUFFIX + BIT_MOD_VALIDATION_ERR_MSG +
                BIT_MOD_DESCR + BIT_DEL_ATTR + BIT_MOD_TYPE + BIT_MOD_LEN +
                BIT_MOD_DEC + BIT_MOD_VIS + BIT_MOD_MAND + BIT_MOD_CALC +
                BIT_MOD_VALID + BIT_MOD_DEF;
         if (punt->is_calculated() == GS_GOOD) What -= BIT_MOD_CALC; // Se non è calcolato
         if (gsc_FindSupportFiles(punt->get_name(), prj, cls, sub, sec,
                                  SupportFile, &FileType) == GS_GOOD)
            What -= BIT_MOD_VALUES_LIST; // Se non esiste la lista di scelta
         if (punt->is_visible() == GS_GOOD) What -= BIT_MOD_VIS; // Se non è visibile

         if (!(What & BIT_MOD_CALC) || !(What & BIT_MOD_VALUES_LIST) || !(What & BIT_MOD_VIS))
            if (punt->reportHTML(file, prj, cls, sub, sec, false, What) == GS_BAD)
               return GS_BAD;

         punt = (C_ATTRIB *) get_next();
      }                             
   }

   return GS_GOOD;
}


/*********************************************************/
/*.doc C_ATTRIB_LIST::to_rb_db                <internal> */
/*+
  Questa funzione scarica la struttura della tabella di una classe o
  sottoclasse in una lista di resbuf.
  La struttura è nel formato Provider dipendente.
  Parametri:
  C_ATTRIB_LIST *plista;    lista struttura tabella
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
presbuf C_ATTRIB_LIST::to_rb_db(void)
{  
   C_ATTRIB  *pattributo;
   C_RB_LIST Stru;
   
   if ((Stru << acutBuildList(RTLB, 0)) == NULL) return NULL;
      
   pattributo = (C_ATTRIB *) get_head();
   while (pattributo)
   {  
      if ((Stru += acutBuildList(RTLB,
                                    RTSTR, (pattributo->name.len() == 0) ? GS_EMPTYSTR : pattributo->get_name(),
                                    RTSTR, pattributo->type,
                                    RTLONG, pattributo->len,
                                    RTLONG, pattributo->dec,
                                 RTLE, 0)) == NULL) return NULL;
                                      
      pattributo = (C_ATTRIB *) get_next();
   }
   
   if ((Stru += acutBuildList(RTLE, 0)) == NULL) return NULL;
   Stru.ReleaseAllAtDistruction(GS_BAD);

   return Stru.get_head();
}


/*********************************************************/
/*.doc C_ATTRIB_LIST::from_Block              <external> */
/*+
  Questa funzione carica la lista degli attributi leggendo 
  la lista degli attributi di un blocco.
  La struttura in è nel formato Provider DB dipendente.
  Parametri:
  C_DBCONNECTION *pConn;  Connessione al provider DB
  const TCHAR *ODTableName;   Nome Tabella OD
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_ATTRIB_LIST::from_Block(C_DBCONNECTION *pConn, const TCHAR *BlockName)
{  
   C_ATTRIB  *pAttribute;
   C_RB_LIST ATTDefStru;
   presbuf   pAttDef, p;
   int       i = 0, SQL_Dec;
   long      SQL_Len;
   C_STRING  SQL_Descr;

   remove_all();
   if ((ATTDefStru << gsc_getBlockAttributeDefs(BlockName)) == NULL) return GS_BAD;

   C_PROVIDER_TYPE *providerType;
   if ((providerType = pConn->getCharProviderType()) == NULL) return GS_BAD;

   // converto campo da codice ADO in Provider dipendente (testo)
   if (pConn->Type2ProviderType(providerType->get_Type(), // DataType
                                FALSE,          // IsLong
                                FALSE,          // IsFixedPrecScale
                                RTNIL,          // IsFixedLength
                                TRUE,           // IsWrite
                                132,            // Size
                                0,              // Prec
                                SQL_Descr,      // ProviderDescr
                                &SQL_Len, &SQL_Dec) == GS_BAD)
      return GS_BAD;

   while ((pAttDef = ATTDefStru.nth(i++)))
   {
      if ((pAttribute = new C_ATTRIB) == NULL)
         { GS_ERR_COD = eGSOutOfMem; remove_all(); return GS_BAD; }
      p = gsc_nth(0, pAttDef); // Nome
      pAttribute->name = p->resval.rstring;
      pAttribute->Caption = p->resval.rstring;

      gsc_strcpy(pAttribute->type, SQL_Descr.get_name(), MAX_LEN_FIELDTYPE);
      pAttribute->len = SQL_Len;
      pAttribute->dec = SQL_Dec;

      p = gsc_nth(1, pAttDef); // Default
      pAttribute->def = gsc_copybuf(p);

      p = gsc_nth(2, pAttDef); // Descr
      pAttribute->Descr = p->resval.rstring;
              
      add_tail(pAttribute);
   }

   return GS_GOOD;
}


/*********************************************************/
/*.doc C_ATTRIB_LIST::from_OD                 <external> */
/*+
  Questa funzione carica la lista degli attributi leggendo 
  la struttura di una tabella Object Data.
  La struttura in è nel formato Provider DB dipendente.
  Parametri:
  C_DBCONNECTION *pConn;  Connessione al provider DB
  const TCHAR *ODTableName;   Nome Tabella OD
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_ATTRIB_LIST::from_OD(C_DBCONNECTION *pConn, const TCHAR *ODTableName)
{  
   C_ATTRIB         *pAttribute;
   C_RB_LIST        ODStru;
   presbuf          pODField, p;
   int              i = 0, SQL_Dec;
   long             OD_Len, SQL_Len;
   AcMap::EDataType OD_Type;
   DataTypeEnum     ADO_Type;
   C_STRING         SQL_Descr;

   remove_all();
   if ((ODStru << gsc_getStruFromODTable(ODTableName)) == NULL) return GS_BAD;

   while ((pODField = ODStru.nth(i++)))
   {
      if ((pAttribute = new C_ATTRIB) == NULL)
         { GS_ERR_COD = eGSOutOfMem; remove_all(); return GS_BAD; }
      p = gsc_nth(0, pODField); // Nome
      pAttribute->name = p->resval.rstring;
      pAttribute->Caption = p->resval.rstring;

      p = gsc_nth(1, pODField); // Tipo
      // converto campo da tipo OD in codice ADO
      OD_Type = (AcMap::EDataType) p->resval.rint;
      switch (OD_Type)
      {
         case AcMap::kInteger:
            ADO_Type = adInteger;
            OD_Len   = -1;
            break;
         case AcMap::kReal:
            ADO_Type = adDouble;
            OD_Len   = -1;
            break;
         case AcMap::kCharacter:
         case AcMap::kPoint:
            ADO_Type = adWChar;
            OD_Len   = 132;
            break;
         default:
            return GS_BAD;
      }
      // converto campo da codice ADO in Provider dipendente
      if (pConn->Type2ProviderType(ADO_Type,  // DataType 
                                   FALSE,     // IsLong
                                   FALSE,     // IsFixedPrecScale
                                   RTNIL,     // IsFixedLength
                                   TRUE,      // IsWrite
                                   OD_Len,    // Size
                                   0,         // Prec
                                   SQL_Descr, // ProviderDescr
                                   &SQL_Len, &SQL_Dec) == GS_BAD)
         return GS_BAD;
      gsc_strcpy(pAttribute->type, SQL_Descr.get_name(), MAX_LEN_FIELDTYPE);
      pAttribute->len = SQL_Len;
      pAttribute->dec = SQL_Dec;

      if ((p = gsc_nth(2, pODField))) // Default
         pAttribute->def = gsc_copybuf(p);

      if ((p = gsc_nth(3, pODField))) // Descr
      pAttribute->Descr = p->resval.rstring;
              
      add_tail(pAttribute);
   }

   return GS_GOOD;
}


/*********************************************************/
/*.doc C_ATTRIB_LIST::from_DB                 <external> */
/*+
  Questa funzione carica la lista degli attributi leggendo 
  la struttura di una tabella di database.
  La struttura in è nel formato Provider DB dipendente.
  Parametri:
  C_DBCONNECTION *pDestConn;  Connessione al provider DB di destinazione
  C_DBCONNECTION *pSrcConn;   Connessione al provider DB sorgente
  const TCHAR *TableRef;      Riferimento alla tabella di database
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_ATTRIB_LIST::from_DB(C_DBCONNECTION *pDestConn, C_DBCONNECTION *pSrcConn,
                           const TCHAR *TableRef)
{
   C_RB_LIST DBStru;
   C_ATTRIB  *pAttribute;
   presbuf   pField, p;
   int       i = 0, DestProviderPrec;
   long      DestProviderSize;
   C_STRING  DestProviderDescr;

   remove_all();
   if ((DBStru << pSrcConn->ReadStruct(TableRef)) == NULL) return GS_BAD;

   while ((pField = DBStru.nth(i++)))
   {
      if ((pAttribute = new C_ATTRIB) == NULL)
         { GS_ERR_COD = eGSOutOfMem; remove_all(); return GS_BAD; }
      p = gsc_nth(0, pField); // Nome
      pAttribute->name = p->resval.rstring;

      // converto tipo nel formato del provider di destinazione
      if (pDestConn->Type2ProviderType((DataTypeEnum) gsc_nth(1, pField)->resval.rlong,     // tipo
                                       (gsc_nth(4, pField)->restype == RTT) ? TRUE : FALSE, // is long
                                       (gsc_nth(5, pField)->restype == RTT) ? TRUE : FALSE, // is PrecScale
                                       gsc_nth(6, pField)->restype,                         // is FixedLength
                                       (gsc_nth(7, pField)->restype == RTT) ? TRUE : FALSE, // IsAutoUniqueValue
                                       gsc_nth(2, pField)->resval.rlong,                    // dimensione
                                       gsc_nth(3, pField)->resval.rint,                     // precisione
                                       DestProviderDescr,
                                       &DestProviderSize,
                                       &DestProviderPrec) == GS_BAD)
      { 
         if (GS_ERR_COD != eGSUnkwnDrvFieldType) return GS_BAD;
         DestProviderDescr =_T("Unknown");
         DestProviderSize = -1;
         DestProviderPrec = -1;
      }
      gsc_strcpy(pAttribute->type, DestProviderDescr.get_name(), MAX_LEN_FIELDTYPE);
      pAttribute->len = DestProviderSize;
      pAttribute->init_ADOType(pDestConn);
      if (gsc_DBIsNumericWithDecimals(pAttribute->ADOType) == GS_GOOD &&
          DestProviderPrec < 0)
         pAttribute->dec = 2; // se double o single forzo 2 decimali
      else
         pAttribute->dec = DestProviderPrec;

      add_tail(pAttribute);
   }

   return GS_GOOD;
}


/*********************************************************/
/*.doc is_funcparam <internal> */
/*+
  Questa funzione verifica se un attributo è utilizzato come parametro
  di una funzione di calcolo o di validità di un attributo della tabella.
  Parmetri:
  TCHAR *fieldname;    nome attributo
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_ATTRIB_LIST::is_funcparam(TCHAR *fieldname)
{
   if (is_in_calc(fieldname) == GS_GOOD) return GS_GOOD;
   if (is_in_valid(fieldname) == GS_GOOD) return GS_GOOD;
   
   return GS_BAD; 
}                 


/*********************************************************/
/*.doc is_in_calc <internal> */
/*+
  Questa funzione verifica se un attributo è utilizzato come parametro
  di una funzione di calcolo della tabella.
  Parametri:
  TCHAR *fieldname;   nome attributo
  int  FilterOnVisib; Flag di ricerca, se = GS_GOOD cerca solo gli attributi visibili
                      (default = GS_BAD)
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_ATTRIB_LIST::is_in_calc(TCHAR *fieldname, int FilterOnVisib)
{ 
   C_ATTRIB *p_attrib;

   if (fieldname == NULL) return GS_BAD;
   if (wcslen(fieldname) == 0) return GS_BAD;   
   
   p_attrib = (C_ATTRIB*) get_head();
   while (p_attrib != NULL)
   {
      // Se esiste il filtro sugli attributi visibili
      if (FilterOnVisib == GS_GOOD && p_attrib->vis == GS_BAD)
         p_attrib = (C_ATTRIB*) get_next();
      else
         if (p_attrib->name.comp(fieldname, FALSE) != 0) // non è lo stesso attributo
            // è calcolato (valore o default) 
            if (p_attrib->is_calculated() == GS_GOOD || p_attrib->is_DefCalculated() == GS_GOOD)
               if (gsc_is_param(p_attrib->calc_file, p_attrib->calc_func, fieldname) == GS_GOOD)
                  return GS_GOOD;

      p_attrib = (C_ATTRIB*) get_next();
   }
   
   return GS_BAD;
}


/*********************************************************/
/*.doc is_in_valid <internal> */
/*+
  Questa funzione verifica se un attributo è utilizzato come parametro
  di una funzione di validità della tabella.
  Parametro:
  TCHAR *fieldname;    nome attributo
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_ATTRIB_LIST::is_in_valid(TCHAR *fieldname)
{ 
   C_ATTRIB *p_attrib;

   if (fieldname == NULL) return GS_BAD;
   if (wcslen(fieldname) == 0) return GS_BAD;   
   
   p_attrib = (C_ATTRIB*) get_head();
   while (p_attrib != NULL)
   {
      if (p_attrib->name.comp(fieldname, FALSE) != 0) // non è lo stesso attributo
         if (p_attrib->is_validated() == GS_GOOD)  // è con validità
            if (gsc_is_param(p_attrib->valid_file, p_attrib->valid_func, fieldname) == GS_GOOD)
               return GS_GOOD;
      p_attrib = (C_ATTRIB*) get_next();
   }
   
   return GS_BAD;
}


/*********************************************************/
/*.doc is_valid <internal> */
/*+
  Questa funzione verifica la validità della lista degli attributi:
  1) un attributo non può essere calcolato da un attributo calcolato a meno che
     quest'ultimo non sia calcolato da grafica
  2) un attributo sia verificato solo da se stesso.
  3) effettua il calcolo usando i valori di default statici
  4) effetta la validazione scartando gli attributi calcolati da grafica
  
  Parametri:
  C_DBCONNECTION *pConn;
  C_ATTRIB **pWrongAttrib; Attributo errato (default = NULL)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
  N.B.: Deve essere già stata chiamata la "C_ATTRIB_LIST::init_ADOType"
        e deve essere già stato caricato un eventuale GSL.GSL dal progetto della classe
-*/  
/*********************************************************/
int C_ATTRIB_LIST::is_valid(C_DBCONNECTION *pConn, C_ATTRIB **pWrongAttrib)
{ 
   C_ATTRIB   *p_attrib;
   C_RB_LIST  DefValues;                      

   if (pWrongAttrib) *pWrongAttrib = NULL;

   // Ordino gli attributi per OrderPos
   sort_by_orderpos();

   // Inizializzo i tipi ADO per ogni attributo
   if (init_ADOType(pConn) == GS_BAD) return GS_BAD;

   p_attrib = (C_ATTRIB*) get_head();
   while (p_attrib)
   {
      // verifico che il nome dell'attributo sia univoco
      if (search_next_name(p_attrib->get_name(), FALSE))
      {
         if (pWrongAttrib) *pWrongAttrib = p_attrib;
         GS_ERR_COD = eGSInvAttribName;
         return GS_BAD;
      }
      // verifico validità singolo attributo
      if (p_attrib->is_valid(pConn) == GS_BAD)
      {
         if (pWrongAttrib) *pWrongAttrib = p_attrib;
         return GS_BAD;
      }

      p_attrib = (C_ATTRIB*) p_attrib->get_next();
   }

   // Inizializzo ordine di calcolo per eventuali attributi calcolati
   // questa funzione verifica se ci sono dei calcoli ciclici (es. A=B e B=A)
   // (per il caso di "calcolato di se stesso" vedi is_valid di C_ATTRIB)
   if (InitCalcOrderPos() == GS_BAD) return GS_BAD;

   // un attributo può essere verificato anche da un altro attributo

   // usando i valori di default, verifico che le funzioni lisp
   // per la validazione e per i campi calcolati, siano corrette
   if (get_StaticDefValues(DefValues) == GS_BAD) return GS_BAD;

   if (TestAllCalc(DefValues) == GS_BAD || TestAllValid(DefValues, pWrongAttrib) == GS_BAD)
      return GS_BAD;

   // setto i valori di default corretti
   if (set_default_values(DefValues) == GS_BAD) return GS_BAD;

   return GS_GOOD;
}


/*********************************************************/
/*.doc is_valid <internal> */
/*+
  Questa funzione verifica la validità della lista degli attributi 
  in relazione alla categoria e al tipo della classe o sottoclasse o 
  secondaria. Si controlla che la lista contenga tutti gli attributi di 
  default, la visibilità o meno degli attributi.
  Parametri:
  int category;            categoria classe
  int type;                tipo classe
  C_DBCONNECTION *pConn;   Connessione OLE-DB
  C_STRING &key_attrib;    attributo chiave
  C_FAS *p_fas;            puntatore a FAS (default = NULL) per verificare che eventuali
                           funzioni di calcolo grafico non collidano con i campi calcolati.
  C_ATTRIB **pWrongAttrib; Attributo errato (default = NULL)
      
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_ATTRIB_LIST::is_valid(int category, int type, C_DBCONNECTION *pConn, C_STRING &key_attrib,
                            C_FAS *p_fas, C_ATTRIB **pWrongAttrib)
{ 
   C_ATTRIB_LIST def_attrib_list;
   C_ATTRIB      *p_attrib_def, *p_attrib;
   presbuf       result_list = NULL;

   if (pWrongAttrib) *pWrongAttrib = NULL;
   
   if (!pConn) { GS_ERR_COD = eGSInvalidArg; return GS_BAD; }

   // per ogni attributo se non ha valore di default assegno il valore di default
   // relativo al tipo dell'attributo
   p_attrib = (C_ATTRIB*) get_head();
   while (p_attrib)
   {
      if (!p_attrib->def) // non ha valore di default
         if (pConn->get_DefValue(p_attrib->type, &(p_attrib->def)) == GS_BAD)
         {
            if (pWrongAttrib) *pWrongAttrib = p_attrib;
            return GS_BAD;
         }

      p_attrib = (C_ATTRIB*) get_next();
   }
                    
   // struttura di default
   if (gsc_getdefaultattr(pConn, category, type, &result_list) == GS_BAD)
      return GS_BAD;
   if (result_list == NULL) return GS_GOOD;
   // aggiungo una "(" e ")" a result_list
   if (def_attrib_list.from_rb(gsc_lspforrb(&result_list)) == GS_BAD)
      { acutRelRb(result_list); return GS_BAD; }
   acutRelRb(result_list);

   // sostituisco il nome dell'attributo chiave di default
   p_attrib_def = (C_ATTRIB *) def_attrib_list.search_name(DEFAULT_KEY_ATTR, FALSE);
   p_attrib_def->name = key_attrib;
      
   p_attrib_def = (C_ATTRIB*) def_attrib_list.get_head();
   while (p_attrib_def != NULL)
   {
      // se è possibile cambiare il nome non ho riferimenti
      // (il riferimento di una colonna in sql è dato dal suo nome)
      // verifico flag di modificabilità
      if (gsc_check_mod_attr(p_attrib_def->mod_attr, BIT_MOD_NAME) == GS_BAD)
      {
         // cerco attributo nella lista degli attributi della classe
         if ((p_attrib = (C_ATTRIB *) search_name(p_attrib_def->get_name(), FALSE)) == NULL)
            { GS_ERR_COD = eGSInvalidDef_attrib; return GS_BAD; }

         // forzo il flag di modificabilità per gli attributi di default
         // più quelli impostati dall'utente
         p_attrib->mod_attr = p_attrib->mod_attr | p_attrib_def->mod_attr;
         
         // se si vuole modificare l'etichetta dell'attributo e non è permesso
         if ((p_attrib_def->Caption.len() > 0 || p_attrib->Caption.len() > 0) &&
             p_attrib_def->Caption.comp(p_attrib->Caption) != 0 && 
             gsc_check_mod_attr(p_attrib->mod_attr, BIT_MOD_CAPTION) == GS_BAD)
         {
            if (pWrongAttrib) *pWrongAttrib = p_attrib;
            GS_ERR_COD = eGSInvAttribCaption;
            return GS_BAD;
         }

         // se si vuole modificare il tipo dell'attributo e non è permesso
         if (gsc_strcmp(p_attrib_def->type, p_attrib->type) != 0 && 
             gsc_check_mod_attr(p_attrib->mod_attr, BIT_MOD_TYPE) == GS_BAD)
         {
            if (pWrongAttrib) *pWrongAttrib = p_attrib;
            GS_ERR_COD = eGSInvalidDef_attrib;
            return GS_BAD;
         }

         // se si vuole modificare il len dell'attributo e non è permesso
         if (p_attrib_def->len != p_attrib->len &&
             gsc_check_mod_attr(p_attrib->mod_attr, BIT_MOD_LEN) == GS_BAD)
         {
            if (pWrongAttrib) *pWrongAttrib = p_attrib;
            GS_ERR_COD = eGSInvalidDef_attrib;
            return GS_BAD;
         }

         // se si vuole modificare il dec dell'attributo e non è permesso
         if (p_attrib_def->dec != p_attrib->dec && 
             (p_attrib_def->dec > 0 || p_attrib->dec > 0) && // -1 o 0 hanno lo stesso significato
             gsc_check_mod_attr(p_attrib->mod_attr, BIT_MOD_DEC) == GS_BAD)
         {
            if (pWrongAttrib) *pWrongAttrib = p_attrib;
            GS_ERR_COD = eGSInvalidDef_attrib;
            return GS_BAD;
         }

         // se si vuole modificare il vis dell'attributo e non è permesso
         if (p_attrib_def->vis != p_attrib->vis && 
             gsc_check_mod_attr(p_attrib->mod_attr, BIT_MOD_VIS) == GS_BAD)
         {
            if (pWrongAttrib) *pWrongAttrib = p_attrib;
            GS_ERR_COD = eGSInvalidDef_attrib;
            return GS_BAD;
         }

         // se si vuole modificare il vis in tooltip dell'attributo e non è permesso
         if (p_attrib_def->VisOnTooltip != p_attrib->VisOnTooltip && 
             gsc_check_mod_attr(p_attrib->mod_attr, BIT_MOD_VIS_ON_TOOLTIP) == GS_BAD)
         {
            if (pWrongAttrib) *pWrongAttrib = p_attrib;
            GS_ERR_COD = eGSInvalidDef_attrib;
            return GS_BAD;
         }

         // se si vuole modificare il man dell'attributo e non è permesso
         if (p_attrib_def->man != p_attrib->man &&
             gsc_check_mod_attr(p_attrib->mod_attr, BIT_MOD_MAND) == GS_BAD)
         {
            if (pWrongAttrib) *pWrongAttrib = p_attrib;
            GS_ERR_COD = eGSInvalidDef_attrib;
            return GS_BAD;
         }

         // se si vuole modificare il calc_file o calc_func dell'attributo e non è permesso
         if (((gsc_strcmp(p_attrib_def->calc_file, p_attrib->calc_file) != 0) ||
             (gsc_strcmp(p_attrib_def->calc_func, p_attrib->calc_func) != 0)) &&
             gsc_check_mod_attr(p_attrib->mod_attr, BIT_MOD_CALC) == GS_BAD)
         {
            if (pWrongAttrib) *pWrongAttrib = p_attrib;
            GS_ERR_COD = eGSInvalidDef_attrib;
            return GS_BAD;
         }

         // se si vuole modificare il valid_file o valid_func dell'attributo e non è permesso
         if (((gsc_strcmp(p_attrib_def->valid_file, p_attrib->valid_file) != 0) ||
             (gsc_strcmp(p_attrib_def->valid_func, p_attrib->valid_func) != 0)) &&
             gsc_check_mod_attr(p_attrib->mod_attr, BIT_MOD_VALID) == GS_BAD)
         {
            if (pWrongAttrib) *pWrongAttrib = p_attrib;
            GS_ERR_COD = eGSInvalidDef_attrib;
            return GS_BAD;
         }

         // se si vuole modificare il def dell'attributo e non è permesso
         if (gsc_equal(p_attrib_def->def, p_attrib->def) == GS_BAD &&
             gsc_check_mod_attr(p_attrib->mod_attr, BIT_MOD_DEF) == GS_BAD)
         {
            if (pWrongAttrib) *pWrongAttrib = p_attrib;
            GS_ERR_COD = eGSInvalidDef_attrib;
            return GS_BAD;
         }
         
         // se si vuole modificare la descrizione dell'attributo e non è permesso
         if ((p_attrib_def->Descr.len() > 0 || p_attrib->Descr.len() > 0) &&
             p_attrib_def->Descr.comp(p_attrib->Descr) != 0 && 
             gsc_check_mod_attr(p_attrib->mod_attr, BIT_MOD_DESCR) == GS_BAD)
         {
            if (pWrongAttrib) *pWrongAttrib = p_attrib;
            GS_ERR_COD = eGSInvalidDef_attrib;
            return GS_BAD;
         }
         
         // se si vuole modificare Messaggio di errore per validazione non rispettata
         // dell'attributo e non è permesso
         if ((p_attrib_def->ValidErrMsg.len() > 0 || p_attrib->ValidErrMsg.len() > 0) &&
             p_attrib_def->ValidErrMsg.comp(p_attrib->ValidErrMsg) != 0 && 
             gsc_check_mod_attr(p_attrib->mod_attr, BIT_MOD_VALIDATION_ERR_MSG) == GS_BAD)
         {
            if (pWrongAttrib) *pWrongAttrib = p_attrib;
            GS_ERR_COD = eGSInvalidDef_attrib;
            return GS_BAD;
         }

         // se si vuole modificare il prefisso grafico e non è permesso
         if ((p_attrib_def->GphPrefix.len() > 0 || p_attrib->GphPrefix.len() > 0) &&
             p_attrib_def->GphPrefix.comp(p_attrib->GphPrefix) != 0 && 
             gsc_check_mod_attr(p_attrib->mod_attr, BIT_MOD_GPH_PREFIX_SUFFIX) == GS_BAD)
         {
            if (pWrongAttrib) *pWrongAttrib = p_attrib;
            GS_ERR_COD = eGSInvalidDef_attrib;
            return GS_BAD;
         }

         // se si vuole modificare il suffisso grafico e non è permesso
         if ((p_attrib_def->GphSuffix.len() > 0 || p_attrib->GphSuffix.len() > 0) &&
             p_attrib_def->GphSuffix.comp(p_attrib->GphSuffix) != 0 && 
             gsc_check_mod_attr(p_attrib->mod_attr, BIT_MOD_GPH_PREFIX_SUFFIX) == GS_BAD)
         {
            if (pWrongAttrib) *pWrongAttrib = p_attrib;
            GS_ERR_COD = eGSInvalidDef_attrib;
            return GS_BAD;
         }

         // se si vuole modificare la maschera di input e non è permesso
         if ((p_attrib_def->InputMask.len() > 0 || p_attrib->InputMask.len() > 0) &&
             p_attrib_def->InputMask.comp(p_attrib->InputMask) != 0 && 
             gsc_check_mod_attr(p_attrib->mod_attr, BIT_MOD_INPUT_MASK) == GS_BAD)
         {
            if (pWrongAttrib) *pWrongAttrib = p_attrib;
            GS_ERR_COD = eGSInvalidDef_attrib;
            return GS_BAD;
         }
      }
      
      p_attrib_def = (C_ATTRIB*) def_attrib_list.get_next();
   }
                                            
   // verifico la visibilità degli attributi
   if (category == CAT_SIMPLEX && type == TYPE_TEXT)
   { // visibile solo 1 attributo
      int QtyVis = 0;

      p_attrib = (C_ATTRIB*) get_head();
      while (p_attrib != NULL)
      {
         if (p_attrib->is_visible() == GS_GOOD)
         {
            QtyVis++;
            if (QtyVis > 1)
               if (pWrongAttrib) *pWrongAttrib = p_attrib;
         }
         p_attrib = (C_ATTRIB*) get_next();
      }
      if (QtyVis == 0 || QtyVis > 1) 
         { GS_ERR_COD = eGSInvalidVis_attrib;  return GS_BAD; }
   }
   else // tabelle secondarie
   if (category == CAT_SECONDARY)
   { // nessun attributo può essere visibile o calcolato da grafica
      p_attrib = (C_ATTRIB*) get_head();
      while (p_attrib)
      {
         if (p_attrib->is_visible() == GS_GOOD)
         {
            if (pWrongAttrib) *pWrongAttrib = p_attrib;
            GS_ERR_COD = eGSInvalidVis_attrib;
            return GS_BAD;
         }
         if (p_attrib->is_from_graph() == GS_GOOD)
         {
            if (pWrongAttrib) *pWrongAttrib = p_attrib;
            GS_ERR_COD = eGSInvalidGraphCalc;
            return GS_BAD;
         }
         p_attrib = (C_ATTRIB*) get_next();
      }
   }
   else // classi gruppi e griglie
   if ((category == CAT_GROUP && type == TYPE_GROUP) ||
       (category == CAT_GRID && type == TYPE_GRID))
      // nessun attributo può essere visibile
      if (is_visible() == GS_GOOD)
         { GS_ERR_COD = eGSInvalidVis_attrib; return GS_BAD; }

   if (p_fas) // verifico che eventuali funzioni di calcolo grafico non collidano 
   {          // con i campi calcolati
      if (gsc_validgphcalc(&(p_fas->file_graph_calc), p_fas->fun_graph_calc, this) == GS_BAD)
         return GS_BAD;
   }

   return GS_GOOD;
}


/*********************************************************/
/*.doc (new 2) C_ATTRIB_LIST::get_StaticDefValues <internal> */
/*+
  Questa funzione restituisce una lista di resbuf così composta:
  ((<nome colonna><valore di default>) ... )
  Parametri:
  C_RB_LIST &ColValues;

  Ritorna GS_GOOD in caso di successo altrimenti GS_BAD.
-*/  
/*********************************************************/
int C_ATTRIB_LIST::get_StaticDefValues(C_RB_LIST &ColValues)
{
   C_ATTRIB *p_attrib;
   
   if ((ColValues << acutBuildList(RTLB, 0)) == NULL) return GS_BAD;
   
   p_attrib = (C_ATTRIB *) get_head();
   while (p_attrib)
   {
      if ((ColValues += acutBuildList(RTLB,
                                      RTSTR, (p_attrib->name.len() == 0) ? GS_EMPTYSTR : p_attrib->get_name(),
                                      0)) == NULL)
         return GS_BAD;

      if (p_attrib->def == NULL) // non c'è il valore di default
      {
         if ((ColValues += acutBuildList(RTNIL, 0)) == NULL) return GS_BAD;
      }
      else
         if ((ColValues += gsc_copybuf(p_attrib->def)) == NULL) return GS_BAD;

      if ((ColValues += acutBuildList(RTLE, 0)) == NULL) return GS_BAD;

      p_attrib = (C_ATTRIB *) get_next();
   }
   if ((ColValues += acutBuildList(RTLE, 0)) == NULL) return GS_BAD;

   return GS_GOOD;
}                  


/*********************************************************/
/*.doc (new 2) C_ATTRIB_LIST::set_default_values <internal> */
/*+
  Questa funzione setta i valori di default:
  ((<nome colonna><valore di default>) ... )
  Parametri:
  C_RB_LIST &ColValues;

  Ritorna GS_GOOD in caso di successo altrimenti GS_BAD.
-*/  
/*********************************************************/
int C_ATTRIB_LIST::set_default_values(C_RB_LIST &ColValues)
{
   C_ATTRIB *p_attrib;
   presbuf  pVal;
     
   p_attrib = (C_ATTRIB *) get_head();
   while (p_attrib)
   {
      if ((pVal = ColValues.CdrAssoc(p_attrib->get_name(), FALSE)))
         if (!p_attrib->def) // non c'è il valore di default
         {
            if ((p_attrib->def = gsc_copybuf(pVal)) == NULL) return GS_BAD;
         }
         else
         {
            if (gsc_RbSubst(p_attrib->def, pVal) == NULL) return GS_BAD;
         }

      p_attrib = (C_ATTRIB *) get_next();
   }

   return GS_GOOD;
}                  


/************************************************************/
/*.doc C_ATTRIB_LIST::CheckValues(C_ATTRIB_LIST listVal)    */
/*+
  Questa funzione controlla la correttezza di una lista di resbuf
  verificando lunghezza, decimali, tipo, obbligatorietà.
  La lista viene modificata inserendo i valori corretti.
  Parametri:
  presbuf  listVal;        Lista valori da controllare.
  C_ATTRIB **pWrongAttrib; Attributo errato (default = NULL)
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
  N.B.: Deve essere già stata chiamata la "C_ATTRIB_LIST::init_ADOType"
-*/  
/************************************************************/
int C_ATTRIB_LIST::CheckValues(C_RB_LIST &ColValues, C_ATTRIB **pWrongAttrib)
{
   C_ATTRIB *punt;
   presbuf  p;

   if (pWrongAttrib) *pWrongAttrib = NULL;

   punt = (C_ATTRIB*) get_head();
   while (punt)
   {
      if ((p = ColValues.CdrAssoc(punt->get_name())) != NULL)
         if (punt->CheckValue(p) == GS_BAD)
            { if (pWrongAttrib) *pWrongAttrib = punt; return GS_BAD; }

      punt = (C_ATTRIB*)punt->get_next();   
   }

   return GS_GOOD;
}



/*********************************************************/
/*.doc (new 2) C_ATTRIB_LIST::TestCalc <internal> */
/*+
  Questa funzione testa tutte le funzioni di calcolo degli
  attributi valutandone la correttezza.
  Parametri:
  C_RB_LIST &ColValues;   Lista resbuf ((nomecampo - valore) ...)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
  N.B.: Gli attributi calcolati da grafica NON vengono ricalcolati ma devono
        già essere inizializzati !
-*/  
/*********************************************************/
int C_ATTRIB_LIST::TestAllCalc(C_RB_LIST &ColValues)
{
   C_ATTRIB      *pAttrib;
   C_INT_VOIDPTR *pCalcOrderAttribPtr = (C_INT_VOIDPTR *) CalcOrderAttribPtrList.get_head();

   while (pCalcOrderAttribPtr)
   {
      pAttrib = (C_ATTRIB *) pCalcOrderAttribPtr->get_VoidPtr();
      if (calc(pAttrib->get_name(), ColValues, INSERT) == GS_BAD) return GS_BAD;

      pCalcOrderAttribPtr = (C_INT_VOIDPTR *) pCalcOrderAttribPtr->get_next();   
   }

   return GS_GOOD;   
}


/*********************************************************/
/*.doc (new 2) C_ATTRIB_LIST::TestAllValid    <internal> */
/*+
  Questa funzione testa tutte le funzioni di validità scartando gli attributi
  calcolati e gli attributi calcolati da un attributo il cui valore
  è calcolato da grafica, valutandone la correttezza.
  Parametri:
  C_RB_LIST &ColValues;   Lista resbuf ((nomecampo - valore) ...)
  C_ATTRIB **pWrongAttrib; Attributo errato (default = NULL)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_ATTRIB_LIST::TestAllValid(C_RB_LIST &ColValues, C_ATTRIB **pWrongAttrib)
{
   C_ATTRIB *p_attrib, *p_attrib2;
   presbuf  PRBAttr;
   short    IsCalcFromAttrFromGraph;

   if (pWrongAttrib) *pWrongAttrib = NULL;

   p_attrib = (C_ATTRIB *) get_head();
   while (p_attrib)
   {  // se l'attributo non è calcolato ed è sottoposto a validità
      if (p_attrib->is_calculated() == GS_BAD && p_attrib->is_DefCalculated() == GS_BAD &&
          p_attrib->is_validated() == GS_GOOD)
      {        
         p_attrib2 = (C_ATTRIB *) get_head();
         IsCalcFromAttrFromGraph = FALSE;
         while (p_attrib2) // ciclo su tutti gli attributi calcolati da grafica
         {
            if (p_attrib2->is_from_graph() == GS_GOOD)
            {
               if (gsc_is_param(p_attrib->calc_file, p_attrib->calc_func, p_attrib2->get_name()) == GS_GOOD)
                  { IsCalcFromAttrFromGraph = TRUE; break; }
            }
            p_attrib2 = (C_ATTRIB *) p_attrib2->get_next();
         }
         // se è calcolato da un attributo calcolato da grafica lo salto
         if (IsCalcFromAttrFromGraph)
         {
            p_attrib = (C_ATTRIB *) p_attrib->get_next();
            continue;
         }

      	if ((PRBAttr = ColValues.CdrAssoc(p_attrib->get_name())) == NULL)
         {
            if (pWrongAttrib) *pWrongAttrib = p_attrib;
            GS_ERR_COD = eGSInvRBType;
            return GS_BAD;
         }

	      // Obbligatorietà
	      if (p_attrib->is_mandatory() == GS_GOOD)
	      {
            if (p_attrib->ADOType == adEmpty)
            {
               if (pWrongAttrib) *pWrongAttrib = p_attrib;
               GS_ERR_COD = eGSInvalidArg;
               return GS_BAD;
            }

            // controllo da fare solo su attributi che non sono boolean
            if (p_attrib->ADOType != adBoolean)
               switch (PRBAttr->restype)
	            {
	               case RTNONE: case RTVOID: case RTNIL:
                  {
                     if (pWrongAttrib) *pWrongAttrib = p_attrib;
                     GS_ERR_COD = eGSObbligFound;
                     return GS_BAD;
                  }
	               case RTSTR :
	                  if (!PRBAttr->resval.rstring ||
	                      wcslen(PRBAttr->resval.rstring) == 0)
	                  {
                        if (pWrongAttrib) *pWrongAttrib = p_attrib;
                        GS_ERR_COD = eGSObbligFound;
                        return GS_BAD;
                     }
	                  break;
	            }  
	      }
	      // Verifico le validità degli attributi che usano p_attrib come parametro
         if (validate(p_attrib->get_name(), ColValues, pWrongAttrib) != GS_GOOD)
	         return GS_BAD;
		}

      p_attrib = (C_ATTRIB *) p_attrib->get_next();
   }

   return GS_GOOD;
}


/*********************************************************/
/*.doc C_ATTRIB_LIST::Convert2ProviderType    <internal> */
/*+
  Questa funzione converte i tipi e le dimensioni degli attributi
  con quelli compatibili ad un'altra connessione OLE-DB.
  Parametri:
  C_DBCONNECTION *pSrc;    Connessione OLE-DB Sorgente
  C_DBCONNECTION *pDest;   Connessione OLE-DB Destinazione

  Restituisce GS_GOOD in caso di successo, GS_CAN se conversione impossibile
  GS_BAD per altri errori.
-*/  
/*********************************************************/
int C_ATTRIB_LIST::Convert2ProviderType(C_DBCONNECTION *pSrc, C_DBCONNECTION *pDest)
{
   int      Res;
   C_ATTRIB *pAttrib = (C_ATTRIB *) get_head();

   while (pAttrib)
   {
      if ((Res = pAttrib->Convert2ProviderType(pSrc, pDest)) != GS_GOOD) return Res;
      pAttrib = (C_ATTRIB *) pAttrib->get_next();   
   }

   return GS_GOOD;
}


/*********************************************************/
/*.doc C_ATTRIB_LIST::init_ADOType           <internal> */
/*+
  Questa funzione inizializza il tipo di dato ADO per ogni attributo.
  Parametri:
  C_DBCONNECTION *pConn;    Connessione OLE-DB

  Restituisce GS_GOOD in caso di successo altrimenti GS_BAD.
-*/  
/*********************************************************/
int C_ATTRIB_LIST::init_ADOType(C_DBCONNECTION *pConn)
{
   int      Res;
   C_ATTRIB *pAttrib = (C_ATTRIB *) get_head();

   while (pAttrib)
   {
      if ((Res = pAttrib->init_ADOType(pConn)) != GS_GOOD) return Res;
      pAttrib = (C_ATTRIB *) pAttrib->get_next();   
   }

   return GS_GOOD;
}
int C_ATTRIB_LIST::init_TempADOType(C_DBCONNECTION *pOldConn, C_DBCONNECTION *pTempConn)
{
   int      Res;
   C_ATTRIB *pAttrib = (C_ATTRIB *) get_head();

   while (pAttrib)
   {
      if ((Res = pAttrib->init_TempADOType(pOldConn, pTempConn)) != GS_GOOD) return Res;
      pAttrib = (C_ATTRIB *) pAttrib->get_next();   
   }

   return GS_GOOD;
}


/*********************************************************/
/*.doc C_ATTRIB_LIST::FilterOnNumericType     <external> */
/*+
  Questa funzione filtra la lista degli attributi lasciando solo quelli
  di tipo numerico. Prima di questa funzione deve essere chiamata la
  funzione "init_ADOType"
  Parametri:

  Restituisce GS_GOOD in caso di successo altrimenti GS_BAD.
-*/  
/*********************************************************/
int C_ATTRIB_LIST::FilterOnNumericType(void)
{
   C_ATTRIB *pAttrib = (C_ATTRIB *) get_head();

   while (pAttrib)
      if (gsc_DBIsNumeric(pAttrib->ADOType) == GS_GOOD)
         pAttrib = (C_ATTRIB *) get_next();
      else
      {
         remove_at();
         pAttrib = (C_ATTRIB *) get_cursor();
      }

   return GS_GOOD;
}


/*********************************************************/
/*.doc C_ATTRIB_LIST::FilterOnCharType        <external> */
/*+
  Questa funzione filtra la lista degli attributi lasciando solo quelli
  di tipo carattere. Prima di questa funzione deve essere chiamata la
  funzione "init_ADOType"
  Parametri:

  Restituisce GS_GOOD in caso di successo altrimenti GS_BAD.
-*/  
/*********************************************************/
int C_ATTRIB_LIST::FilterOnCharType(void)
{
   C_ATTRIB *pAttrib = (C_ATTRIB *) get_head();

   while (pAttrib)
      if (gsc_DBIsChar(pAttrib->ADOType) == GS_GOOD)
         pAttrib = (C_ATTRIB *) get_next();
      else
      {
         remove_at();
         pAttrib = (C_ATTRIB *) get_cursor();
      }

   return GS_GOOD;
}


/*********************************************************/
/*.doc C_ATTRIB_LIST::ParseToString                      */
/*+
  Questa funzione scrive le caption e i valori degli attributi in
  una stringa formattata.
  Se si è in sessione di lavoro, verranno letti anche entuali liste di valori
  attributi REF e TAB. in caso positivo i valori verranno formattati leggendo
  la corrispondente descrizione:
  Parametri:
  C_RB_LIST &ColValues; Lista resbuf ((nomecampo - valore) ...)
  C_STRING &Out;        Stringa in uscita
  bool ToolTipFmt;      Fomattazione per tooltip (default = FALSE)
  int cls;              Codice classe (per risovere i riferimenti a TAB e REF), default = 0 (non usato)
  int sub;              Codice sottoclasse (per risovere i riferimenti a TAB e REF), default = 0 (non usato)
  int sec;              Codice tab. secondaria (per risovere i riferimenti a TAB e REF), default = 0 (non usato)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_ATTRIB_LIST::ParseToString(C_RB_LIST &ColValues, C_STRING &Out, bool ToolTipFmt,
                                 int cls, int sub, int sec)
{
   C_ATTRIB *pAttrib = (C_ATTRIB *) get_head();
   size_t   LenStr, MaxLenAttribName = 0;
   C_STRING Str, FldVal;
   presbuf  p_rb;

   // Se si tratta di formattare per tooltip
   if (ToolTipFmt)
   {
      Out = _T("<PropertyCollection>");

      while (pAttrib)
      {
         // Verifico visibilità
         if (pAttrib->VisOnTooltip == GS_GOOD)
         {
            Out += _T("<Property Name=\"");
            Str = pAttrib->Caption;
            Str.toAXML();
            Out += Str;
            Out += _T("\" Value=\"");

            if ((p_rb = ColValues.CdrAssoc(pAttrib->get_name())) != NULL)
               if (pAttrib->ParseToString(p_rb, Str, &ColValues, cls, sub, sec) == GS_GOOD)
               {
                  Str.alltrim();
                  Str.toAXML();
                  Out += Str;
               }
  
            Out += _T("\" />"); 
         }
         pAttrib = (C_ATTRIB *) pAttrib->get_next();
      }

      Out += _T("</PropertyCollection>");
      return GS_GOOD;
   }

   // Se NON si tratta di formattare per tooltip
   // Calcolo la lunghezza max delle caption degli attributi
   while (pAttrib)
   {
      LenStr = pAttrib->Caption.len();
      if (MaxLenAttribName < LenStr) MaxLenAttribName = LenStr;
      pAttrib = (C_ATTRIB *) pAttrib->get_next();
   }

   Out.clear();
   pAttrib = (C_ATTRIB *) get_head();
   while (pAttrib)
   {
      FldVal = pAttrib->Caption;
      for (size_t i = pAttrib->Caption.len(); i < MaxLenAttribName; i++) 
         FldVal += _T(" ");

      FldVal += _T(": ");

      if ((p_rb = ColValues.CdrAssoc(pAttrib->get_name())) != NULL)
         if (pAttrib->ParseToString(p_rb, Str, &ColValues, cls, sub, sec) == GS_GOOD)
         {
            Str.alltrim();
            FldVal += Str;
         }
  
      Out += FldVal;
      if ((pAttrib = (C_ATTRIB *) pAttrib->get_next()) != NULL)
         { Out += (char) 13; Out += (char) 10; }
   }

   return GS_GOOD;
}


/**************************************************************/
/*.doc CopySupportFiles                                       */
/*+
   Funzione che copia i files di supporto per lista di valori degli 
   attributi per renderli disponibili per una altra classe 
   (o sottoclasse o tabella secondaria).
   Parametri:
   int SrcPrj;             Codice progetto sorgente
   int SrcCls;             Codice classe sorgente
   int SrcSub;             Codice sottoclasse sorgente
   int SrcSec;             Codice tabella secondaria sorgente
   int DstPrj;             Codice progetto destinazione
   int DstCls;             Codice classe destinazione
   int DstSub;             Codice sottoclasse destinazione
   int DstSec;             Codice tabella secondaria destinazione

   Ritorna GS_GOOD in caso di successo altrimenti GS_BAD.
-*/                                             
/**************************************************************/
int C_ATTRIB_LIST::CopySupportFiles(int SrcPrj, int SrcCls, int SrcSub, int SrcSec,
                                    int DstPrj, int DstCls, int DstSub, int DstSec)
{
   C_ATTRIB *pAttrib = (C_ATTRIB *) get_head();

   while (pAttrib)
   {
      // Copio quello che riesco e non mi fermo in caso di errore
      gsc_CopySupportFile(pAttrib->get_name(), SrcPrj, SrcCls, SrcSub, SrcSec,
                          DstPrj, DstCls, DstSub, DstSec);

      pAttrib = (C_ATTRIB *) get_next();
   }

   return GS_GOOD;
}


/**************************************************************/
/*.doc C_ATTRIB_LIST::DelSupportFiles                         */
/*+
   Funzione che cancella i files di supporto per lista di valori degli 
   attributi di una classe (o sottoclasse o tabella secondaria).
   Parametri:
   int Prj;                Codice progetto
   int Cls;                Codice classe
   int Sub;                Codice sottoclasse
   int Sec;                Codice tabella secondaria

   Ritorna GS_GOOD in caso di successo altrimenti GS_BAD.
-*/                                             
/**************************************************************/
int C_ATTRIB_LIST::DelSupportFiles(int Prj, int Cls, int Sub, int Sec)
{
   C_ATTRIB *pAttrib = (C_ATTRIB *) get_head();

   while (pAttrib)
   {
      // Copio quello che riesco e non mi fermo in caso di errore
      gsc_DelSupportFile(pAttrib->get_name(), Prj, Cls, Sub, Sec);

      pAttrib = (C_ATTRIB *) get_next();
   }

   return GS_GOOD;
}


/**************************************************************/
/*.doc C_ATTRIB_LIST::InitCalcOrderPos                        */
/*+
   Funzione che inizializza l'ordine di calcolo degli attributi
   (CalcOrderPos di C_ATTRIB).
   I primi saranno quelli calcolati dalla grafica, poi quelli con una 
   funzione di calcolo semplice, poi quelli calcolati da calcolati e così via.

   Ritorna GS_GOOD in caso di successo altrimenti GS_BAD.
-*/                                             
/**************************************************************/
int C_ATTRIB_LIST::InitCalcOrderPos(void)
{
   C_ATTRIB   *pAttrib, *pAttribCalcFrom;
   short      i = 0;
   bool       AllDependenciesInitialized;
   C_STR_LIST InitializedAttribList; // lista degli attributi che non hanno dipendenze irrisolte
   C_STR      *pInitializedAttrib;

   CalcOrderAttribPtrList.remove_all();

   // Setto CalcOrderPos = 0 per gli attributi non calcolati
   pAttrib = (C_ATTRIB *) get_head();
   while (pAttrib)
   {
      // se non è calcolato (valore o default) 
      if (pAttrib->is_calculated() == GS_BAD && pAttrib->is_DefCalculated() == GS_BAD)
         InitializedAttribList.add_tail_str(pAttrib->get_name());

      pAttrib = (C_ATTRIB *) pAttrib->get_next();
   }

   do
   {
      // Setto CalcOrderPos per gli attributi calcolati che dipendono da valori 
      // già inizializzati (i valori da grafica si intendono già inizializzati)
      pAttrib = (C_ATTRIB *) get_head();
      while (pAttrib)
      {
         // Se già inizializzato lo salto
         if (InitializedAttribList.search_name(pAttrib->get_name()))
            { pAttrib = (C_ATTRIB *) pAttrib->get_next(); continue; }

         AllDependenciesInitialized = true;
         pAttribCalcFrom = (C_ATTRIB *) get_head();
         while (pAttribCalcFrom)
         {
            if (pAttrib != pAttribCalcFrom) // salto lo stesso attributo
               if (gsc_is_param(pAttrib->calc_file, pAttrib->calc_func, pAttribCalcFrom->get_name()) == GS_GOOD)
                  if (InitializedAttribList.search_name(pAttribCalcFrom->get_name()) == NULL) // se non è già inizializzato
                     { AllDependenciesInitialized = false; break; }

            pAttribCalcFrom = (C_ATTRIB *) pAttribCalcFrom->get_next();
         }

         if (AllDependenciesInitialized)
            InitializedAttribList.add_tail_str(pAttrib->get_name());

         pAttrib = (C_ATTRIB *) pAttrib->get_next();
      }

      // verifico se tutti gli attributi sono inizializzati
      AllDependenciesInitialized = true;
      pAttrib = (C_ATTRIB *) get_head();
      while (pAttrib)
      {
         if (InitializedAttribList.search_name(pAttrib->get_name()) == NULL) // se non è già inizializzato
            { AllDependenciesInitialized = false; break; }

         pAttrib = (C_ATTRIB *) pAttrib->get_next();
      }

      if (!AllDependenciesInitialized) i++;
   }
   while (!AllDependenciesInitialized && i < 10); // provo al max 10 volte a fare questi controlli

   // se ancora ci sono attributi non inizializzati vuole dire che c'è 
   // un calcolo ciclico (es. A=B e B=A)
   if (!AllDependenciesInitialized)
   {
      GS_ERR_COD = eGSInvalidCalcOfCalc;
      return GS_BAD;
   }

   // compilo la lista ordinata dei puntatori gli attributi calcolati
   i = 0;
   pInitializedAttrib = (C_STR *) InitializedAttribList.get_head();
   while (pInitializedAttrib)
   {
      pAttrib = (C_ATTRIB *) search_name(pInitializedAttrib->get_name());
      // se è calcolato (valore o default) 
      if (pAttrib->is_calculated() == GS_GOOD || pAttrib->is_DefCalculated() == GS_GOOD)
         CalcOrderAttribPtrList.add_tail_int_voidptr(++i, pAttrib);

      pInitializedAttrib = (C_STR *) pInitializedAttrib->get_next();
   }

   return GS_GOOD;
}


/*********************************************************/
/*.doc C_ATTRIB_LIST::GetTxtFileAttribFormats <external> */
/*+
  Questa funzione prepara i formati testo per l'import\export dei dati in file txt. 
  Parametri:
  int modo;            Modo di esportazione dati:
                       DELIMITED  colonne delimitate con <delimiter>; '\n' a 
                                  fine riga
                       SDF        colonne spaziate per le loro dimensioni 
                                  (senza intestazione <nomi colonne>) '\n' a 
                                  fine riga
                       SDF_HEADER colonne spaziate per le loro dimensioni e per
                                  le dimensioni delle intestazioni (prima riga
                                  intestazione <nomi colonne>); '\n' a fine 
                                  riga (fra una colonna e l'altra ' ')
  TCHAR *delimiter;    Stringa delimitatrice di fine colonna
  C_STR_LIST &Formats; Lista dei formati
  
  Restituisce i formati in caso di successo altrimenti NULL.
  N.B. la funzione NON tratta campi MEMO o di tipi incompabili a TXT
-*/  
/*********************************************************/
int C_ATTRIB_LIST::GetTxtFileAttribFormats(int modo, TCHAR *delimiter, C_STR_LIST &Formats)
{
   C_ATTRIB   *pAttrib;
   C_STR     *pFormat;
   TCHAR     Buffer[32];     // Formato colonna 

   Formats.remove_all();

   pAttrib = (C_ATTRIB *) get_head();
   while (pAttrib)
   {
      Buffer[0] = _T('\0');
      if (gsc_DBIsNumeric(pAttrib->ADOType) == GS_GOOD)
      {
         switch (modo)     // testo giustificato a destra
         {
            case DELIMITED:  // con delimitatore
               if (pAttrib->get_next() == NULL) // ultimo campo quindi elimino delimitatore per ultima colonna
                  swprintf(Buffer, 32, _T("%%s"));
               else
                  swprintf(Buffer, 32, _T("%%s%s"), delimiter);
               break;
            case SDF:        // SDF semplice
               swprintf(Buffer, 32, _T("%%%ds"), pAttrib->len);
               break;
            case SDF_HEADER: // SDF con intestazione
               swprintf(Buffer, 32, _T("%%%ds"), max((int)pAttrib->name.len(), pAttrib->len));
               break;
         }
      }
      else
      if (gsc_DBIsDate(pAttrib->ADOType) == GS_GOOD ||
          gsc_DBIsTimestamp(pAttrib->ADOType) == GS_GOOD)
      {
         switch (modo)     // testo giustificato a destra
         {
            case DELIMITED:  // con delimitatore
               if (pAttrib->get_next() == NULL) // ultimo campo quindi elimino delimitatore per ultima colonna
                  swprintf(Buffer, 32, _T("%%s"));
               else
                  swprintf(Buffer, 32, _T("%%s%s"), delimiter);
               break;
            case SDF:        // SDF semplice
               swprintf(Buffer, 32, _T("%%-%ds"), 30); // 30 per data estesa
               break;
            case SDF_HEADER: // SDF con intestazione
               swprintf(Buffer, 32, _T("%%-%ds"), max(pAttrib->name.len(), 30)); // 30 per data estesa
               break;
         }
      }
      else
      if (gsc_DBIsTime(pAttrib->ADOType) == GS_GOOD)
      {
         switch (modo)     // testo giustificato a destra
         {
            case DELIMITED:  // con delimitatore
               if (pAttrib->get_next() == NULL) // ultimo campo quindi elimino delimitatore per ultima colonna
                  swprintf(Buffer, 32, _T("%%s"));
               else
                  swprintf(Buffer, 32, _T("%%s%s"), delimiter);
               break;
            case SDF:        // SDF semplice
               swprintf(Buffer, 32, _T("%%-%ds"), 8); // 8 per ora (hh:mm:ss)
               break;
            case SDF_HEADER: // SDF con intestazione
               swprintf(Buffer, 32, _T("%%-%ds"), max(pAttrib->name.len(), 8)); // 8 per ora (hh:mm:ss)
               break;
         }
      }
      else
      {
         switch (modo)     // testo giustificato a sinistra
         {
            case DELIMITED:  // con delimitatore
               if (pAttrib->get_next() == NULL) // ultimo campo quindi elimino delimitatore per ultima colonna
                  swprintf(Buffer, 32, _T("\"%%s\""));
               else
                  swprintf(Buffer, 32, _T("\"%%s\"%s"), delimiter);
               break;
            case SDF:        // SDF semplice
               swprintf(Buffer, 32, _T("%%-%ds"), pAttrib->len);
               break;
            case SDF_HEADER: // SDF con intestazione
               swprintf(Buffer, 32, _T("%%-%ds"), max((int)pAttrib->name.len(), pAttrib->len));
               break;
         }
      }

      if ((pFormat = new C_STR(Buffer)) == NULL)
         { GS_ERR_COD = eGSOutOfMem; return GS_BAD; }

      Formats.add_tail(pFormat);
      pAttrib = (C_ATTRIB *) pAttrib->get_next();
   }
   
   return GS_GOOD;
}


/*********************************************************/
/*.doc C_ATTRIB_LIST::sprintfHeader           <external> */
/*+
  Questa funzione stampa l'intestazione di una tabella in modo formattato. 
  Parametri:
  FILE *fhandle;       Handle del file in cui scrivere
  C_STR_LIST &Formats; Lista dei formati
  
  Restituisce GS_GOOD in caso di successo altrimenti GS_BAD.
-*/  
/*********************************************************/
int C_ATTRIB_LIST::sprintfHeader(FILE *fhandle, C_STR_LIST &Formats)
{
   C_STR    *pFormat;
   C_ATTRIB *pAttrib;

   pFormat = (C_STR *) Formats.get_head();
   pAttrib = (C_ATTRIB *) get_head();
   while (pFormat && pAttrib)
   {
      if (pFormat->len() > 0)
         if (fwprintf(fhandle, pFormat->get_name(), pAttrib->get_name()) < 0)
            { GS_ERR_COD = eGSWriteFile; return GS_BAD; }
      pFormat = (C_STR *) Formats.get_next();
      pAttrib = (C_ATTRIB *) get_next();
   }

   if (fwprintf(fhandle, GS_LFSTR) < 0)
      { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

   return GS_GOOD;
}






//-----------------------------------------------------------------------//
//////////////////  C_ATTRIB_LIST  FINE    ////////////////////////////////
//////////////////  C_ATTRIB   INIZIO      ////////////////////////////////
//-----------------------------------------------------------------------//


C_ATTRIB::C_ATTRIB() : C_NODE() 
{
   type[0]      = _T('\0');
   len          = dec = mod_attr = 0;
   vis          = man = GS_BAD;
   VisOnTooltip = GS_GOOD;
   calc_file    = calc_func = valid_file = valid_func = NULL;
   IsDefCalc    = GS_BAD;
   def          = NULL;
   ADOType      = TempADOType = adEmpty;
   OrderPos     = 0;
} 


/*********************************************************/
/*.doc C_ATTRIB::C_ATTRIB                     <internal> */
/*+
  Costruttore  parametrizzato.
  Parametri:
  C_STRING &_name;         name
  int OrderPos;
  C_STRING &_Caption;      caption
  TCHAR *_type;            type
  int _len;                len
  int _dec;                dec
  int _vis;                visibility
  int _VisOnTooltip;       visibilità nella tooltip dell'interrogazione dinamica
  int _man;                mandatory
  TCHAR *_calc_file;       calculation file
  TCHAR *_calc_func;       calculation function
  int _IsDefCalc;          Flag che indica se la funzione di calcolo
                           è riferita al valore di default
  TCHAR *_valid_file;      validation file    
  TCHAR *_valid_func;      validation function
  C_STRING &_ValidErrMsg;  Messaggio di errore per validazione
  resbuf *_def;            default value
  int _mod_attr;           management flag
  C_STRING &_Descr;        Descizione
  C_STRING &_GphPrefix;    Prefisso grafico
  C_STRING &_GphSuffix;    Suffisso grafico
  C_STRING &_InputMask;    Maschera per input dati
-*/  
/*********************************************************/
C_ATTRIB::C_ATTRIB(C_STRING &_name, int _OrderPos, C_STRING &_Caption, TCHAR *_type,
                   long _len, int _dec, int _vis, int _VisOnTooltip, int _man,
                   TCHAR *_calc_file, TCHAR *_calc_func, int _IsDefCalc, 
                   TCHAR *_valid_file, TCHAR *_valid_func, C_STRING &_ValidErrMsg,
                   resbuf *_def, int _mod_attr, C_STRING &_Descr,
                   C_STRING &_GphPrefix, C_STRING &_GphSuffix,
                   C_STRING &_InputMask) : C_NODE()
{
   calc_file   = calc_func = valid_file = valid_func = NULL;
   def         = NULL;
   ADOType     = adEmpty;
   TempADOType = adEmpty;
   
   set(_name, _OrderPos, _Caption, _type, _len, _dec, _vis, _VisOnTooltip, _man, 
       _calc_file, _calc_func, _IsDefCalc,
       _valid_file, _valid_func, _ValidErrMsg, _def, _mod_attr, _Descr,
       _GphPrefix, _GphSuffix, _InputMask);
}

C_ATTRIB::~C_ATTRIB()
{
  if (calc_file)  free(calc_file);
  if (calc_func)  free(calc_func);
  if (valid_file) free(valid_file);
  if (valid_func) free(valid_func);
  if (def)        acutRelRb(def);
} 


TCHAR *C_ATTRIB::get_name() { return name.get_name(); }


/*********************************************************/
/*.doc C_ATTRIB::ToFile                       <internal> */
/*+
  Questa funzione salva su file la struttura dell'attributo.
  Parametri:
  C_STRING &filename;   File in cui scrivere le informazioni
  const TCHAR *sez;     nome della sezione in cui scrivere
  int n_attrib;         numero ordinale dell'attributo

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_ATTRIB::ToFile(C_STRING &filename, const TCHAR *sez, int n_attrib)
{
   C_PROFILE_SECTION_BTREE ProfileSections;
   bool                    Unicode = false;

   if (gsc_path_exist(filename) == GS_GOOD)
      if (gsc_read_profile(filename, ProfileSections, &Unicode) == GS_BAD) return GS_BAD;

   if (ToFile(ProfileSections, sez, n_attrib) == GS_BAD) return GS_BAD;

   return gsc_write_profile(filename, ProfileSections, Unicode);
}
int C_ATTRIB::ToFile(C_PROFILE_SECTION_BTREE &ProfileSections, const TCHAR *sez, int n_attrib)
{
   C_BPROFILE_SECTION *ProfileSection;
   C_STRING entry, entryPrefix, Buffer;

   entryPrefix = n_attrib;
   entryPrefix += _T(".");

   if (!(ProfileSection = (C_BPROFILE_SECTION *) ProfileSections.search(sez)))
   {
      if (ProfileSections.add(sez) == GS_BAD) return GS_BAD;
      ProfileSection = (C_BPROFILE_SECTION *) ProfileSections.get_cursor();
   }

   // nome attributo
   entry = entryPrefix;
   entry += _T("ATTRIB");
   ProfileSection->set_entry(entry.get_name(), (name.len() == 0) ? GS_EMPTYSTR : name.get_name());

   // posizione dell'attributo nella lista
   entry = entryPrefix;
   entry += _T("ORDER_POS");
   ProfileSection->set_entry(entry.get_name(), OrderPos);

   // etichetta attributo
   entry = entryPrefix;
   entry += _T("CAPTION");
   ProfileSection->set_entry(entry.get_name(), (Caption.len() == 0) ? GS_EMPTYSTR : Caption.get_name());

   // tipo attributo
   entry = entryPrefix;
   entry += _T("TYPE");
   ProfileSection->set_entry(entry.get_name(), type);

   // lunghezza attributo
   entry = entryPrefix;
   entry += _T("LEN");
   ProfileSection->set_entry(entry.get_name(), len);

   // decimali attributo
   entry = entryPrefix;
   entry += _T("DECIM");
   ProfileSection->set_entry(entry.get_name(), dec);

   // visibilità attributo
   entry = entryPrefix;
   entry += _T("VISIBIL");
   ProfileSection->set_entry(entry.get_name(), vis);

   // visibilità attributo in tooltip
   entry = entryPrefix;
   entry += _T("VISIB_ON_TOOLTIP");
   ProfileSection->set_entry(entry.get_name(), VisOnTooltip);

   // obbligatorietà attributo
   entry = entryPrefix;
   entry += _T("MANDAT");
   ProfileSection->set_entry(entry.get_name(), man);

   // file contenente la funzione di calcolo
   if (calc_file != NULL)
   {  // converto path con alias host
      Buffer = calc_file;
      if (gsc_drive2nethost(Buffer) == GS_BAD) return GS_BAD;
   }
   else Buffer = GS_EMPTYSTR;

   entry = entryPrefix;
   entry += _T("FILE_CALC");
   ProfileSection->set_entry(entry.get_name(), Buffer.get_name());

   // Funzione di calcolo (che potrebbe contenere delle virgole)
   entry = entryPrefix;
   entry += _T("CALC_FUNC");
   ProfileSection->set_entry(entry.get_name(), (calc_func) ? calc_func : GS_EMPTYSTR);

   // Flag che indica se la funzione di calcolo
   // è riferita al valore di default
   entry = entryPrefix;
   entry += _T("IS_DEF_CALC");
   ProfileSection->set_entry(entry.get_name(), IsDefCalc);

   // File contenente la funzione di validità
   if (valid_file != NULL)
   {  // converto path con alias host
      Buffer = valid_file;
      if (gsc_drive2nethost(Buffer) == GS_BAD) return GS_BAD;
   }
   else Buffer = GS_EMPTYSTR;

   entry = entryPrefix;
   entry += _T("FILE_VALID");
   ProfileSection->set_entry(entry.get_name(), Buffer.get_name());

   // Funzione di validità (che potrebbe contenere delle virgole)
   entry = entryPrefix;
   entry += _T("VALID_FUNC");
   ProfileSection->set_entry(entry.get_name(), (valid_func) ? valid_func : GS_EMPTYSTR);
   
   // valore di default
   Buffer.clear();
   if (def != NULL) Buffer.paste(gsc_rb2str(def, len, dec));
   if (Buffer.get_name() == NULL) Buffer = GS_EMPTYSTR;

   entry = entryPrefix;
   entry += _T("DEFAULT_VALUE");
   ProfileSection->set_entry(entry.get_name(), Buffer.get_name());

   // Flag di modificabilità
   entry = entryPrefix;
   entry += _T("MOD_ATTR");
   ProfileSection->set_entry(entry.get_name(), mod_attr);

   // Messaggio di errore per validazione (che potrebbe contenere delle virgole)
   entry = entryPrefix;
   entry += _T("VALIDATION_ERR_MSG");
   ProfileSection->set_entry(entry.get_name(), (ValidErrMsg.len()) ? ValidErrMsg.get_name() : GS_EMPTYSTR);

   // Descrizione attributo (che potrebbe contenere delle virgole)
   entry = entryPrefix;
   entry += _T("DESCRIPTION");
   ProfileSection->set_entry(entry.get_name(), (Descr.len()) ? Descr.get_name() : GS_EMPTYSTR);

   // Prefisso grafico attributo (che potrebbe contenere delle virgole)
   entry = entryPrefix;
   entry += _T("GPH_PREFIX");
   ProfileSection->set_entry(entry.get_name(), (GphPrefix.len()) ? GphPrefix.get_name() : GS_EMPTYSTR);

   // Suffisso grafico attributo (che potrebbe contenere delle virgole)
   entry = entryPrefix;
   entry += _T("GPH_SUFFIX");
   ProfileSection->set_entry(entry.get_name(), (GphSuffix.len()) ? GphSuffix.get_name() : GS_EMPTYSTR);

   // Suffisso grafico attributo (che potrebbe contenere delle virgole)
   entry = entryPrefix;
   entry += _T("INPUT_MASK");
   ProfileSection->set_entry(entry.get_name(), (InputMask.len()) ? InputMask.get_name() : GS_EMPTYSTR);
  
   return GS_GOOD;
}


/*********************************************************/
/*.doc C_ATTRIB::load <internal> */
/*+
  Questa funzione legge da file la struttura dell'attributo scritto
  nel formato Provider dipendente.
  Parametri:
  C_PROFILE_SECTION_BTREE &ProfileSections; File di profilo letto in memoria
  const TCHAR *sez;         nome della sezione in cui scrivere
  C_DBCONNECTION *pConn;   Connessione OLE-DB
  int n_attrib;            numero ordinale dell'attributo

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_ATTRIB::load(C_PROFILE_SECTION_BTREE &ProfileSections, const TCHAR *sez, C_DBCONNECTION *pConn, int n_attrib)
{
   C_BPROFILE_SECTION *ProfileSection;
   C_2STR_BTREE       *pProfileEntries;
   C_B2STR            *pProfileEntry;

   C_STRING entry, entryPrefix, Buffer; 
   C_STRING m_name, m_Caption, m_type;
   C_STRING m_CalcFile, m_CalcFunc, m_ValidFile, m_ValidFunc, m_def;
   C_STRING m_Descr, m_ValidErrMsg, m_GphPrefix, m_GphSuffix, m_InputMask;
   int      m_OrderPos, m_dec, m_vis, m_visOnTooltip, m_mand, m_flag, m_IsDefCalc;
   long     m_len;
   presbuf  p_def = NULL;

   if (!(ProfileSection = (C_BPROFILE_SECTION *) ProfileSections.search(sez))) return GS_CAN;
   pProfileEntries = (C_2STR_BTREE *) ProfileSection->get_ptr_EntryList();

   entryPrefix = n_attrib;
   entryPrefix += _T(".");

   // nome attributo (obbligatorio)
   entry = entryPrefix;
   entry += _T("ATTRIB");
   if (!(pProfileEntry = (C_B2STR *) pProfileEntries->search(entry.get_name()))) return GS_CAN;
   m_name = pProfileEntry->get_name2();
   m_name.alltrim();

   // posizione dell'attributo nella lista
   entry = entryPrefix;
   entry += _T("ORDER_POS");
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(entry.get_name())))
      m_OrderPos = _wtoi(pProfileEntry->get_name2());
   else
      m_OrderPos = 0;

   // etichetta attributo
   entry = entryPrefix;
   entry += _T("CAPTION");
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(entry.get_name())))
   {
      m_Caption = pProfileEntry->get_name2();
      m_Caption.alltrim();
   }

   // tipo attributo (obbligatorio)
   entry = entryPrefix;
   entry += _T("TYPE");
   if (!(pProfileEntry = (C_B2STR *) pProfileEntries->search(entry.get_name()))) return GS_CAN;
   m_type = pProfileEntry->get_name2();

   // lunghezza attributo (obbligatorio)
   entry = entryPrefix;
   entry += _T("LEN");
   if (!(pProfileEntry = (C_B2STR *) pProfileEntries->search(entry.get_name()))) return GS_CAN;
   m_len = _wtol(pProfileEntry->get_name2());

   // decimali attributo
   entry = entryPrefix;
   entry += _T("DECIM");
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(entry.get_name())))
      m_dec = _wtoi(pProfileEntry->get_name2());
   else
      m_dec = 0;

   // visibilità attributo
   entry = entryPrefix;
   entry += _T("VISIBIL");
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(entry.get_name())))
      m_vis = _wtoi(pProfileEntry->get_name2());
   else
      m_vis = GS_BAD;

   // visibilità attributo in tooltip
   entry = entryPrefix;
   entry += _T("VISIB_ON_TOOLTIP");
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(entry.get_name())))
      m_visOnTooltip = _wtoi(pProfileEntry->get_name2());
   else
      m_visOnTooltip = GS_GOOD;

   // obbligatorietà attributo
   entry = entryPrefix;
   entry += _T("MANDAT");
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(entry.get_name())))
      m_mand = _wtoi(pProfileEntry->get_name2());
   else
      m_mand = GS_BAD;

   // file contenente la funzione di calcolo
   entry = entryPrefix;
   entry += _T("FILE_CALC");
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(entry.get_name())))
      m_CalcFile = pProfileEntry->get_name2();

   // Funzione di calcolo (che potrebbe contenere delle virgole)
   entry = entryPrefix;
   entry += _T("CALC_FUNC");
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(entry.get_name())))
      m_CalcFunc = pProfileEntry->get_name2();
   else // se non c'era la entry non è errore
      m_CalcFunc = GS_EMPTYSTR;

   // Flag che indica se la funzione di calcolo
   // è riferita al valore di default
   entry = entryPrefix;
   entry += _T("IS_DEF_CALC");
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(entry.get_name())))
      m_IsDefCalc = _wtoi(pProfileEntry->get_name2());
   else
      m_IsDefCalc = GS_BAD;

   // File contenente la funzione di validità
   entry = entryPrefix;
   entry += _T("FILE_VALID");
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(entry.get_name())))
      m_ValidFile = pProfileEntry->get_name2();

   // Funzione di validità (che potrebbe contenere delle virgole)
   entry = entryPrefix;
   entry += _T("VALID_FUNC");
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(entry.get_name())))
      m_ValidFunc = pProfileEntry->get_name2();
   else
      // se non c'era la entry non è errore
      m_ValidFunc = GS_EMPTYSTR;

   // valore di default
   entry = entryPrefix;
   entry += _T("DEFAULT_VALUE");
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(entry.get_name())))
      m_def = pProfileEntry->get_name2();
   // converto valore di default in resbuf
   if ((p_def = pConn->ptr_DataTypeList()->DataValueStr2Rb(m_type.get_name(), 
                                                           m_def.get_name())) == NULL)
      return GS_BAD;

   // Flag di modificabilità
   entry = entryPrefix;
   entry += _T("MOD_ATTR");
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(entry.get_name())))
      m_flag = _wtoi(pProfileEntry->get_name2());
   else
      m_flag = GS_BAD;

   // Messaggio di errore per validazione (che potrebbe contenere delle virgole)
   entry = entryPrefix;
   entry += _T("VALIDATION_ERR_MSG");
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(entry.get_name())))
      m_ValidErrMsg = pProfileEntry->get_name2();

   // Descrizione attributo (che potrebbe contenere delle virgole)
   entry = entryPrefix;
   entry += _T("DESCRIPTION");
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(entry.get_name())))
      m_Descr = pProfileEntry->get_name2();

   // Prefisso grafico attributo (che potrebbe contenere delle virgole)
   entry = entryPrefix;
   entry += _T("GPH_PREFIX");
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(entry.get_name())))
      m_GphPrefix = pProfileEntry->get_name2();

   // Suffisso grafico attributo (che potrebbe contenere delle virgole)
   entry = entryPrefix;
   entry += _T("GPH_SUFFIX");
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(entry.get_name())))
      m_GphSuffix = pProfileEntry->get_name2();

   // Suffisso grafico attributo (che potrebbe contenere delle virgole)
   entry = entryPrefix;
   entry += _T("INPUT_MASK");
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(entry.get_name())))
      m_InputMask = pProfileEntry->get_name2();

   if (set(m_name, m_OrderPos, m_Caption, m_type.get_name(), m_len, m_dec, 
           m_vis, m_visOnTooltip, m_mand,
           m_CalcFile.get_name(), m_CalcFunc.get_name(), m_IsDefCalc,
           m_ValidFile.get_name(), m_ValidFunc.get_name(), m_ValidErrMsg,
           p_def, m_flag, m_Descr,
           m_GphPrefix, m_GphSuffix, m_InputMask) == GS_BAD)
      { acutRelRb(p_def); return GS_BAD; }
   acutRelRb(p_def);
   
   return GS_GOOD;      
}


/*********************************************************/
/*.doc C_ATTRIB::is_valid <internal> */
/*+
  Questa funzione verifica se un attributo è valido.
  Controlla che esista il nome, che non sia una parola chiave SQL,
  che non contenga spazi, che non sia calcolato da sè stesso, che
  non possa avere contemporaneamente una funzione di calcolo ed una
  funzione di validità e che abbia un tipo di dato valido e che le sue dimensioni
  siano corrette. Nel caso in cui sia calcolato dalla grafica, 
  setta il valore di default appropriato.
  Parametri:
  C_DBCONNECTION *pConn;   Connessione OLE-DB
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
  N.B: converte i nomi e i tipi degli attributi in maiuscolo e può
       modificare il valore di default.
-*/  
/*********************************************************/
int C_ATTRIB::is_valid(C_DBCONNECTION *pConn)
{ 
   long     DBDim;
   int      DBDec;
   short    DBIsFixedPrecScale;
   C_STRING CreateParam;

   // NOME
   if (pConn->IsValidFieldName(name) == GS_BAD)
      { GS_ERR_COD = eGSInvAttribName; return GS_BAD; }

   // ETICHETTA
   if (Caption.len() == 0) Caption = name;

   // TIPO
   if (type == NULL || wcslen(type) == 0)
      { GS_ERR_COD = eGSUnkwnDrvFieldType; return GS_BAD; }
   gsc_alltrim(type);
   // Leggo caratteristiche tipo DataBase
   if (pConn->ProviderDescr2InfoType(type, NULL, &DBDim, &DBDec, NULL,
                                     &DBIsFixedPrecScale, NULL, &CreateParam) == GS_BAD)
      return GS_BAD;

   if (DBIsFixedPrecScale) // precisione e scala fisse
   {
      int nParam = (CreateParam.len() > 0) ? CreateParam.strtran(_T(","), _T(",")) + 1 : 0;

      switch (nParam)
      {
         case 0:
            if (pConn->IsNumeric(type) == GS_GOOD)
            {
               if (len > DBDim) { GS_ERR_COD = eGSInvAttribLen; return GS_BAD; }
               if (len <= 0) len = DBDim;

               // se è un numero reale verifico che i decimali siano corretti
               if (pConn->IsNumericWithDecimals(type) == GS_GOOD && dec > 0)
                  // considero almeno una cifra per le unità (il sep. decimale non conta)
                  if (dec >= len - 1) { GS_ERR_COD = eGSInvAttribDec; return GS_BAD; }

               if (dec < 0) dec = 0;
            }
            else
            {
               len = DBDim;
               dec = DBDec;
            }
            break;
         case 1:
            if (DBDim > 0) // esiste la dimensione
               if (len > DBDim) { GS_ERR_COD = eGSInvAttribLen; return GS_BAD; }

            // se è un numero reale
            if (pConn->IsNumericWithDecimals(type) == GS_GOOD)
            {
               if (dec > 0) // verifico che i decimali siano corretti
                  // considero almeno una cifra per le unità (il sep. decimale non conta)
                  if (dec >= len - 1) { GS_ERR_COD = eGSInvAttribDec; return GS_BAD; }

               if (dec < 0) dec = 0;
            }
            else
               dec = DBDec;
           break;
         case 2:
            if (DBDec > 0) // esistono i decimali
               if (dec > DBDec) { GS_ERR_COD = eGSInvAttribDec; return GS_BAD; }
            break;
      }
   }
   else
   {
      if (pConn->IsNumeric(type) == GS_GOOD)
      {
         if (len <= 0) len = DBDim;

         // se è un numero reale verifico che i decimali siano corretti
         if (pConn->IsNumericWithDecimals(type) == GS_GOOD && dec > 0)
            // considero almeno una cifra per le unità (il sep. decimale non conta)
            if (dec >= len - 1) { GS_ERR_COD = eGSInvAttribDec; return GS_BAD; }

         if (dec < 0) dec = 0;
      }
   }

   // un attributo non può essere calcolato da sè stesso
   if (is_calculated() == GS_GOOD || is_DefCalculated() == GS_GOOD) // è con calcolo (valore o default)
   {
      if (gsc_is_param(calc_file, calc_func, name.get_name()) == GS_GOOD)
         { GS_ERR_COD = eGSInvalidCalc; return GS_BAD; }
      // se si tratta di una funzione di calcolo da grafica
      // leggo il suo valore di default e lo sostituisco
      if (gsc_is_from_graph(calc_func) == GS_GOOD)
      {
         C_RB_LIST def_from_graph;
         
         def_from_graph << gsc_get_default_from_graph(calc_func);
         if (gsc_sostitutebuf(def_from_graph.get_head(), def) == GS_BAD) return GS_BAD;
      }
   }

   return GS_GOOD;
}         


/*********************************************************/
/*.doc C_ATTRIB::is_from_graph <internal> */
/*+
  Questa funzione verifica se un attributo deve essere
  aggiornato da grafica.
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_ATTRIB::is_from_graph() 
{
   return gsc_is_from_graph(calc_func);
}


/*********************************************************/
/*.doc (new 2) C_ATTRIB::set_charact <internal> */
/*+
  Questa funzione setta le caratteristiche di un attributo:
  visibilità, obbligatorietà, funzione di calcolo, funzione di validità,
  descrizione, prefisso e suffisso grafico, maschera di input.
  Parametri:
  int    _OrderPos;
  C_STRING &_Caption;
  int    _vis;
  int    _VisOnTooltip;
  int    _man;
  TCHAR  *_calc_file;
  TCHAR  *_calc_func;
  int    _IsDefCalc;
  TCHAR  *_valid_file;
  TCHAR  *_valid_func;
  C_STRING &_ValidErrMsg;
  C_STRING &_Descr;
  C_STRING &_GphPrefix;
  C_STRING &_GphSuffix;
  C_STRING &_InputMask;

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_ATTRIB::set_charact(int _OrderPos, C_STRING &_Caption, int _vis, int _VisOnTooltip, int _man,
                          TCHAR *_calc_file, TCHAR *_calc_func, int _IsDefCalc,
                          TCHAR *_valid_file, TCHAR *_valid_func, C_STRING &_ValidErrMsg,
                          C_STRING &_Descr,
                          C_STRING &_GphPrefix, C_STRING &_GphSuffix,
                          C_STRING &_InputMask)
{
   size_t   len;
   C_STRING buff;

   OrderPos = _OrderPos;

   if (_Caption.len() == 0) Caption = name;
   else Caption = _Caption;

   vis          = (_vis == 0) ? GS_BAD : GS_GOOD;
   VisOnTooltip = (_VisOnTooltip == 0) ? GS_BAD : GS_GOOD;
   man          = (_man == 0) ? GS_BAD : GS_GOOD;
    
   if (calc_file) { free(calc_file); calc_file = NULL; }
   if (calc_func) { free(calc_func); calc_func = NULL; }
   if (valid_file) { free(valid_file); valid_file = NULL; }
   if (valid_func) { free(valid_func); valid_func = NULL; }
   
   // nome della funzione
   if (_calc_func)
   {
      if ((len = wcslen(_calc_func)) < MAX_LSP_FUNCNAME && len > 0)
      {
         if ((calc_func = (TCHAR *) malloc(sizeof(TCHAR) * (len + 1))) == NULL)
            { GS_ERR_COD = eGSOutOfMem; return GS_BAD; }
         wcscpy(calc_func, _calc_func);
         gsc_alltrim(calc_func);
         // la converto in maiuscolo solo se una funzione da grafica
         if (is_from_graph() == GS_GOOD) gsc_toupper(calc_func);
      }      
      // nome del file
      if (_calc_file != NULL)
      {
         if (wcslen(_calc_file) > 0)
         {
            buff = _calc_file;
            buff.alltrim();
            // converto path con uno senza alias host
            if (gsc_nethost2drive(buff) == GS_BAD) return GS_BAD;
            calc_file = gsc_tostring(buff.get_name());
         }      
      }
      
      IsDefCalc = (_IsDefCalc == 0) ? GS_BAD : GS_GOOD;
   }
   else
      IsDefCalc = GS_BAD;

   // nome della funzione
   if (_valid_func != NULL)
   {
      if ((len = wcslen(_valid_func)) < MAX_LSP_FUNCNAME && len > 0)
      {
         if ((valid_func = (TCHAR *) malloc(sizeof(TCHAR) * (len + 1))) == NULL)
            { GS_ERR_COD = eGSOutOfMem; return GS_BAD; }
         wcscpy(valid_func, _valid_func);
         gsc_alltrim(valid_func);
      }
      // nome del file
      if (_valid_file != NULL)
      {
         if (wcslen(_valid_file) > 0)
         {
            buff = _valid_file;
            buff.alltrim();
            // converto path con uno senza alias host
            if (gsc_nethost2drive(buff) == GS_BAD) return GS_BAD;
            valid_file = gsc_tostring(buff.get_name());
         }
      }
   }
 
   Descr       = _Descr;
   ValidErrMsg = _ValidErrMsg;
   GphPrefix   = _GphPrefix;
   GphSuffix   = _GphSuffix;
   InputMask   = _InputMask;

   return GS_GOOD;
}


/*********************************************************/
/*.doc (new 2) C_ATTRIB::set <internal> */
/*+
  Questa funzione setta tutte le informazioni di un attributo.
  Parametri:
  C_ATTRIB *in;
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_ATTRIB::set(C_ATTRIB *in)
{
   if (!in) { GS_ERR_COD = eGSInvalidArg; return GS_BAD; } 

   return set(in->name, in->OrderPos, in->Caption, in->type, in->len, in->dec, 
              in->vis, in->VisOnTooltip, in->man,
              in->calc_file, in->calc_func, in->IsDefCalc,
              in->valid_file, in->valid_func, in->ValidErrMsg,
              in->def, in->mod_attr, in->Descr,
              in->GphPrefix, in->GphSuffix, in->InputMask);
}


/*********************************************************/
/*.doc (new 2) C_ATTRIB::set <internal> */
/*+
  Questa funzione setta tutte le informazioni di un attributo.
  Parametri:
  C_STRING  &_name;
  int       _OrderPos;
  C_STRING  &_Caption;
  TCHAR     *_type;
  long      _len;
  int       _dec;
  int       _vis;
  int       _VisOnTooltip;
  int       _man;
  TCHAR     *_calc_file;
  TCHAR     *_calc_func;
  int       _IsDefCalc;
  TCHAR     *_valid_file;
  TCHAR     *_valid_func;
  C_STRING  &_ValidErrMsg;
  resbuf    *_def;
  int       _mod_attr;
  C_STRING  &_Descr;
  C_STRING  &_GphPrefix;
  C_STRING  &_GphSuffix;
  C_STRING  &_InputMask;
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_ATTRIB::set(C_STRING &_name, int _OrderPos, C_STRING &_Caption, TCHAR *_type,
                  long _len, int _dec, int _vis, int _VisOnTooltip, int _man,
                  TCHAR *_calc_file, TCHAR *_calc_func, int _IsDefCalc,
                  TCHAR *_valid_file, TCHAR *_valid_func, C_STRING &_ValidErrMsg,
                  resbuf *_def, int _mod_attr, C_STRING &_Descr,
                  C_STRING &_GphPrefix, C_STRING &_GphSuffix,
                  C_STRING &_InputMask)
{
   if (_name.len() == 0 || !_type) { GS_ERR_COD = eGSInvalidArg; return GS_BAD; }

   name = _name;
   
   gsc_strcpy(type, _type, MAX_LEN_FIELDTYPE);
   gsc_alltrim(type);

   len = _len;
   dec = _dec;

   if (set_charact(_OrderPos, _Caption, _vis, _VisOnTooltip, _man, _calc_file, _calc_func, _IsDefCalc, 
                   _valid_file, _valid_func, _ValidErrMsg, _Descr,
                   _GphPrefix, _GphSuffix, _InputMask) == GS_BAD)
      return GS_BAD;

   if (def) acutRelRb(def);
   if (_def) def = gsc_copybuf(_def);
   else def = NULL;

   mod_attr = _mod_attr;

   return GS_GOOD;
}


/************************************************************/
/*.doc C_ATTRIB::CheckValue                                 */
/*+
  Questa funzione controlla la correttezza del valore
  verificando lunghezza, decimali, tipo, obbligatorietà. 
  Il valore viene modificato con quello corretto.
  Parametri:
  presbuf   NewValue;         Nuovo valore dell'attributo
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
  N.B.: Deve essere già stata chiamata la "C_ATTRIB::init_ADOType"
-*/  
/************************************************************/
int C_ATTRIB::CheckValue(presbuf Value) 
{
   size_t str_len = 0;
   TCHAR *str_num = NULL;

   if (!Value) { GS_ERR_COD = eGSInvalidArg; return GS_BAD; }
   if (ADOType == adEmpty) { GS_ERR_COD = eGSInvalidArg; return GS_BAD; }

	// Obbligatorietà
	if (is_mandatory() == GS_GOOD)
      // controllo da fare solo su attributi che non sono boolean
      if (ADOType != adBoolean)
         if (Value->restype == RTNONE || Value->restype == RTVOID ||
             Value->restype == RTNIL ||
             (Value->restype == RTSTR && wcslen(Value->resval.rstring) == 0))
            { GS_ERR_COD = eGSObbligFound; return GS_BAD; }

   // se la destinazione è carattere
   if (gsc_DBIsChar(ADOType) == GS_GOOD)
   {
      switch (Value->restype)
      {
         case RTREAL:
            if ((str_num = gsc_tostring(Value->resval.rreal)) == NULL) return GS_BAD;
            str_len = wcslen(str_num);
            if ((long) str_len > len) str_num[len] = _T('\0');
            gsc_RbSubst(Value, str_num);
            break;
         case RTSHORT:
            if ((str_num = gsc_tostring(Value->resval.rint)) == NULL) return GS_BAD;
            str_len = wcslen(str_num);
            if ((long) str_len > len) str_num[len] = _T('\0');
            gsc_RbSubst(Value, str_num);
            break;
         case RTLONG:
            if ((str_num = gsc_tostring(Value->resval.rlong)) == NULL) return GS_BAD;
            str_len = wcslen(str_num);
            if ((long) str_len > len) str_num[len] = _T('\0');
            gsc_RbSubst(Value, str_num);
            break;
         case RTSTR:
            if ((str_num = gsc_tostring(Value->resval.rstring)) == NULL) return GS_BAD;
            str_len = wcslen(str_num);
            if ((long) str_len > len) str_num[len] = _T('\0');
            gsc_RbSubst(Value, str_num);
            break;
         case RTPOINT:
         case RT3DPOINT:
            if ((str_num = gsc_tostring(Value->resval.rpoint)) == NULL) return GS_BAD;
            str_len = wcslen(str_num);
            if ((long) str_len > len) str_num[len] = _T('\0');
            gsc_RbSubst(Value, str_num);
            break;
         case RTNIL: case RTNONE: case RTVOID:
            gsc_RbSubstNIL(Value);
				break;
         default:
				GS_ERR_COD = eGSInvAttribType;
				return GS_BAD;
      }
   }
   else
   if (gsc_DBIsDate(ADOType) == GS_GOOD ||
       gsc_DBIsTimestamp(ADOType) == GS_GOOD)
   {
      if (Value->restype == RTNIL || Value->restype == RTNONE)
         gsc_RbSubstNIL(Value);
      else
      {
         C_STRING DateTimeDest;
         if (Value->restype != RTSTR) { GS_ERR_COD = eGSInvAttribType; return GS_BAD; }
         // se la conversione fallisce la data è invalida
         if (gsc_conv_DateTime_2_WinFmt(Value->resval.rstring, DateTimeDest) == GS_BAD) return GS_BAD;
      }
   }
   else
   if (gsc_DBIsTime(ADOType) == GS_GOOD)
   {
      if (Value->restype == RTNIL || Value->restype == RTNONE)
         gsc_RbSubstNIL(Value);
      else
      {
         C_STRING TimeDest;
         if (Value->restype != RTSTR) { GS_ERR_COD = eGSInvAttribType; return GS_BAD; }
         // se la conversione fallisce la data è invalida
         if (gsc_conv_Time_2_WinFmt(Value->resval.rstring, TimeDest) == GS_BAD) return GS_BAD;
      }
   }
   else
   if (gsc_DBIsNumeric(ADOType) == GS_GOOD)
   {
      switch (Value->restype)
      {
         case RTSTR:
            gsc_RbSubst(Value, _wtof(Value->resval.rstring));
         case RTREAL:
            if (CheckReal(&(Value->resval.rreal)) == GS_BAD) return GS_BAD; 
            break;
         case RTSHORT:
            // La lunghezza non tiene conto del segno
            if ((str_num = gsc_tostring(abs(Value->resval.rint))) == NULL) return GS_BAD;
            str_len = wcslen(str_num);
            if ((long) str_len > len) 
            {
               GS_ERR_COD = eGSInvAttribLen;
               free(str_num);
               return GS_BAD;
            }
            break;
         case RTLONG:
            // La lunghezza non tiene conto del segno
            if ((str_num = gsc_tostring(labs(Value->resval.rlong))) == NULL) return GS_BAD; 
            str_len = wcslen(str_num);
            if ((long) str_len > len)
            {
               GS_ERR_COD = eGSInvAttribLen;
               free(str_num);
               return GS_BAD;
            }
            break;
         case RTNIL: case RTNONE: case RTVOID:
            gsc_RbSubstNIL(Value);
            break;
         default:
				GS_ERR_COD = eGSInvAttribType;
				return GS_BAD;
      }
   }
   else
   if (gsc_DBIsBoolean(ADOType) == GS_GOOD)
   {
      switch (Value->restype)
      {
         case RTT: case RTNIL:
            break;
         case RTNONE: case RTVOID:
            gsc_RbSubstNIL(Value);
            break;
         case RTSHORT:
            if (Value->resval.rint) gsc_RbSubstT(Value);
            else gsc_RbSubstNIL(Value);
            break;
         case RTLONG:
            if (Value->resval.rlong) gsc_RbSubstT(Value);
            else gsc_RbSubstNIL(Value);
            break;
         case RTREAL:
            if (Value->resval.rreal) gsc_RbSubstT(Value);
            else gsc_RbSubstNIL(Value);
            break;
         case RTSTR:
         {
            int IsTrue;

            gsc_conv_Bool(Value->resval.rstring, &IsTrue);
            if (IsTrue) gsc_RbSubstT(Value);
            else gsc_RbSubstNIL(Value);
            break;
         }
         default:
            GS_ERR_COD = eGSInvAttribType;
            return GS_BAD;
      }
   }
   else
   if (gsc_DBIsBlob(ADOType) != GS_GOOD)
      { GS_ERR_COD = eGSInvAttribType; return GS_BAD; }

   if (str_num) free(str_num);

   return GS_GOOD;
}


/*********************************************************/
/*.doc C_ATTRIB::CheckReal <internal> */
/*+
  Questa funzione verifica se un valore reale è adatto alle 
  caratteristiche dell'attributo.
  Parametri:
  ads_real *value;

  Restituisce GS_GOOD in caso di successo altrimenti GS_BAD.
-*/  
/*********************************************************/
int C_ATTRIB::CheckReal(ads_real *value) 
{
   TCHAR *StrNum;

   // Ne faccio l'abs per non considerare il segno nella lunghezza
   if ((StrNum = gsc_tostring(fabs(*value), len, dec)) == NULL) return GS_BAD;

   if (wcschr(StrNum, _T('e')) != NULL) // es. 1.11e+011
      // la funzione ha approssimato con notazione esponenziale -> n. troppo grande
      { free(StrNum); GS_ERR_COD = eGSInvAttribLen; return GS_BAD; }

   if (*value < 0)
      *value = -1.0 * _wtof(StrNum);
   else
      *value = _wtof(StrNum);

   free(StrNum);

   //int      positive;
   //char     *str_num = NULL, *separator = NULL;
   //C_STRING IntPart, DecPart;

   //positive = (*value >= 0) ? TRUE : FALSE;
   //// non considero il segno
   //if ((str_num = gsc_tostring(fabs(*value))) == NULL) return GS_BAD;
   //
   //if (wcschr(str_num, _T('e')) != NULL) // es. 1.11e+011
   //   // la funzione ha approssimato con notazione esponenziale -> n. troppo grande
   //   { free(str_num); GS_ERR_COD = eGSInvAttribLen; return GS_BAD; }
   //
   //// cerco il divisore tra parte intera e decimale
   //if ((separator = wcschr(str_num, _T('.'))) == NULL)
   //   IntPart = str_num;
   //else
   //{
   //   if ((IntPart.set_name(str_num, 0, (separator - str_num - 1))) == GS_BAD)
   //      { free(str_num); return GS_BAD; }
   //   DecPart = ++separator;
   //}
   //free(str_num);
   //
   //// verifico dimensione valore parte intera
   //if (dec == 0)
   //{
   //   if (IntPart.len() > len) { GS_ERR_COD = eGSInvAttribLen; return GS_BAD; }
   //}
   //else
   //{
   //   int nDecAvailable = dec; 
   //   int LenIntPart = IntPart.len();
   //   int LenDecPart = DecPart.len();

   //   // Se numero troppo grande
   //   if (LenIntPart + LenDecPart > len)
   //   { // Diminuisco il numero di decimali
   //      nDecAvailable = len - IntPart.len();
   //      // Se anche questo non è sufficiente
   //      if (nDecAvailable < 0) {  GS_ERR_COD = eGSInvAttribLen; return GS_BAD; }
   //   }

   //   // verifico dimensione valore parte decimale
   //   if (LenDecPart > nDecAvailable)
   //   {  // taglio i decimali meno significativi
   //      if (nDecAvailable >= 0) DecPart.set_chr('\0', nDecAvailable);
   //      IntPart += _T('.');
   //      IntPart += DecPart;
   //      *value = _wtof(IntPart.get_name());

   //      if (!positive) *value = *value * -1;
   //   }
   //}

   return GS_GOOD;
}


/*********************************************************/
/*.doc C_ATTRIB::from_rb <internal> */
/*+
  Questa funzione setta i valori della C_ATTRIB leggendoli da una lista resbuf.
  Parametri:
  resbuf *p_rb_attrib;      Lista resbuf
  ((ATTRIB <val>)(TYPE <val>)(LEN <val>)[(DECIM <val>)][(CAPTION <val>)]
   [(VISIBIL <val>)][(VISIB_ON_TOOLTIP <val>)][(MANDAT <val>)][(FILE_CALC <val>)]
   [(FUN_CALC <val>)][(IS_DEF_CALC <val>)][(FILE_VALID <val>)][(FUN_VALID <val>)]
   [(DEFAULT_VALUE <val>)][(MOD_ATTR <val>)][(VALIDATION_ERR_MSG <val>)]
   [(DESCRIPTION <val>)][(GPH_PREFIX <val>)][(GPH_SUFFIX <val>)][(INPUT_MASK <val>)]

  (<name><type><len><dec><vis><man><calcolabilità><validità><def><mod_attr><Descr>)
  
  <calcolabilità> = (<calc_file><calc_func>) || nil
  <validità>      = (<valid_file><valid_func>) || nil

  Restituisce GS_GOOD in caso di successo altrimenti GS_BAD.
-*/  
/*********************************************************/
int C_ATTRIB::from_rb(presbuf rb)
{
   presbuf p;
   C_STRING _name, _Caption, _Descr, _ValidErrMsg, _GphPrefix, _GphSuffix, _InputMask;
   TCHAR    *_Type, *_calc_file = NULL, *_calc_func = NULL;
   TCHAR    *_valid_file = NULL, *_valid_func = NULL;
   int      _OrderPos = 0, _dec = 0, _man = GS_BAD, _mod_attr = 0, _IsDefCalc = FALSE;
   int      _vis = INVISIBLE, _VisOnTooltip = VISIBLE;
   long     _len;
   presbuf  _def = NULL;

   if (rb == NULL) { GS_ERR_COD = eGSInvRBType; return GS_BAD; }

   // ATTRIB obbligatorio
   if (!(p = gsc_CdrAssoc(_T("ATTRIB"), rb, FALSE)) || p->restype != RTSTR)
      { GS_ERR_COD = eGSInvRBType; return GS_BAD; }
   _name = p->resval.rstring;

   // ORDER_POS   
   if ((p = gsc_CdrAssoc(_T("ORDER_POS"), rb, FALSE)))
      if (gsc_rb2Int(p, &_OrderPos) == GS_BAD)
         { GS_ERR_COD = eGSInvRBType; return GS_BAD; }

   // TYPE obbligatorio
   if (!(p = gsc_CdrAssoc(_T("TYPE"), rb, FALSE)) || p->restype != RTSTR)
      { GS_ERR_COD = eGSInvRBType; return GS_BAD; }
   _Type = p->resval.rstring;

   // LEN obbligatorio
   if (!(p = gsc_CdrAssoc(_T("LEN"), rb, FALSE)) || gsc_rb2Lng(p, &_len) == GS_BAD)
      { GS_ERR_COD = eGSInvRBType; return GS_BAD; }

   // DECIM
   if ((p = gsc_CdrAssoc(_T("DECIM"), rb, FALSE)))
      if (gsc_rb2Int(p, &_dec) == GS_BAD)
         { GS_ERR_COD = eGSInvRBType; return GS_BAD; }

   // CAPTION
   if ((p = gsc_CdrAssoc(_T("CAPTION"), rb, FALSE)) && p->restype == RTSTR)
      _Caption = p->resval.rstring;

   // VISIBIL
   if ((p = gsc_CdrAssoc(_T("VISIBIL"), rb, FALSE)))
      if (gsc_rb2Int(p, &_vis) == GS_BAD)
         { GS_ERR_COD = eGSInvRBType; return GS_BAD; }

   // VISIB_ON_TOOLTIP
   if ((p = gsc_CdrAssoc(_T("VISIB_ON_TOOLTIP"), rb, FALSE)))
      if (gsc_rb2Int(p, &_VisOnTooltip) == GS_BAD)
         { GS_ERR_COD = eGSInvRBType; return GS_BAD; }

   // MANDAT
   if ((p = gsc_CdrAssoc(_T("MANDAT"), rb, FALSE)))
      if (gsc_rb2Int(p, &_man) == GS_BAD)
         { GS_ERR_COD = eGSInvRBType; return GS_BAD; }

   // FILE_CALC
   if ((p = gsc_CdrAssoc(_T("FILE_CALC"), rb, FALSE)) && p->restype == RTSTR)
      _calc_file = p->resval.rstring;

   // FUN_CALC
   if ((p = gsc_CdrAssoc(_T("FUN_CALC"), rb, FALSE)) && p->restype == RTSTR)
      _calc_func = p->resval.rstring;

   // IS_DEF_CALC
   if ((p = gsc_CdrAssoc(_T("IS_DEF_CALC"), rb, FALSE)))
      if (gsc_rb2Int(p, &_IsDefCalc) == GS_BAD)
         { GS_ERR_COD = eGSInvRBType; return GS_BAD; }

   // FILE_VALID
   if ((p = gsc_CdrAssoc(_T("FILE_VALID"), rb, FALSE)) && p->restype == RTSTR)
      _valid_file = p->resval.rstring;

   // FUN_VALID
   if ((p = gsc_CdrAssoc(_T("FUN_VALID"), rb, FALSE)) && p->restype == RTSTR)
      _valid_func = p->resval.rstring;

   // DEFAULT_VALUE
   if ((p = gsc_CdrAssoc(_T("DEFAULT_VALUE"), rb, FALSE)))
      _def = p;

   // MOD_ATTR
   if ((p = gsc_CdrAssoc(_T("MOD_ATTR"), rb, FALSE)))
      if (gsc_rb2Int(p, &_mod_attr) == GS_BAD)
         { GS_ERR_COD = eGSInvRBType; return GS_BAD; }
   
   // VALIDATION_ERR_MSG
   if ((p = gsc_CdrAssoc(_T("VALIDATION_ERR_MSG"), rb, FALSE)) && p->restype == RTSTR &&
       gsc_strlen(p->resval.rstring) > 0)
      _ValidErrMsg = p->resval.rstring;

   // DESCRIPTION
   if ((p = gsc_CdrAssoc(_T("DESCRIPTION"), rb, FALSE)) && p->restype == RTSTR &&
       gsc_strlen(p->resval.rstring) > 0)
      _Descr = p->resval.rstring;

   // GPH_PREFIX
   if ((p = gsc_CdrAssoc(_T("GPH_PREFIX"), rb, FALSE)) && p->restype == RTSTR &&
       gsc_strlen(p->resval.rstring) > 0)
      _GphPrefix = p->resval.rstring;

   // GPH_SUFFIX
   if ((p = gsc_CdrAssoc(_T("GPH_SUFFIX"), rb, FALSE)) && p->restype == RTSTR &&
       gsc_strlen(p->resval.rstring) > 0)
      _GphSuffix = p->resval.rstring;

   // INPUT_MASK
   if ((p = gsc_CdrAssoc(_T("INPUT_MASK"), rb, FALSE)) && p->restype == RTSTR &&
       gsc_strlen(p->resval.rstring) > 0)
      _InputMask = p->resval.rstring;
           
   return set(_name, _OrderPos, _Caption, _Type, _len, _dec,
              _vis, _VisOnTooltip, _man,
              _calc_file, _calc_func, _IsDefCalc,
              _valid_file, _valid_func, _ValidErrMsg,
              _def, _mod_attr, _Descr,
              _GphPrefix, _GphSuffix, _InputMask);
}


/*********************************************************/
/*.doc (new 2) C_ATTRIB::to_rb <internal> */
/*+
  Questa funzione ritorna una lista di resbuf con tutte le informazioni
  dell'attributo.
  (("ATTRIB"<nome>)("ORDER_POS"<pos>)("CAPTION"<caption>)("TYPE"<tipo>)("LEN"<len>)("DECIM"<dec>)
   ("VISIBIL"<vis>)("VISIB_ON_TOOLTIP"<VisOnTooltip>)("MANDAT"<obbl>)
   ("FILE_CALC"<calc_file>)("FUN_CALC"<calc_funz>)("IS_DEF_CALC"<IsDefCalc>)
   ("FILE_VALID"<val_file>)("FUN_VALID"<val_funz>)
   ("DEFAULT_VALUE"<default>)("MOD_ATTR"<mod_attr>)("VALIDATION_ERR_MSG"<ValidErrMsg>)
   ("DESCRIPTION"<descrizione>)("GPH_PREFIX"<prefisso gph>)("GPH_SUFFIX"<suffisso gph>)
   ("INPUT_MASK"<mask>))

  Parametri:
  bool ConvertDrive2nethost; Se = TRUE le path vengono convertite
                             con alias di rete (default = FALSE)
    
  Restituisce una lista di resbuf in caso di successo altrimenti restituisce NULL.
-*/  
/*********************************************************/
presbuf C_ATTRIB::to_rb(bool ConvertDrive2nethost)
{
   C_RB_LIST List;
            
   // ATTRIB
   if ((List << acutBuildList(RTLB,
                              RTLB,
                                 RTSTR, _T("ATTRIB"),
                              0)) == NULL) return NULL;
   if ((List += gsc_str2rb(name)) == NULL) return NULL;
   // ORDER_POS
   if ((List += acutBuildList(RTLE,
                              RTLB,
                                 RTSTR, _T("ORDER_POS"),
                                 RTSHORT, OrderPos,
                              0)) == NULL) return NULL; 
    // CAPTION
   if ((List += acutBuildList(RTLE,
                              RTLB,
                                 RTSTR, _T("CAPTION"),
                              0)) == NULL) return NULL;
   if ((List += gsc_str2rb(Caption)) == NULL) return NULL;
   // TYPE
   if ((List += acutBuildList(RTLE,
                              RTLB,
                                 RTSTR, _T("TYPE"),
                              0)) == NULL) return NULL; 
   if ((List += gsc_str2rb(type)) == NULL) return NULL;
   
   if ((List += acutBuildList(RTLE,
                              RTLB,
                                 RTSTR, _T("LEN"),    // LEN
                                 RTSHORT, len,
                              RTLE,
                              RTLB,
                                 RTSTR, _T("DECIM"),  // DECIM
                                 RTSHORT, dec,
                              RTLE,
                              RTLB,
                                 RTSTR, _T("VISIBIL"),  // VISIBIL
                                 RTSHORT, vis,
                              RTLE,
                              RTLB,
                                 RTSTR, _T("VISIB_ON_TOOLTIP"),  // VISIB_ON_TOOLTIP
                                 RTSHORT, VisOnTooltip,
                              RTLE,
                              RTLB,
                                 RTSTR, _T("MANDAT"),  // MANDAT
                                 RTSHORT, man,
                              RTLE,
                              RTLB,
                                 RTSTR, _T("FILE_CALC"),
                              0)) == NULL) return NULL;

   // FILE_CALC
   if (ConvertDrive2nethost)
   {
      C_STRING Path(calc_file);
      if (gsc_drive2nethost(Path) == GS_BAD) return NULL;
      if ((List += gsc_str2rb(Path)) == NULL) return NULL;
   }
   else
      if ((List += gsc_str2rb(calc_file)) == NULL) return NULL;

   // FUN_CALC
   if ((List += acutBuildList(RTLE,
                              RTLB,
                                 RTSTR, _T("FUN_CALC"),
                              0)) == NULL) return NULL;
   if ((List += gsc_str2rb(calc_func)) == NULL) return NULL;

   // IS_DEF_CALC
   if ((List += acutBuildList(RTLE,
                              RTLB,
                                 RTSTR, _T("IS_DEF_CALC"),
                                 RTSHORT, IsDefCalc,
                              RTLE,
                              RTLB,
                                 RTSTR, _T("FILE_VALID"),
                              0)) == NULL) return NULL;

   // FILE_VALID
   if (ConvertDrive2nethost)
   {
      C_STRING Path(valid_file);
      if (gsc_drive2nethost(Path) == GS_BAD) return NULL;
      if ((List += gsc_str2rb(Path)) == NULL) return NULL;
   }
   else
      if ((List += gsc_str2rb(valid_file)) == NULL) return NULL;

   // FUN_VALID
   if ((List += acutBuildList(RTLE,
                              RTLB,
                                 RTSTR, _T("FUN_VALID"),
                              0)) == NULL) return NULL;
   if ((List += gsc_str2rb(valid_func)) == NULL) return NULL;

   // DEFAULT_VALUE
   if ((List += acutBuildList(RTLE,
                              RTLB,
                                 RTSTR, _T("DEFAULT_VALUE"),
                              0)) == NULL) return NULL;
   if (def)
   {
      if ((List += gsc_copybuf(def)) == NULL) return NULL;
   }   
   else 
      if ((List += acutBuildList(RTNIL, 0)) == NULL) return NULL;

   // MOD_ATTR
   if ((List += acutBuildList(RTLE,
                              RTLB,
                                 RTSTR, _T("MOD_ATTR"),
                                 RTSHORT, mod_attr,
                              0)) == NULL) return NULL;
   
   // VALIDATION_ERR_MSG
   if ((List += acutBuildList(RTLE,
                              RTLB,
                                 RTSTR, _T("VALIDATION_ERR_MSG"),
                              0)) == NULL) return NULL;
   if ((List += gsc_str2rb(ValidErrMsg)) == NULL) return NULL;

   // DESCRIPTION
   if ((List += acutBuildList(RTLE,
                              RTLB,
                                 RTSTR, _T("DESCRIPTION"),
                              0)) == NULL) return NULL;
   if ((List += gsc_str2rb(Descr)) == NULL) return NULL;
   
   // GPH_PREFIX
   if ((List += acutBuildList(RTLE,
                              RTLB,
                                 RTSTR, _T("GPH_PREFIX"),
                              0)) == NULL) return NULL;
   if ((List += gsc_str2rb(GphPrefix)) == NULL) return NULL;

   // GPH_SUFFIX
   if ((List += acutBuildList(RTLE,
                              RTLB,
                                 RTSTR, _T("GPH_SUFFIX"),
                              0)) == NULL) return NULL;
   if ((List += gsc_str2rb(GphSuffix)) == NULL) return NULL;

   // INPUT_MASK
   if ((List += acutBuildList(RTLE,
                              RTLB,
                                 RTSTR, _T("INPUT_MASK"),
                              0)) == NULL) return NULL;
   if ((List += gsc_str2rb(InputMask)) == NULL) return NULL;

   if ((List += acutBuildList(RTLE, RTLE, 0)) == NULL) return NULL;

   List.ReleaseAllAtDistruction(GS_BAD);

   return List.get_head();      
}


/*********************************************************/
/*.doc C_ATTRIB::NoGraphInfoToRb                <internal> */
/*+
  Questa funzione ritorna una lista di resbuf con tutte le informazioni
  non grafiche dell'attributo sottoforma di lista
  di coppie di resbuf ((<proprietà> <valore>) ...).
  bool ConvertDrive2nethost; Se = TRUE le path vengono convertite
                             con alias di rete (default = FALSE)
  
  Restituisce la lista in caso di successo altrimenti restituisce NULL.
-*/  
/*********************************************************/
presbuf C_ATTRIB::NoGraphInfoToRb(bool ConvertDrive2nethost)
{
   C_RB_LIST List;
            
   if ((List << acutBuildList(RTLB,
                                 RTSTR, _T("ATTRIB"),
                                 RTSTR, get_name(),
                              RTLE,
                              RTLB,
                                 RTSTR, _T("ORDER_POS"),                                 
                                 RTSHORT, OrderPos,
                              RTLE,
                              RTLB,
                                 RTSTR, _T("MANDAT"),                                 
                                 RTSHORT, man,
                              RTLE,
                              RTLB,
                                 RTSTR, _T("VISIBIL"),
                                 RTSHORT, vis,
                              RTLE,
                              RTLB,
                                 RTSTR, _T("VISIB_ON_TOOLTIP"),
                                 RTSHORT, VisOnTooltip,
                              RTLE,
                              RTLB,
                                 RTSTR, _T("FILE_VALID"),
                              0)) == NULL) return NULL;
   if (ConvertDrive2nethost)
   {
      C_STRING Path(valid_file);
      if (gsc_drive2nethost(Path) == GS_BAD) return NULL;
      if ((List += gsc_str2rb(Path)) == NULL) return NULL;
   }
   else
      if ((List += gsc_str2rb(valid_file)) == NULL) return NULL;
   if ((List += acutBuildList(RTLE,
                              RTLB,
                                 RTSTR, _T("FUN_VALID"),
                              0)) == NULL) return NULL;
   if ((List += gsc_str2rb(valid_func)) == NULL) return NULL;
   if ((List += acutBuildList(RTLE,
                              RTLB,
                                 RTSTR, _T("VALIDATION_ERR_MSG"),
                              0)) == NULL) return NULL;
   if ((List += gsc_str2rb(ValidErrMsg)) == NULL) return NULL;
   if ((List += acutBuildList(RTLE,
                              RTLB,
                                 RTSTR, _T("FILE_CALC"),
                              0)) == NULL) return NULL;
   if (ConvertDrive2nethost)
   {
      C_STRING Path(calc_file);
      if (gsc_drive2nethost(Path) == GS_BAD) return NULL;
      if ((List += gsc_str2rb(Path)) == NULL) return NULL;
   }
   else
      if ((List += gsc_str2rb(calc_file)) == NULL) return NULL;
   if ((List += acutBuildList(RTLE,
                              RTLB,
                                 RTSTR, _T("FUN_CALC"),
                              0)) == NULL) return NULL;
   if ((List += gsc_str2rb(calc_func)) == NULL) return NULL;
   if ((List += acutBuildList(RTLE,
                              RTLB,
                                 RTSTR, _T("IS_DEF_CALC"),
                                 RTSHORT, IsDefCalc,
                              RTLE,
                              RTLB,
                                 RTSTR, _T("MOD_ATTR"),
                                 RTSHORT, mod_attr,
                              RTLE,
                              RTLB,
                                 RTSTR, _T("LEN"),
                                 RTLONG, len,
                              RTLE,
                              RTLB,
                                 RTSTR, _T("DECIM"),
                                 RTSHORT, dec,
                              RTLE,
                              RTLB,
                                 RTSTR, _T("DESCRIPTION"),
                              0)) == NULL) return NULL;
   if ((List += gsc_str2rb(Descr)) == NULL) return NULL;
   if ((List += acutBuildList(RTLE,
                              RTLB,
                                 RTSTR, _T("INPUT_MASK"),
                              0)) == NULL) return NULL;
   if ((List += gsc_str2rb(InputMask)) == NULL) return NULL;
   if ((List += acutBuildList(RTLE,
                              RTLB,
                                 RTSTR, _T("CAPTION"),
                              0)) == NULL) return NULL;
   if ((List += gsc_str2rb(Caption)) == NULL) return NULL;
   if ((List += acutBuildList(RTLE, 0)) == NULL) return NULL;

   List.ReleaseAllAtDistruction(GS_BAD);

   return List.get_head();      
}


/*********************************************************/
/*.doc C_ATTRIB::NoGraphInfoFromRb                <internal> */
/*+
  Questa funzione legge le informazioni non grafiche dell'attributo 
  sottoforma di lista
  di coppie di resbuf ((<proprietà> <valore>) ...).
  Parametri:
  C_RB_LIST &ColValues; Lista di valori
  oppure
  resbuf *rb;           Lista di valori

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_ATTRIB::NoGraphInfoFromRb(C_RB_LIST &ColValues)
{
   return NoGraphInfoFromRb(ColValues.get_head());
}
int C_ATTRIB::NoGraphInfoFromRb(resbuf *rb)
{
   presbuf p;

   if ((p = gsc_CdrAssoc(_T("ATTRIB"), rb, FALSE)))
      if (p->restype == RTSTR) name = p->resval.rstring;
      else { GS_ERR_COD = eGSInvAttribName; return GS_BAD; }

   if ((p = gsc_CdrAssoc(_T("ORDER_POS"), rb, FALSE)))
      if (gsc_rb2Int(p, &OrderPos) == GS_BAD) OrderPos = 0;

   if ((p = gsc_CdrAssoc(_T("CAPTION"), rb, FALSE)))
      Caption.paste(gsc_rb2str(p));

   if ((p = gsc_CdrAssoc(_T("MANDAT"), rb, FALSE)))
      if (gsc_rb2Int(p, &man) == GS_BAD) man = 0;

   if ((p = gsc_CdrAssoc(_T("VISIBIL"), rb, FALSE)))
      if (gsc_rb2Int(p, &vis) == GS_BAD) vis = 0;

   if ((p = gsc_CdrAssoc(_T("VISIB_ON_TOOLTIP"), rb, FALSE)))
      if (gsc_rb2Int(p, &VisOnTooltip) == GS_BAD) VisOnTooltip = 0;

   if ((p = gsc_CdrAssoc(_T("FILE_VALID"), rb, FALSE)))
   {
      if (valid_file) { free(valid_file); valid_file = NULL; }
      if (p->restype == RTSTR)
      {
         C_STRING dummy(p->resval.rstring);
         // traduco dir assoluto in dir relativo
         if (gsc_nethost2drive(dummy) == GS_BAD) return GS_BAD;
         valid_file = dummy.cut();
      }
   }

   if ((p = gsc_CdrAssoc(_T("FUN_VALID"), rb, FALSE)))
   {
      if (valid_func) { free(valid_func); valid_func = NULL; }
      if (p->restype == RTSTR) valid_func = gsc_tostring(p->resval.rstring);
   }

   if ((p = gsc_CdrAssoc(_T("VALIDATION_ERR_MSG"), rb, FALSE)))
      ValidErrMsg.paste(gsc_rb2str(p));

   if ((p = gsc_CdrAssoc(_T("FILE_CALC"), rb, FALSE)))
   {
      if (calc_file) { free(calc_file); calc_file = NULL; }
      if (p->restype == RTSTR)
      {
         C_STRING dummy(p->resval.rstring);
         // traduco dir assoluto in dir relativo
         if (gsc_nethost2drive(dummy) == GS_BAD) return GS_BAD;
         calc_file = dummy.cut();
      }
   }

   if ((p = gsc_CdrAssoc(_T("FUN_CALC"), rb, FALSE)))
   {
      if (calc_func) { free(calc_func); calc_func = NULL; }
      if (p->restype == RTSTR) calc_func = gsc_tostring(p->resval.rstring);
   }

   if ((p = gsc_CdrAssoc(_T("IS_DEF_CALC"), rb, FALSE)))
      if (gsc_rb2Int(p, &IsDefCalc) == GS_BAD) IsDefCalc = 0;

   if ((p = gsc_CdrAssoc(_T("MOD_ATTR"), rb, FALSE)))
      if (gsc_rb2Int(p, &mod_attr) == GS_BAD) mod_attr = 0;

   if ((p = gsc_CdrAssoc(_T("LEN"), rb, FALSE)))
      if (gsc_rb2Lng(p, &len) == GS_BAD) len = 0;

   if ((p = gsc_CdrAssoc(_T("DECIM"), rb, FALSE)))
      if (gsc_rb2Int(p, &dec) == GS_BAD) dec = 0;

   if ((p = gsc_CdrAssoc(_T("DESCRIPTION"), rb, FALSE)))
      Descr.paste(gsc_rb2str(p));

   if ((p = gsc_CdrAssoc(_T("INPUT_MASK"), rb, FALSE)))
      InputMask.paste(gsc_rb2str(p));

   return GS_GOOD;
}


/*********************************************************/
/*.doc C_ATTRIB::GraphInfoToRb                <internal> */
/*+
  Questa funzione ritorna una lista di resbuf con tutte le informazioni
  grafiche dell'attributo sottoforma di lista
  di coppie di resbuf ((<proprietà> <valore>) ...).
  
  Restituisce la lista in caso di successo altrimenti restituisce NULL.
-*/  
/*********************************************************/
presbuf C_ATTRIB::GraphInfoToRb(void)
{
   C_RB_LIST List;

   if ((List << acutBuildList(RTLB,
                                 RTSTR, _T("ATTRIB"),
                                 RTSTR, get_name(),
                              RTLE,
                              RTLB,
                                 RTSTR, _T("GPH_PREFIX"),
                              0)) == NULL) return NULL;
   if ((List += gsc_str2rb(GphPrefix)) == NULL) return NULL;
   if ((List += acutBuildList(RTLE,
                              RTLB,
                                 RTSTR, _T("GPH_SUFFIX"),
                              0)) == NULL) return NULL;
   if ((List += gsc_str2rb(GphSuffix)) == NULL) return NULL;
   if ((List += acutBuildList(RTLE, 0)) == NULL) return NULL;

   List.ReleaseAllAtDistruction(GS_BAD);

   return List.get_head();      
}


/*********************************************************/
/*.doc C_ATTRIB::GraphInfoFromRb                <internal> */
/*+
  Questa funzione legge le informazioni grafiche dell'attributo 
  sottoforma di lista
  di coppie di resbuf ((<proprietà> <valore>) ...).
  Parametri:
  C_RB_LIST &ColValues; Lista di valori
  oppure
  resbuf *rb;           Lista di valori

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_ATTRIB::GraphInfoFromRb(C_RB_LIST &ColValues)
{
   return GraphInfoFromRb(ColValues.get_head());
}
int C_ATTRIB::GraphInfoFromRb(resbuf *rb)
{
   presbuf p;

   if ((p = gsc_CdrAssoc(_T("ATTRIB"), rb, FALSE)))
      if (p->restype == RTSTR) name = p->resval.rstring;
      else { GS_ERR_COD = eGSInvAttribName; return GS_BAD; }

   if ((p = gsc_CdrAssoc(_T("GPH_PREFIX"), rb, FALSE)))
      if (p->restype == RTSTR) GphPrefix = p->resval.rstring;
      else GphPrefix.clear();

   if ((p = gsc_CdrAssoc(_T("GPH_SUFFIX"), rb, FALSE)))
      if (p->restype == RTSTR) GphSuffix = p->resval.rstring;
      else GphSuffix.clear();

   return GS_GOOD;
}


/*********************************************************/
/*.doc C_ATTRIB::is_validated <internal> */
/*+
  Restituisce GS_GOOD nel caso in cui l'attributo abbia una funzione di
  validazione altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_ATTRIB::is_validated()
{
   return (valid_func != NULL && wcslen(valid_func) > 0) ? GS_GOOD : GS_BAD;
}


/*********************************************************/
/*.doc C_ATTRIB::is_calculated                <internal> */
/*+
  Restituisce GS_GOOD nel caso in cui il valore dell'attributo sia il risultato
  di una funzione di calcolo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_ATTRIB::is_calculated(void)
{
   return (calc_func && wcslen(calc_func) > 0 && IsDefCalc == GS_BAD) ? GS_GOOD : GS_BAD;
}


/*********************************************************/
/*.doc C_ATTRIB::is_DefCalculated             <internal> */
/*+
  Restituisce GS_GOOD nel caso in cui il valore di default dell'attributo 
  sia il risultato di una funzione di calcolo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_ATTRIB::is_DefCalculated(void)
{
   return (calc_func && wcslen(calc_func) > 0 && IsDefCalc == GS_GOOD) ? GS_GOOD : GS_BAD;
}


/*********************************************************/
/*.doc C_ATTRIB::is_visible <internal> */
/*+
  Restituisce GS_GOOD nel caso in cui l'attributo sia visibile in grafica
  altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_ATTRIB::is_visible(void) { return (vis == GS_BAD) ? GS_BAD : GS_GOOD; }


/*********************************************************/
/*.doc C_ATTRIB::is_VisibleOnTooltip <internal> */
/*+
  Restituisce GS_GOOD nel caso in cui l'attributo sia visibile in tooltip usata
  dall'interrogazione dinamica altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_ATTRIB::is_VisibleOnTooltip(void) { return (VisOnTooltip == GS_BAD) ? GS_BAD : GS_GOOD; }


/*********************************************************/
/*.doc C_ATTRIB::is_mandatory <internal> */
/*+
  Restituisce GS_GOOD nel caso in cui l'inserimento del valore dell'attributo
  sia obbligatorio altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_ATTRIB::is_mandatory(void) { return (man == GS_BAD) ? GS_BAD : GS_GOOD; }


/****************************************************************************/
/*.doc C_ATTRIB::reportHTML                                      <external> */
/*+
  Questa funzione stampa su un file i dati della C_ATTRIB.
  Parametri:
  FILE *file;     puntatore a file
  int prj;        codice progetto
  int cls;        codice classe
  int sub;        codice sottoclasse
  int sec;        codice tab. secondaria
  bool SynthMode; Opzionale. Flag di modalità di report.
                  Se = true attiva il report sintetico (default = false)
  int What;       Opzionale. Flag a bit usato nel caso di report dettagliato
                  per limitare la stampa di informazioni (indica cosa non stampare).

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/
/******************************************************************************/
int C_ATTRIB::reportHTML(FILE *file, int prj, int cls, int sub, int sec,
                         bool SynthMode, int What)
{
   C_STRING Value;
   C_STRING TitleBorderColor("#808080"), TitleBgColor("#c0c0c0");
   C_STRING BorderColor("#00CCCC"), BgColor("#99FFFF");

   if (SynthMode) // report sintetico 
   {  // formato tabellare la cui intestazione viene scritta 
      // in C_ATTRIB_LIST::reportHTML

      // inizio riga
      if (fwprintf(file, _T("\n<tr>")) < 0)
         { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

      // "Nome attributo"
      if (fwprintf(file, _T("<td width=\"30%%\">%s</td>"),
                   (name.len() == 0) ? _T("&nbsp;") : name.get_name()) < 0)
         { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

      // "Tipo attributo"
      if (fwprintf(file, _T("<td>%s</td>"), type) < 0)
         { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

      // "Lunghezza" e "Decimali"
      Value = len;
      if (dec >= 0) // se sono supportati i decimali
      {
         Value += _T(",");
         Value += dec;
      }

      if (fwprintf(file, _T("<td>%s</td>"), Value.get_name()) < 0)
         { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

      // "Valore di default"
      if (def) ParseToString(def, Value);
      if (fwprintf(file, _T("<td>%s</td>"),
                   (Value.len() > 0) ? Value.get_name() : _T("&nbsp;")) < 0)
         { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

      // Calcolato
      Value = (is_calculated() == GS_GOOD) ? gsc_msg(774) : gsc_msg(775); // Sì No
      if (fwprintf(file, _T("<td>%s</td>"), Value.get_name()) < 0)
         { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

      // Lista di scelta
      C_STRING SupportFile;
      ValuesListTypeEnum FileType;
      if (gsc_FindSupportFiles(get_name(), prj, cls, sub, sec,
                               SupportFile, &FileType) == GS_GOOD)
         Value = gsc_msg(774); // Sì
      else 
         Value = gsc_msg(775); // No

      if (fwprintf(file, _T("<td>%s</td>"), Value.get_name()) < 0) // Sì
            { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

      // fine riga
      if (fwprintf(file, _T("</tr>")) < 0)
         { GS_ERR_COD = eGSWriteFile; return GS_BAD; }
   }
   else // report dettagliato
   {
      // intestazione tabella
      if (fwprintf(file, _T("\n<table bordercolor=\"%s\" cellspacing=\"2\" cellpadding=\"2\" border=\"1\">"), 
                   BorderColor.get_name()) < 0)
         { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

      if (!(What & BIT_MOD_NAME)) // se non è interdetta la stampa di questa proprietà
         // "Nome attributo"
         if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\" width=\"30%%\"><b>%s:</b></td><td width=\"70%%\">%s</td></tr>"),
                      BgColor.get_name(), gsc_msg(740), 
                      (name.len() == 0) ? _T("&nbsp;") : name.get_name()) < 0)
            { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

      if (!(What & BIT_MOD_CAPTION)) // se non è interdetta la stampa di questa proprietà
         // "Etichetta attributo"
         if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\" width=\"30%%\"><b>%s:</b></td><td width=\"70%%\">%s</td></tr>"),
                      BgColor.get_name(), gsc_msg(767), 
                      (Caption.len() == 0) ? _T("&nbsp;") : Caption.get_name()) < 0)
            { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

      if (!(What & BIT_MOD_TYPE)) // se non è interdetta la stampa di questa proprietà
         // "Tipo attributo"
         if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%s</td></tr>"),
                      BgColor.get_name(), gsc_msg(741), type) < 0)
            { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

      if (!(What & BIT_MOD_LEN)) // se non è interdetta la stampa di questa proprietà
         // "Lunghezza"
         if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%d</td></tr>"),
                      BgColor.get_name(), gsc_msg(742), (len < 0) ? 0 : len) < 0)
            { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

      if (!(What & BIT_MOD_DEC)) // se non è interdetta la stampa di questa proprietà
         // "Decimali"
         if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%d</td></tr>"),
                      BgColor.get_name(), gsc_msg(743), (dec < 0) ? 0 : dec) < 0)
            { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

      if (!(What & BIT_MOD_VIS)) // se non è interdetta la stampa di questa proprietà
         if (is_visible() == GS_GOOD)
         {
            Value = gsc_msg(774); // "Si"
            if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%s</td></tr>"),
                         BgColor.get_name(), gsc_msg(744), Value.get_name()) < 0) // "Etichettato"
               { GS_ERR_COD = eGSWriteFile; return GS_BAD; }
         }

      if (!(What & BIT_MOD_VIS_ON_TOOLTIP)) // se non è interdetta la stampa di questa proprietà
      {
         // "Visibile in tooltip"
         Value = (is_VisibleOnTooltip() == GS_GOOD) ? gsc_msg(774) : gsc_msg(775);
         if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%s</td></tr>"),
                      BgColor.get_name(), gsc_msg(765), Value.get_name()) < 0) // "Si" "No"
            { GS_ERR_COD = eGSWriteFile; return GS_BAD; }
      }

      if (!(What & BIT_MOD_MAND)) // se non è interdetta la stampa di questa proprietà
      {
         // "Obbligatorio"
         Value = (is_mandatory() == GS_GOOD) ? gsc_msg(774) : gsc_msg(775);
         if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%s</td></tr>"),
                      BgColor.get_name(), gsc_msg(745), Value.get_name()) < 0) // "Si" "No"
            { GS_ERR_COD = eGSWriteFile; return GS_BAD; }
      }

      if (!(What & BIT_MOD_CALC)) // se non è interdetta la stampa di questa proprietà
      {
         // "File funz. calcolo"
         if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%s</td></tr>"),
                     BgColor.get_name(), gsc_msg(746),
                     (calc_file) ? calc_file : _T("&nbsp;")) < 0)
            { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

         // "Funzione calcolo"
         if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%s</td></tr>"),
                     BgColor.get_name(), gsc_msg(747),
                     (calc_func) ? calc_func : _T("&nbsp;")) < 0)
            { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

         // "Default calcolato"
         Value = (is_DefCalculated() == GS_GOOD) ? gsc_msg(774) : gsc_msg(775);
         if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%s</td></tr>"),
                      BgColor.get_name(), gsc_msg(119), Value.get_name()) < 0) // "Si" "No"
            { GS_ERR_COD = eGSWriteFile; return GS_BAD; }
      }

      if (!(What & BIT_MOD_VALID)) // se non è interdetta la stampa di questa proprietà
      {
         // "File funz. validità"
         if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%s</td></tr>"),
                      BgColor.get_name(), gsc_msg(748),
                      (valid_file) ? valid_file : _T("&nbsp;")) < 0)
            { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

         // "Funzione validità"
         if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%s</td></tr>"),
                      BgColor.get_name(), gsc_msg(749),
                      (is_validated() == GS_GOOD) ? valid_func : _T("&nbsp;")) < 0)
            { GS_ERR_COD = eGSWriteFile; return GS_BAD; }
      }

      if (!(What & BIT_MOD_DEF)) // se non è interdetta la stampa di questa proprietà
      {
         // "Valore di default"
         if (def) ParseToString(def, Value);
         if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%s</td></tr>"),
                      BgColor.get_name(), gsc_msg(750),
                      (Value.len() > 0) ? Value.get_name() : _T("&nbsp;")) < 0)
            { GS_ERR_COD = eGSWriteFile; return GS_BAD; }
      }
      
      // uso questo bit (BIT_DEL_ATTR) impropriamente perchè non mi sembra il caso 
      // di creare un bit solo per questo utilizzo
      if (!(What & BIT_DEL_ATTR)) // se non è interdetta la stampa di questa proprietà
         // "Modalità"
         if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%d</td></tr>"),
                      BgColor.get_name(), gsc_msg(737), mod_attr) < 0)
            { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

      if (!(What & BIT_MOD_DESCR)) // se non è interdetta la stampa di questa proprietà
         // "Descrizione"
         if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%s</td></tr>"),
                      BgColor.get_name(), gsc_msg(794),
                      (Descr.len() > 0) ? Descr.get_name() : _T("&nbsp;")) < 0)
            { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

      if (!(What & BIT_MOD_VALIDATION_ERR_MSG)) // se non è interdetta la stampa di questa proprietà
         // "Msg. di Err. Validaz."
         if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%s</td></tr>"),
                      BgColor.get_name(), gsc_msg(98),
                      (ValidErrMsg.len() > 0) ? ValidErrMsg.get_name() : _T("&nbsp;")) < 0)
            { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

      if (!(What & BIT_MOD_GPH_PREFIX_SUFFIX)) // se non è interdetta la stampa di questa proprietà
      {
         // "Prefisso grafico"
         if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%s</td></tr>"),
                     BgColor.get_name(), gsc_msg(290),
                     (GphPrefix.len() > 0) ? GphPrefix.get_name() : _T("&nbsp;")) < 0)
            { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

         // "Suffisso grafico"
         if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%s</td></tr>"),
                     BgColor.get_name(), gsc_msg(291),
                     (GphSuffix.len() > 0) ? GphSuffix.get_name() : _T("&nbsp;")) < 0)
            { GS_ERR_COD = eGSWriteFile; return GS_BAD; }
      }

      if (!(What & BIT_MOD_INPUT_MASK)) // se non è interdetta la stampa di questa proprietà
         // "Maschera di input dati"
         if (fwprintf(file, _T("\n<tr><td align=\"right\" bgcolor=\"%s\"><b>%s:</b></td><td>%s</td></tr>"),
                     BgColor.get_name(), gsc_msg(292),
                     (InputMask.len() > 0) ? InputMask.get_name() : _T("&nbsp;")) < 0)
            { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

      if (!(What & BIT_MOD_VALUES_LIST)) // se non è interdetta la stampa di questa proprietà
      {
         // Lista di scelta
         C_STRING SupportFile;
         ValuesListTypeEnum FileType, PrevFileType;
         bool               ValuesFromDB = false;
         if (gsc_FindSupportFiles(get_name(), prj, cls, sub, sec,
                                  SupportFile, &FileType) == GS_GOOD)
         {
            C_2STR_LIST ValuesList;
            C_2STR      *pValue;
            C_STRING    ConnStrUDLFile, UdlProperties, SelectStm;

            PrevFileType = FileType;
            // Carico la lista di valori
            ValuesList.load(SupportFile.get_name(), _T(';'));

            if (gsc_is_C_2STR_LIST_referred_to_DB(ValuesList, ConnStrUDLFile, 
                                                  UdlProperties, SelectStm))
            {
               ValuesFromDB = true;
               FileType     = TAB; // mi serve solo per stampare le proprietà DB
            }
            // "Lista di scelta"
            if (fwprintf(file, _T("\n<tr><td align=\"right\" valign=\"top\" bgcolor=\"%s\"><b>%s:</b></td><td>%s"),
                         BgColor.get_name(), gsc_msg(382), SupportFile.get_name()) < 0)
               { GS_ERR_COD = eGSWriteFile; return GS_BAD; }
            
            // inizio sotto-tabella
            if (fwprintf(file, _T("\n<table border=\"1\">")) < 0)
               { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

            pValue = (C_2STR *) ValuesList.get_head();

            switch (FileType)
            {
               case TAB: case REF:
                  while (pValue)
                  {
                     if (fwprintf(file, _T("\n<tr><td>%s</td><td>%s</td></tr>"),
                                  pValue->get_name(), pValue->get_name2()) < 0)
                        { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

                     pValue = (C_2STR *) pValue->get_next();
                  }
                  break;
               case FDF: case DEF:
                  while (pValue)
                  {
                     if (fwprintf(file, _T("\n<tr><td>%s</td></tr>"), pValue->get_name()) < 0)
                        { GS_ERR_COD = eGSWriteFile; return GS_BAD; }
                     pValue = (C_2STR *) pValue->get_next();
                  }
                  break;
            }

            FileType = PrevFileType;

            // Se le righe lette contengono il collegamento ad un DB
            // allora la lista dei valori va letta dal DB
            if (ValuesFromDB)
            {
               if (gsc_C_2STR_LIST_load(ValuesList, ConnStrUDLFile, UdlProperties, 
                                        SelectStm, (presbuf) NULL) == GS_GOOD)
               {
                  // stampo solo i primi 10 record
                  int i = 0, MaxLines = 10;

                  pValue = (C_2STR *) ValuesList.get_head();

                  switch (FileType)
                  {
                     case TAB: case REF:
                        if (fwprintf(file, _T("\n<tr><td>%s</td><td></td></tr>"),
                                     gsc_msg(271)) < 0) // "Valori"
                           { GS_ERR_COD = eGSWriteFile; return GS_BAD; }
                        while (pValue && (i++ < MaxLines))
                        {
                           if (fwprintf(file, _T("\n<tr><td>%s</td><td>%s</td></tr>"),
                                        pValue->get_name(), pValue->get_name2()) < 0)
                              { GS_ERR_COD = eGSWriteFile; return GS_BAD; }

                           pValue = (C_2STR *) pValue->get_next();
                        }
                        if (ValuesList.get_count() > MaxLines)
                           if (fwprintf(file, _T("\n<tr><td>...</td><td>...</td></tr>")) < 0)
                              { GS_ERR_COD = eGSWriteFile; return GS_BAD; }
                        break;
                     case FDF: case DEF:
                        if (fwprintf(file, _T("\n<tr><td>%s</td></tr>"), gsc_msg(271)) < 0) // "Valori"
                           { GS_ERR_COD = eGSWriteFile; return GS_BAD; }
                        while (pValue && (i++ < MaxLines))
                        {
                           if (fwprintf(file, _T("\n<tr><td>%s</td></tr>"), pValue->get_name()) < 0)
                              { GS_ERR_COD = eGSWriteFile; return GS_BAD; }
                           pValue = (C_2STR *) pValue->get_next();
                        }
                        if (ValuesList.get_count() > MaxLines)
                           if (fwprintf(file, _T("\n<tr><td>...</td></tr>")) < 0)
                              { GS_ERR_COD = eGSWriteFile; return GS_BAD; }
                        break;
                  }
               }
            }

            // fine sotto-tabella
            if (fwprintf(file, _T("\n</table></td></tr>")) < 0)
               { GS_ERR_COD = eGSWriteFile; return GS_BAD; }
         }
      }

      // fine tabella
      if (fwprintf(file, _T("\n</table><br><br>")) < 0)
         { GS_ERR_COD = eGSWriteFile; return GS_BAD; }
   }

   return GS_GOOD;
}  


/*********************************************************/
/*.doc C_ATTRIB::Convert2ProviderType         <internal> */
/*+
  Questa funzione converte il tipo, le dimensioni dell' attributo
  con quello compatibile ad un'altra connessione OLE-DB.
  Parametri:
  C_DBCONNECTION *pSrc;    Connessione OLE-DB Sorgente
  C_DBCONNECTION *pDest;   Connessione OLE-DB Destinazione

  Restituisce GS_GOOD in caso di successo, GS_CAN se conversione impossibile
  GS_BAD per altri errori.
-*/  
/*********************************************************/
int C_ATTRIB::Convert2ProviderType(C_DBCONNECTION *pSrc, C_DBCONNECTION *pDest)
{
   C_STRING DestProviderDescr;
   long     DestSize;
   int      Res, DestPrec;

   if ((Res = pSrc->Descr2ProviderDescr(type, len, dec, *pDest,
                                        DestProviderDescr, &DestSize, &DestPrec)) != GS_GOOD)
      return Res;
   gsc_strcpy(type, DestProviderDescr.get_name(), MAX_LEN_FIELDTYPE);
   len = min(DestSize, len);
   
   if (pDest->IsNumericWithDecimals(type) == GS_GOOD)
   {
      // considero almeno una cifra per le unità (il sep. decimale non conta)
      if (dec > len - 1) dec = len - 1;
      if (dec < 0) dec = 0;
   }
   else
      dec = DestPrec;

   return GS_GOOD;
}


/*********************************************************/
/*.doc C_ATTRIB::init_ADOType                <internal> */
/*+
  Questa funzione inizializza il tipo di dato ADO per l'attributo.
  Parametri:
  C_DBCONNECTION *pConn;    Connessione OLE-DB

  Restituisce GS_GOOD in caso di successo altrimenti GS_BAD.
-*/  
/*********************************************************/
int C_ATTRIB::init_ADOType(C_DBCONNECTION *pConn)
{ 
   return (ADOType == adEmpty) ? pConn->ProviderDescr2InfoType(type, &ADOType) : GS_GOOD;
}
int C_ATTRIB::init_TempADOType(C_DBCONNECTION *pOldConn, C_DBCONNECTION *pTempConn)
{ 
   if (TempADOType != adEmpty) return GS_GOOD;
   else
   {
      C_STRING DataDescr;
      int      _Prec;
      long     _Size;

      if (pOldConn->Descr2ProviderDescr(type, len, dec, *pTempConn, DataDescr, &_Size, &_Prec) == GS_BAD)
         return GS_BAD;
      return pTempConn->ProviderDescr2InfoType(DataDescr.get_name(), &TempADOType);
   }
}


/*********************************************************/
/*.doc C_ATTRIB::ParseToString                <internal> */
/*+
  Questa funzione effettua la conversione di un valore in formato
  stringa seguendo le impostazioni di Window.
  Se si è in sessione di lavoro, verranno letti anche entuali liste di valori
  attributi REF e TAB. In caso positivo i valori verranno formattati leggendo
  la corrispondente descrizione:
  Parametri:
  presbuf ValIn;        Valore da convertire
  C_STRING &ValOut;     Risultato
  C_RB_LIST *pColValues; puntatore a lista resbuf dell'entità ((nomecampo - valore) ...)
                         (per risovere i riferimenti a TAB e REF condizionati), default = NULL
  int cls;              Codice classe (per risovere i riferimenti a TAB e REF), default = 0 (non usato)
  int sub;              Codice sottoclasse (per risovere i riferimenti a TAB e REF), default = 0 (non usato)
  int sec;              Codice tab. secondaria (per risovere i riferimenti a TAB e REF), default = 0 (non usato)

  Restituisce GS_GOOD in caso di successo altrimenti GS_BAD.
-*/  
/*********************************************************/
int C_ATTRIB::ParseToString(presbuf ValIn, C_STRING &ValOut,
                            C_RB_LIST *pColValues, int cls, int sub, int sec)
{
   return ParseToString(ValIn, ValOut, (pColValues) ? pColValues->get_head() : NULL,
                        cls, sub, sec);

}
int C_ATTRIB::ParseToString(presbuf ValIn, C_STRING &ValOut,
                            presbuf ColValues, int cls, int sub, int sec)
{
   C_2STR *pDescrFrom_TAB_REF;

   ValOut.clear();

   if (ADOType == adEmpty) { GS_ERR_COD = eGSInvalidArg; return GS_BAD; }

   // Se l'attributo ha un tipo dati non visualizzabile tramite stringa
   if (gsc_DBIsBlob(ADOType) == GS_GOOD)
      return GS_GOOD;

   pDescrFrom_TAB_REF = NULL;
   if (GS_CURRENT_WRK_SESSION && ColValues)
      pDescrFrom_TAB_REF = GS_CURRENT_WRK_SESSION->get_pCacheClsAttribValuesList()->get_Descr(name, ColValues,
                                                                                       GS_CURRENT_WRK_SESSION->get_PrjId(),
                                                                                       cls, sub, sec);
   if (pDescrFrom_TAB_REF) // se il valore è letto da TAB o REF
   {
      ValOut = pDescrFrom_TAB_REF->get_name2();
      return GS_GOOD;
   }

   if (gsc_DBIsBoolean(ADOType) == GS_GOOD)
   {
      if (gsc_conv_Bool(ValIn, ValOut) == GS_BAD) return GS_BAD;
   }
   else
   if (gsc_DBIsChar(ADOType) == GS_GOOD)
   {
      if (ValOut.paste(gsc_rb2str(ValIn)) == NULL) return GS_BAD;
   }
   else
   if (gsc_DBIsCurrency(ADOType) == GS_GOOD)
   {
      if (ValIn->restype != RTNIL && ValIn->restype != RTNONE && ValIn->restype != RTVOID)
         if (gsc_conv_Currency(ValIn, ValOut) == GS_BAD) return GS_BAD;
   }
   else
   if (gsc_DBIsDate(ADOType) == GS_GOOD ||
       gsc_DBIsTimestamp(ADOType) == GS_GOOD)
   {
      if (ValIn->restype != RTNIL && ValIn->restype != RTNONE && ValIn->restype != RTVOID)
         if (gsc_conv_DateTime_2_WinFmt(ValIn, ValOut) == GS_BAD) return GS_BAD;
   }
   else
   if (gsc_DBIsTime(ADOType) == GS_GOOD)
   {
      if (ValIn->restype != RTNIL && ValIn->restype != RTNONE && ValIn->restype != RTVOID)
         if (gsc_conv_Time_2_WinFmt(ValIn, ValOut) == GS_BAD) return GS_BAD;
   }
   else
   if (gsc_DBIsNumericWithDecimals(ADOType) == GS_GOOD)
   {
      if (ValIn->restype != RTNIL && ValIn->restype != RTNONE && ValIn->restype != RTVOID)
         if (gsc_conv_Number(ValIn, ValOut, len, dec) == GS_BAD) return GS_BAD;
   }
   else
   if (gsc_DBIsNumeric(ADOType) == GS_GOOD)
   {
      if (ValIn->restype != RTNIL && ValIn->restype != RTNONE && ValIn->restype != RTVOID)
         if (gsc_conv_Number(ValIn, ValOut) == GS_BAD) return GS_BAD;
   }

   return GS_GOOD;
}


//-----------------------------------------------------------------------//
///////////////////   C_ATTRIB FINE    ////////////////////////////////////
///////////////////   C_CLASS  INIZIO  ////////////////////////////////////
//-----------------------------------------------------------------------//


C_CLASS::C_CLASS():C_NODE()
{
   ptr_secondary_list    = NULL;
   m_BitForUpdateableFAS = GSNoneSetting;
}
C_CLASS::~C_CLASS() 
{
   if (ptr_secondary_list) 
      delete ptr_secondary_list;
   if (ptr_GphInfo()) 
      delete ptr_GphInfo();
}

int    C_CLASS::get_key(void)  { return id.code; }
int    C_CLASS::get_category(void) { return id.category; }
int    C_CLASS::get_type(void) { return id.type; }
TCHAR* C_CLASS::get_name(void) { return id.name; }

int    C_CLASS::get_PrjId(void) { return (id.pPrj) ? ((C_PROJECT *) id.pPrj)->get_key() : 0; }
C_PROJECT *C_CLASS::get_pPrj() { return ((C_PROJECT *) id.pPrj); }


/*********************************************************/
/*.doc C_CLASS::get_Bitmap                    <external> */
/*+
  Funzione che restituisce la bitmap della classe.
  bool LargeSize;    Se vero la dimensione della bitmap sarà di 32x16
                     altrimenti sarà di 16x16
  CBitmap &CBMP;     Oggetto bitmap (output)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_CLASS::get_Bitmap(bool LargeSize, CBitmap &CBMP)
{
   C_COLOR color;
   
   if (ptr_fas()) color = ptr_fas()->color;
   else color.setByLayer();

   return gsc_getClassBitmap(get_category(), get_type(), color, LargeSize, CBMP);
}


/*********************************************************/
/*.doc C_CLASS::get_CompleteName              <external> */
/*+
   Funzione che restituisce il nome completo che, nel caso di 
   sottoclassi, consiste nel nome della classe madre + " - " + nome sottoclasse
   (ad es. "simulazione acqua - pompa")
-*/  
/*********************************************************/
void C_CLASS::get_CompleteName(C_STRING &CompleteName)
{
   if (id.sub_code > 0)
   {
      CompleteName = get_pPrj()->find_class(id.code)->get_name();
      CompleteName += _T(" - ");
   }
   else
      CompleteName.clear();

   CompleteName += id.name;
}


int C_CLASS::ToFile_id(C_STRING &filename)
{  
   TCHAR sez[SEZ_PROFILE_LEN];

   swprintf(sez, SEZ_PROFILE_LEN, _T("%d.%d"), id.code, id.sub_code);
 
   return id.ToFile(filename, sez);
}
int C_CLASS::ToFile_id(C_PROFILE_SECTION_BTREE &ProfileSections)
{  
   TCHAR sez[SEZ_PROFILE_LEN];

   swprintf(sez, SEZ_PROFILE_LEN, _T("%d.%d"), id.code, id.sub_code);
 
   return id.ToFile(ProfileSections, sez);
}

//-----------------------------------------------------------------------//
int C_CLASS::ToFile_attrib_list(C_STRING &filename)
{  
   TCHAR          sez[SEZ_PROFILE_LEN];
   C_ATTRIB_LIST *p_attrib_list;

   // modifico classe in memoria
   if ((p_attrib_list = ptr_attrib_list()) == NULL)
      { GS_ERR_COD = eGSInvClassType; return GS_BAD; }
   swprintf(sez, SEZ_PROFILE_LEN, _T("%d.%d%s"), id.code, id.sub_code, ATTRIB_PROFILE);
  
   return p_attrib_list->ToFile(filename, sez);
}
int C_CLASS::ToFile_attrib_list(C_PROFILE_SECTION_BTREE &ProfileSections)
{  
   TCHAR          sez[SEZ_PROFILE_LEN];
   C_ATTRIB_LIST *p_attrib_list;

   // modifico classe in memoria
   if ((p_attrib_list = ptr_attrib_list()) == NULL)
      { GS_ERR_COD = eGSInvClassType; return GS_BAD; }
   swprintf(sez, SEZ_PROFILE_LEN, _T("%d.%d%s"), id.code, id.sub_code, ATTRIB_PROFILE);
  
   return p_attrib_list->ToFile(ProfileSections, sez);
}
//-----------------------------------------------------------------------//
int C_CLASS::load_attrib_list(TCHAR *filename)
{  
   TCHAR sez[SEZ_PROFILE_LEN];

   if (!ptr_attrib_list() || !ptr_info()) { GS_ERR_COD = eGSInvClassType; return GS_BAD; }
   
   swprintf(sez, SEZ_PROFILE_LEN, _T("%d.%d%s"), id.code, id.sub_code, ATTRIB_PROFILE);
   
   return ptr_attrib_list()->load(filename, sez, ptr_info()->getDBConnection(OLD));
}


/*********************************************************/
/*.doc C_CLASS::restore_attriblist            <internal> */
/*+
  Questa funzione carica la lista degli attributi della classe dai database.
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
  N.B.: Prima di utilizzare questa funzione deve essere caricata la C_ID e
        la C_INFO
-*/  
/*********************************************************/
int C_CLASS::restore_attriblist(void)
{  
   C_STRING       statement, TableRef;
   C_ATTRIB_LIST  *p_attrib_list = ptr_attrib_list();
   C_INFO         *p_info = ptr_info();
   C_DBCONNECTION *pConn;
   _RecordsetPtr  pRs;

   if (!p_info || !p_attrib_list) { GS_ERR_COD = eGSInvClassType; return GS_BAD; }

   p_attrib_list->remove_all();

   // Se si tratta di una tabella collegata non carico i valori di default
   if (gsc_stru_valdef2attriblist(this, (p_info->LinkedTable) ? GS_BAD : GS_GOOD) == GS_BAD)
      return GS_BAD;

   // ottengo la connessione OLE-DB il riferimento alla tabella GS_ATTR
   // per leggere le informazioni NON grafiche degli attributi
   if (get_pPrj()->getAttribsTabInfo(&pConn, &TableRef) == GS_BAD) return GS_BAD;

   statement = _T("SELECT * FROM ");
   statement += TableRef;
   statement += _T(" WHERE CLASS_ID=");
   statement += id.code;
   statement += _T(" AND SUB_CL_ID=");
   statement += id.sub_code;
   statement += _T(" AND SEC_ID=0");
   
   // leggo le righe della tabella senza bloccarla
   if (pConn->OpenRecSet(statement, pRs) == GS_BAD) return GS_BAD;

   if (gsc_NoGraphCharact2attriblist(pRs, p_attrib_list) == GS_BAD)
      { gsc_DBCloseRs(pRs); p_attrib_list->remove_all(); return GS_BAD; }

   if (gsc_DBCloseRs(pRs) == GS_BAD)
      { p_attrib_list->remove_all(); return GS_BAD; }

   ////////////////////////////////////////////////////////////////////////////
   // ottengo la connessione OLE-DB il riferimento alla tabella GS_ATTR_GRAPH
   // per leggere le informazioni grafiche degli attributi
   if (get_pPrj()->getGraphAttribsTabInfo(&pConn, &TableRef) == GS_BAD) return GS_BAD;

   statement = _T("SELECT * FROM ");
   statement += TableRef;
   statement += _T(" WHERE CLASS_ID=");
   statement += id.code;
   statement += _T(" AND SUB_CL_ID=");
   statement += id.sub_code;
   
   // leggo le righe della tabella senza bloccarla
   if (pConn->OpenRecSet(statement, pRs) == GS_BAD) return GS_BAD;

   if (gsc_GraphCharact2attriblist(pRs, p_attrib_list) == GS_BAD)
      { gsc_DBCloseRs(pRs); p_attrib_list->remove_all(); return GS_BAD; }

   if (gsc_DBCloseRs(pRs) == GS_BAD)
      { p_attrib_list->remove_all(); return GS_BAD; }

   return GS_GOOD;
}


/*********************************************************/
/*.doc del_db_carattattr <internal> */
/*+
  Questa funzione cancella la lista delle caratteristiche degli attributi
  della classe nei database
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/  
/*********************************************************/
int C_CLASS::del_db_carattattr(void)
{
   return gsc_del_db_carattattr(id.pPrj, id.code, id.sub_code, 0);
} 


/*********************************************************/
/*.doc carattattr_to_db <internal> */
/*+
  Questa funzione scarica la lista delle caratteristiche degli attributi
  della classe nei database.
  Parametri:
  C_ATTRIB_LIST *p_attrib_list;  lista attributi
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/  
/*********************************************************/
int C_CLASS::carattattr_to_db(C_ATTRIB_LIST *p_attrib_list)
{
   return gsc_carattattr_to_db((C_NODE *) id.pPrj, id.code, id.sub_code, 0,
                               p_attrib_list);
}                  


/*********************************************************/
/*.doc del_db_ClassSet                        <internal> */
/*+
  Questa funzione cancella la classe dal set di classi del progetto
  nel database
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/  
/*********************************************************/
int C_CLASS::del_db_ClassSet(void)
{
   return gsc_del_db_ClassSet((C_NODE *) id.pPrj, id.code);
}


/*********************************************************/
/*.doc C_CLASS::get_default_values <internal> */
/*+
  Questa funzione restituisce una lista di resbuf così composta:
  ((<nome colonna><valore di default>) ... )
  Parametri:
  C_RB_LIST &ColValues;
  ads_name ent;
  oppure
  C_RB_LIST &ColValues;
  C_SELSET *GlobalSelSet;

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_CLASS::get_default_values(C_RB_LIST &ColValues, ads_name ent)
{
   C_SELSET GlobalSelSet;

   if (ent && !ads_name_nil(ent))
      if (GlobalSelSet.add(ent) == GS_BAD) return GS_BAD;

   return get_default_values(ColValues, &GlobalSelSet);
}
int C_CLASS::get_default_values(C_RB_LIST &ColValues, C_SELSET *GlobalSelSet)
{
   C_ATTRIB_LIST *p_attrib_list;
   
   // Ritorna il puntatore alla ATTRIBLIST della classe
   if ((p_attrib_list = ptr_attrib_list()) == NULL)
      { GS_ERR_COD = eGSInvClassType; return NULL; }
  
   if (p_attrib_list->get_StaticDefValues(ColValues) == GS_BAD) return GS_BAD;
   
   // Ciclo per calcolo eventuali valori di default calcolati
   // validazione e ricalcolo dati
   if (p_attrib_list->is_DefCalculated() == GS_GOOD)
      if (CalcValidData(ColValues, INSERT, GlobalSelSet) == GS_BAD) return GS_BAD;

   return GS_GOOD;
}                  


/*********************************************************/
/*.doc C_CLASS::set_exclusive_use             <internal> */
/*+
  Questa funzione setta in GS_CLASS il campo "OWNER" per impedire
  che altri utenti o sessioni di lavoro possano usare la classe.
  Parametri:
  long OwnerCode;     Codice della sessione proprietaria (se negativo è il codice utente)
  int *result;

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_CLASS::set_exclusive_use(long OwnerCode, int *result)
{
   C_DBCONNECTION *pConn;
   C_STRING       statement, ClassesTableRef, ExtractedBy, SavedBy, EmptyStr = GS_EMPTYSTR;
   long           RecordsAffected, nCode;

   if (ptr_id()->abilit != GSUpdateableData)
      { GS_ERR_COD = eGSClassLocked; return GS_BAD; }

   // ricavo connessione e riferimento a tabella GS_CLASS
   if (get_pPrj()->getClassesTabInfo(&pConn, &ClassesTableRef) == GS_BAD)
      return GS_BAD;

   // Correggo la stringa secondo la sintassi SQL
   ExtractedBy = _T("EXTRACTED BY ");
   ExtractedBy += OwnerCode;
   if (pConn->Str2SqlSyntax(ExtractedBy) == GS_BAD) return GS_BAD;
   SavedBy = _T("SAVED BY ");
   SavedBy += OwnerCode;
   if (pConn->Str2SqlSyntax(SavedBy) == GS_BAD) return GS_BAD;
   if (pConn->Str2SqlSyntax(EmptyStr) == GS_BAD) return GS_BAD;

   statement = _T("UPDATE ");
   statement += ClassesTableRef;
   statement += _T(" SET OWNER=");
   statement += OwnerCode;
   statement += _T(" WHERE GS_ID=");
   statement += id.code;
   // non è in accesso esclusivo da parte di un altro proprietario
   statement += _T(" AND (OWNER IS NULL OR OWNER=0 OR OWNER=");
   statement += OwnerCode;
   statement += _T(")");
   // non è in uso
   statement += _T(" AND (LOCKED IS NULL OR LOCKED=");
   statement += EmptyStr;
   // non è in estrazione da parte di un altro proprietario
   statement += _T(" OR LOCKED=");
   statement += ExtractedBy;
   // non è in salvataggio da parte di un altro proprietario
   statement += _T(" OR LOCKED=");
   statement += SavedBy;

   statement += _T(")");

   // verifico che nessun'altra sessione abbia estratto la classe
   if (gsc_is_inarea(get_PrjId(), id.code, &nCode, NULL, &OwnerCode) == GS_BAD ||
       nCode > 0)
   {
      // se "gsc_is_inarea" non ha dato errore ma la classe era già bloccata 
      if (nCode > 0) GS_ERR_COD = eGSSessionsFound;
      else if (nCode < 0) GS_ERR_COD = eGSClassLocked;

      if (result) *result = GS_BAD;
      
      return GS_GOOD;
   }

   if (pConn->ExeCmd(statement, &RecordsAffected) == GS_BAD) return GS_BAD;

   // se è già bloccata da un'altra sessione
   if (RecordsAffected == 0)
      { GS_ERR_COD = eGSClassLocked; if (result) *result = GS_BAD; return GS_GOOD; }

   if (result) *result = GS_GOOD;

   return GS_GOOD;
}


/*********************************************************/
/*.doc C_CLASS::set_share_use <internal> */
/*+
  Questa funzione setta in GS_CLASS il campo "OWNER" e"LOCKED" = NULL
  per condividere la classe.
  La funzione notifica agli altri utenti che la classe non è più in uso esclusivo.

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/  
/*********************************************************/
int C_CLASS::set_share_use(void)
{
   C_STRING       statement, TableRef;
   C_DBCONNECTION *pConn;

   // sblocco eventuali classi simulazioni bloccate dalla sessione di lavoro corrente
   // setto il riferimento di GS_CLASS (<catalogo>.<schema>.<tabella>)
   if (get_pPrj()->getClassesTabInfo(&pConn, &TableRef) == GS_BAD) return GS_BAD;

   statement = _T("UPDATE ");
   statement += TableRef;
   statement += _T(" SET OWNER=NULL, LOCKED=NULL WHERE GS_ID=");
   statement += id.code;

   if (pConn->ExeCmd(statement) == GS_BAD)
   {
      if (GS_ERR_COD == eGSLocked) GS_ERR_COD = eGSClassInUse;
      return GS_BAD;
   }
   
   // "Messaggio GEOsim: La classe <%s> non è più in uso esclusivo."
   TCHAR Msg[256];
   swprintf(Msg, 256, gsc_msg(289), id.name);
   gsc_NotifyWaitForSave(get_PrjId(), id.code, Msg);
   gsc_NotifyWaitForExtraction(get_PrjId(), id.code, Msg);

   return GS_GOOD;
}


/*********************************************************/
/*.doc gsc_get_class_lock                     <internal> */
/*+
  Funzione di ausilio per set_locked_on_extract e set_locked_on_save che
  ottiene attraverso una lettura di un record di GS_CLASS, 
  quali sessioni di lavoro ( o utente se codice negativo)
  e cosa stanno facendo con la classe.
  Parametri:
  C_RB_LIST &ColValues;  Lista di valori letti da GS_CLASS
  C_LONG_LIST &LockedBy; Lista delle sessioni che stanno bloccando la classe
  int       *Mode;       Se = EXCLUSIVEBYANOTHER la classe era bloccata in 
                         accesso esclusivo
  int       *State;      Se = WRK_SESSION_SAVE la classe era bloccata in salvataggio;
                         se = WRK_SESSION_EXTR la classe era bloccata in estrazione;

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int gsc_get_class_lock(int prj, int cls, C_LONG_LIST &LockedBy, int *Mode, int *State)
{
   C_PROJECT      *pPrj;
   C_DBCONNECTION *pConn;
   C_STRING       statement, ClassesTableRef;
   _RecordsetPtr  pRs;
   C_RB_LIST      ColValues;

   LockedBy.remove_all();

   // Cerca progetto nella lista GEOsimAppl::PROJECTS
   if ((pPrj = (C_PROJECT *) GEOsimAppl::PROJECTS.search_key(prj)) == NULL)
      { GS_ERR_COD = eGSInvalidPrjCode; return GS_BAD; }

   // ricavo connessione e riferimento a tabella GS_CLASS
   if (((C_PROJECT *) pPrj)->getClassesTabInfo(&pConn, &ClassesTableRef) == GS_BAD)
      return GS_BAD;

   // seleziono riga della classe in GS_CLASS
   statement = _T("SELECT * FROM ");
   statement += ClassesTableRef;
   statement += _T(" WHERE GS_ID=");
   statement += cls;

   // set di dati NON aggiornabile
   if (pConn->OpenRecSet(statement, pRs) == GS_BAD)
   {
      if (GS_ERR_COD == eGSLocked) GS_ERR_COD = eGSClassInUse;
      return GS_BAD;
   }

   if (gsc_isEOF(pRs) == GS_GOOD)
      { gsc_DBCloseRs(pRs); GS_ERR_COD = eGSInvClassCode; return GS_BAD; }

   if (gsc_DBReadRow(pRs, ColValues) == GS_BAD) 
      { gsc_DBCloseRs(pRs); return GS_BAD; }

   gsc_DBCloseRs(pRs);

   return gsc_get_class_lock(ColValues, LockedBy, Mode, State);
}
int gsc_get_class_lock(C_RB_LIST &ColValues, C_LONG_LIST &LockedBy, int *Mode, int *State)
{
   int     Result = GS_GOOD;
   presbuf p;
   long    WrkSessionCode;

   LockedBy.remove_all();
   *Mode     = 0;
   *State    = 0;

   // verifico se è già bloccata in modo esclusivo
   if ((p = ColValues.CdrAssoc(_T("OWNER"))) == NULL) return GS_BAD;
   if (gsc_rb2Lng(p, &WrkSessionCode) == GS_GOOD && WrkSessionCode > 0)
   {
      LockedBy.add_tail_long(WrkSessionCode);
      *Mode = EXCLUSIVEBYANOTHER;
   }

   if ((p = ColValues.CdrAssoc(_T("LOCKED"))) == NULL) return GS_BAD;

   if (p->restype == RTSTR && gsc_strlen(p->resval.rstring) > 0)
   {
      C_STRING LockedStr(p->resval.rstring);

      LockedStr.alltrim(); // elimino spazi iniziali e finali

      // classe già bloccata in salvataggio
      if (gsc_strstr(LockedStr.get_name(), _T("SAVED BY"), FALSE) && 
          LockedStr.len() > (int) wcslen(_T("SAVED BY")))
      {  // verifico chi sta bloccando
         LockedBy.from_str(p->resval.rstring + wcslen(_T("SAVED BY")), _T(' '));
         *State = WRK_SESSION_SAVE;
      }
      
      if (gsc_strstr(LockedStr.get_name(), _T("EXTRACTED BY"), FALSE) &&
          LockedStr.len() > (int) wcslen(_T("EXTRACTED BY")))
      {  // verifico chi sta bloccando
         LockedBy.from_str(p->resval.rstring + wcslen(_T("EXTRACTED BY")), _T(' '));
         *State = WRK_SESSION_EXTR;
      }
   }

   return GS_GOOD;
}


/*********************************************************/
/*.doc C_CLASS::set_locked_on_extract <internal> */
/*+
  Questa funzione segnala attraverso GS_CLASS che una sessione di lavoro sta
  estraendo la classe.
  Nel caso in cui un'altra sessione stia salvando o estraendo o abbia in
  accesso esclusivo questa classe allora la funzione fallisce.
  Il campo "LOCKED" controlla le operazioni di estrazione e di salvataggio.
  La funzione setta "LOCKED" come di seguito:
  "EXTRACTED BY " + codice della sessione
  Parametri:
  long    OwnerCode;    Codice del proprietario
  int    *result;       GS_BAD nel caso in cui la classe sia già bloccata in salvataggio

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/  
/*********************************************************/
int C_CLASS::set_locked_on_extract(long OwnerCode, int *result)
{
   C_DBCONNECTION *pConn;
   C_STRING       statement, ClassesTableRef, ExtractedBy, SavedBy, EmptyStr = GS_EMPTYSTR;
   C_STRING       NotInExclusiveUseByAnother;
   long           RecordsAffected;

   // ricavo connessione e riferimento a tabella GS_CLASS
   if (get_pPrj()->getClassesTabInfo(&pConn, &ClassesTableRef) == GS_BAD)
      return GS_BAD;

   // Correggo la stringa secondo la sintassi SQL
   ExtractedBy = _T("EXTRACTED BY ");
   ExtractedBy += OwnerCode;
   ExtractedBy += _T(" ");
   if (pConn->Str2SqlSyntax(ExtractedBy) == GS_BAD) return GS_BAD;
   SavedBy = _T("SAVED BY ");
   SavedBy += OwnerCode;
   SavedBy += _T(" ");
   if (pConn->Str2SqlSyntax(SavedBy) == GS_BAD) return GS_BAD;
   if (pConn->Str2SqlSyntax(EmptyStr) == GS_BAD) return GS_BAD;

   // non è in accesso esclusivo da parte di un altro proprietario
   NotInExclusiveUseByAnother = _T("(OWNER IS NULL OR OWNER=0 OR OWNER=");
   NotInExclusiveUseByAnother += OwnerCode;
   NotInExclusiveUseByAnother += _T(")");

   // Provo a settare LOCK in estrazione nel caso:
   // non ci sia LOCK oppure ci sia ma già a carico del proprietario
   // Es. di SQL per settare LOCK della classe 2 alla sessione 1
   // UPDATE [GS_CLASS] SET LOCKED='EXTRACTED BY 1 ' WHERE GS_ID=2 AND
   // (OWNER IS NULL OR OWNER=0 OR OWNER=1) AND
   // (LOCKED IS NULL OR LOCKED='' OR LOCKED='EXTRACTED BY 1 ' OR LOCKED='SAVED BY 1 ')

   statement = _T("UPDATE ");
   statement += ClassesTableRef;
   statement += _T(" SET LOCKED=");
   statement += ExtractedBy;
   statement += _T(" WHERE GS_ID=");
   statement += id.code;
   // non è in accesso esclusivo da parte di un altro proprietario
   statement += _T(" AND ");
   statement += NotInExclusiveUseByAnother;
   // non è in uso
   statement += _T(" AND (LOCKED IS NULL OR LOCKED=");
   statement += EmptyStr;
   // è in estrazione solo da parte del proprietario
   statement += _T(" OR LOCKED=");
   statement += ExtractedBy;
   // è in salvataggio solo da parte del proprietario
   statement += _T(" OR LOCKED=");
   statement += SavedBy;   
   statement += _T(")");

   if (pConn->ExeCmd(statement, &RecordsAffected) == GS_BAD) return GS_BAD;

   if (RecordsAffected == 0)
   {
      C_STRING ConcatenationStrSQLKeyWord, OwnerCodeAtTheMiddle, OwnerCodeStr;

      if (pConn->getConcatenationStrSQLKeyWord(ConcatenationStrSQLKeyWord) == GS_BAD) return GS_BAD;
      OwnerCodeStr = OwnerCode;
      OwnerCodeStr += _T(" ");
      if (pConn->Str2SqlSyntax(OwnerCodeStr) == GS_BAD) return GS_BAD;

      OwnerCodeAtTheMiddle = pConn->get_MultiCharWildcard();
      OwnerCodeAtTheMiddle += _T(" ");
      OwnerCodeAtTheMiddle += OwnerCode;
      OwnerCodeAtTheMiddle += _T(" ");
      OwnerCodeAtTheMiddle += pConn->get_MultiCharWildcard();
      if (pConn->Str2SqlSyntax(OwnerCodeAtTheMiddle) == GS_BAD) return GS_BAD;

      ExtractedBy = _T("EXTRACTED BY ");
      ExtractedBy += pConn->get_MultiCharWildcard();
      if (pConn->Str2SqlSyntax(ExtractedBy) == GS_BAD) return GS_BAD;

      // Provo a settare LOCK in estrazione nel caso:
      // ci sia LOCK in estrazione a carico di altri
      // Es. di SQL per settare LOCK della classe 2 ai proprietari esistenti con in più la sessione 1
      // UPDATE [GS_CLASS] SET LOCKED=LOCKED & ' 1 ' WHERE GS_ID=2 AND
      // (OWNER IS NULL OR OWNER=0 OR OWNER=1) AND
      // (LOCKED LIKE 'EXTRACTED BY *' AND LOCKED NOT LIKE '* 1 *')

      statement = _T("UPDATE ");
      statement += ClassesTableRef;
      statement += _T(" SET LOCKED=LOCKED");
      statement += ConcatenationStrSQLKeyWord;
      statement += OwnerCodeStr;
      statement += _T(" WHERE GS_ID=");
      statement += id.code;
      // non è in accesso esclusivo da parte di un altro proprietario
      statement += _T(" AND ");
      statement += NotInExclusiveUseByAnother;
      // è in estrazione
      statement += _T(" AND (LOCKED LIKE ");
      statement += ExtractedBy;
      // è in uso da altri
      statement += _T(" AND LOCKED NOT LIKE ");
      statement += OwnerCodeAtTheMiddle;
      statement += _T(")");

      if (pConn->ExeCmd(statement, &RecordsAffected) == GS_BAD) return GS_BAD;

      if (RecordsAffected == 0)
      {
         // Provo a settare LOCK in estrazione nel caso:
         // ci sia LOCK in estrazione a carico del proprietario e di altri
         // Es. di SQL per settare LOCK della classe 2 ai proprietari esistenti con in più la sessione 1
         // UPDATE [GS_CLASS] SET LOCKED=LOCKED WHERE GS_ID=2 AND 
         // (OWNER IS NULL OR OWNER=0 OR OWNER=1) AND
         // (LOCKED LIKE 'EXTRACTED BY *' AND LOCKED LIKE '* 1 *')

         statement = _T("UPDATE ");
         statement += ClassesTableRef;
         statement += _T(" SET LOCKED=LOCKED");
         statement += _T(" WHERE GS_ID=");
         statement += id.code;
         // non è in accesso esclusivo da parte di un altro proprietario
         statement += _T(" AND ");
         statement += NotInExclusiveUseByAnother;
         // è in estrazione
         statement += _T(" AND (LOCKED LIKE ");
         statement += ExtractedBy;
         // è in uso da altri
         statement += _T(" AND LOCKED LIKE ");
         statement += OwnerCodeAtTheMiddle;
         statement += _T(")");

         if (pConn->ExeCmd(statement, &RecordsAffected) == GS_BAD) return GS_BAD;

         if (RecordsAffected == 0)
            { GS_ERR_COD = eGSClassLocked; if (result) *result = GS_BAD; return GS_GOOD; }
      }
   }

   if (result) *result = GS_GOOD;

   return GS_GOOD;
}


/*********************************************************/
/*.doc C_CLASS::set_locked_on_save <internal> */
/*+
  Questa funzione segnala attraverso GS_CLASS che una sessione di lavoro sta
  salvando la classe.
  Nel caso in cui un'altra sessione stia salvando o estraendo o abbia in
  accesso esclusivo questa classe allora la funzione fallisce.
  Il campo "LOCKED" controlla le operazioni di estrazione e di salvataggio.
  La funzione setta "LOCKED" come di seguito:
  "SAVED BY " + codice della sessione
  La funzione opzionalmnete restituisce il valore della colonna LAST_ENT da usare 
  come ultimo codice dell'entità della classe.
  Parametri:
  long OwnerCode;     Codice del proprietario
  int  *result;       GS_BAD nel caso in cui la classe sia già bloccata in estrazione
  long *LastEnt;      Opzionale, output. Codice ultima entità della classe.
                      Settato solo se l'operazione di lock ha avuto successo(default = NULL)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/  
/*********************************************************/
int C_CLASS::set_locked_on_save(long OwnerCode, int *result, long *LastEnt)
{
   C_DBCONNECTION *pConn;
   C_STRING       statement, ClassesTableRef, ExtractedBy, SavedBy, EmptyStr = GS_EMPTYSTR;
   C_STRING       NotInExclusiveUseByAnother;
   long           RecordsAffected;

   // ricavo connessione e riferimento a tabella GS_CLASS
   if (get_pPrj()->getClassesTabInfo(&pConn, &ClassesTableRef) == GS_BAD)
      return GS_BAD;

   // Correggo la stringa secondo la sintassi SQL
   ExtractedBy = _T("EXTRACTED BY ");
   ExtractedBy += OwnerCode;
   ExtractedBy += _T(" ");
   if (pConn->Str2SqlSyntax(ExtractedBy) ==  GS_BAD) return GS_BAD;
   SavedBy = _T("SAVED BY ");
   SavedBy += OwnerCode;
   SavedBy += _T(" ");
   if (pConn->Str2SqlSyntax(SavedBy) == GS_BAD) return GS_BAD;
   if (pConn->Str2SqlSyntax(EmptyStr) == GS_BAD) return GS_BAD;

   // non è in accesso esclusivo da parte di un altro proprietario
   NotInExclusiveUseByAnother = _T("(OWNER IS NULL OR OWNER=0 OR OWNER=");
   NotInExclusiveUseByAnother += OwnerCode;
   NotInExclusiveUseByAnother += _T(")");

   // Provo a settare LOCK in salvataggio nel caso:
   // non ci sia LOCK oppure ci sia ma già a carico del proprietario
   // Es. di SQL per settare LOCK della classe 2 alla sessione 1
   // UPDATE [GS_CLASS] SET LOCKED='SAVED BY 1' WHERE GS_ID=2 AND 
   // (OWNER IS NULL OR OWNER=0 OR OWNER=1) AND
   // (LOCKED IS NULL OR LOCKED='' OR LOCKED='EXTRACTED BY 1 ' OR LOCKED='SAVED BY 1 ')

   statement = _T("UPDATE ");
   statement += ClassesTableRef;
   statement += _T(" SET LOCKED=");
   statement += SavedBy;
   statement += _T(" WHERE GS_ID=");
   statement += id.code;
   // non è in accesso esclusivo da parte di un altro proprietario
   statement += _T(" AND ");
   statement += NotInExclusiveUseByAnother;
   statement += _T(" AND (LOCKED IS NULL OR LOCKED=");
   statement += EmptyStr;
   // non è in estrazione da parte di un altro proprietario
   statement += _T(" OR LOCKED=");
   statement += ExtractedBy;
   // non è in salvataggio da parte di un altro proprietario
   statement += _T(" OR LOCKED=");
   statement += SavedBy;
   statement += _T(")");

   if (pConn->ExeCmd(statement, &RecordsAffected) == GS_BAD) return GS_BAD;

   // se è già bloccata da un'altra sessione
   if (RecordsAffected == 0)
      { GS_ERR_COD = eGSClassLocked; if (result) *result = GS_BAD; return GS_GOOD; }

   if (LastEnt) // Leggo ultimo codice entità usato
   {
      _RecordsetPtr pRs;
      C_RB_LIST     ColValues;
      presbuf       p;

      // seleziono riga del progetto in GS_PRJ
      statement = _T("SELECT LAST_ENT FROM ");
      statement += ClassesTableRef;
      statement += _T(" WHERE GS_ID=");
      statement += id.code;

      // set di dati NON aggiornabile
      if (pConn->OpenRecSet(statement, pRs) == GS_BAD)
      {
         if (result) *result = GS_BAD;
         return GS_BAD;
      }
      if (gsc_DBReadRow(pRs, ColValues) == GS_BAD) 
         { gsc_DBCloseRs(pRs); return GS_BAD; }
      gsc_DBCloseRs(pRs);

      if ((p = ColValues.CdrAssoc(_T("LAST_ENT"))))
      {
         if (gsc_rb2Lng(p, LastEnt) == GS_BAD) *LastEnt = 0;
      }
      else *LastEnt = 0;
   }

   if (result) *result = GS_GOOD;

   return GS_GOOD;
}


/*********************************************************/
/*.doc gs_share_class                         <external> */
/*+
  Questa funzione LISP sblocca completamente una classe di GEOsim.
  Attraverso il campo "LOCKED" e "OWNER" di GS_CLASS e i file DWK.
  Parametri:
  (<prj><cls>)

  Restituisce RTNORM in caso di successo altrimenti restituisce RTERROR. 
-*/  
/*********************************************************/
int gs_share_class(void)
{
   presbuf  arg = acedGetArgs();
   int      Prj, Cls;
   C_CLASS  *pCls;
   C_STRING statement, TableRef;

   acedRetNil();
   if (gsc_superuser() != GS_GOOD)
      { GS_ERR_COD = eGSOpNotAble; return RTERROR; } // non è un SUPER USER

   // Legge nella lista dei parametri: progetto e classe
   if (arg_to_prj_cls_sub(&arg, &Prj, &Cls) == GS_BAD) return RTERROR;

   if ((pCls = gsc_find_class(Prj, Cls)) == NULL) return RTERROR;

   if (pCls->set_share_use() == GS_BAD) return RTERROR;

   // sblocco i disegni della classe
   pCls->DWGsUnlock();

   acedRetT();

   return RTNORM;
}


/*********************************************************/
/*.doc C_CLASS::set_unlocked                  <internal> */
/*+
  Questa funzione segnala attraverso GS_CLASS che una sessione di lavoro
  ha terminato l'operazione di estrazione o di salvataggio sulla classe.
  Il campo "LOCKED" controlla le operazioni di estrazione e di salvataggio.
  La funzione setta "LOCKED" come di seguito:
  Se esistono altre sessioni che stanno estraendo, elimina il codice della sessione 
  dalla lista, altrimenti svuota il campo LOCKED.
  Parametri:
  long   OwnerCode;     Codice della sessione proprietaria 
                        (se = 0 significa per tutte le sessioni)
  int    Notify;        Flag di notifica in rete (default = GS_GOOD)
  bool   UpdateLastEnt; Flag, se = true aggiorna LAST ent in GS_CLASS leggendolo
                        da OldLastId della C_INFO (default = false)
  bool UpdateLastSaveDate; Flag, se = true aggiorna il campo LAST_SAVE_DATE in GS_CLASS
                           con la data e l'ora corrente (default = false)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/  
/*********************************************************/
int C_CLASS::set_unlocked(long OwnerCode, int Notify, bool UpdateLastEnt, bool UpdateLastSaveDate)
{
   C_DBCONNECTION *pConn;
   C_STRING       statement, ClassesTableRef;
   long           RecordsAffected;

   // ricavo connessione e riferimento a tabella GS_CLASS
   if (get_pPrj()->getClassesTabInfo(&pConn, &ClassesTableRef) == GS_BAD)
      return GS_BAD;

   if (OwnerCode == 0) // sblocco la classe da tutte le sessioni
   {
      statement = _T("UPDATE ");
      statement += ClassesTableRef;
      statement += _T(" SET LOCKED=NULL");
      if (UpdateLastEnt && get_category() != CAT_EXTERN && ptr_info()) // Aggiorno LAST_ENT
      {
         statement += _T(", LAST_ENT=");
         statement += ptr_info()->OldLastId;
      }
      if (UpdateLastSaveDate) // Aggiorno LAST_SAVE_DATE
      {
         C_STRING CreationDateTime;

         // setto la data e l'ora di creazione
         gsc_current_DateTime(CreationDateTime);
         // Correggo la stringa "time-stamp" secondo la sintassi SQL 
         pConn->Str2SqlSyntax(CreationDateTime, pConn->ptr_DataTypeList()->search_Type(adDBTimeStamp, FALSE));

         statement += _T(", LAST_SAVE_DATE=");
         statement += CreationDateTime;
      }
      statement += _T(" WHERE GS_ID=");
      statement += id.code;

      if (pConn->ExeCmd(statement, &RecordsAffected) == GS_BAD) return GS_BAD;
   }
   else // sblocco la classe solo da una sessione
   {
      C_STRING ExtractedBy, SavedBy, EmptyStr = GS_EMPTYSTR, NotInExclusiveUseByAnother;

      // Correggo la stringa secondo la sintassi SQL
      ExtractedBy = _T("EXTRACTED BY ");
      ExtractedBy += OwnerCode;
      ExtractedBy += _T(" ");
      if (pConn->Str2SqlSyntax(ExtractedBy) == GS_BAD) return GS_BAD;
      SavedBy = _T("SAVED BY ");
      SavedBy += OwnerCode;
      SavedBy += _T(" ");
      if (pConn->Str2SqlSyntax(SavedBy) == GS_BAD) return GS_BAD;
      if (pConn->Str2SqlSyntax(EmptyStr) == GS_BAD) return GS_BAD;

      // non è in accesso esclusivo da parte di un altro proprietario
      NotInExclusiveUseByAnother = _T("(OWNER IS NULL OR OWNER=0 OR OWNER=");
      NotInExclusiveUseByAnother += OwnerCode;
      NotInExclusiveUseByAnother += _T(")");

      // Provo a rimuovere LOCK nel caso:
      // non ci sia LOCK oppure ci sia ma già a carico del proprietario
      // Es. di SQL per settare LOCK della classe 2 alla sessione 1
      // UPDATE [GS_CLASS] SET LOCKED=NULL WHERE GS_ID=2 AND
      // (OWNER IS NULL OR OWNER=0 OR OWNER=1) AND
      // (LOCKED IS NULL OR LOCKED='' OR LOCKED='EXTRACTED BY 1 ' OR LOCKED='SAVED BY 1 ')

      statement = _T("UPDATE ");
      statement += ClassesTableRef;
      statement += _T(" SET LOCKED=NULL");
      if (UpdateLastEnt && get_category() != CAT_EXTERN && ptr_info()) // Aggiorno LAST_ENT
      {
         statement += _T(", LAST_ENT=");
         statement += ptr_info()->OldLastId;
      }
      if (UpdateLastSaveDate) // Aggiorno LAST_SAVE_DATE
      {
         C_STRING CreationDateTime;

         // setto la data e l'ora di creazione
         gsc_current_DateTime(CreationDateTime);
         // Correggo la stringa "time-stamp" secondo la sintassi SQL 
         pConn->Str2SqlSyntax(CreationDateTime, pConn->ptr_DataTypeList()->search_Type(adDBTimeStamp, FALSE));

         statement += _T(", LAST_SAVE_DATE=");
         statement += CreationDateTime;
      }
      statement += _T(" WHERE GS_ID=");
      statement += id.code;
      // non è in accesso esclusivo da parte di un altro proprietario
      statement += _T(" AND ");
      statement += NotInExclusiveUseByAnother;
      // non è in uso
      statement += _T(" AND (LOCKED IS NULL OR LOCKED=");
      statement += EmptyStr;
      // non è in estrazione da parte di un altro proprietario
      statement += _T(" OR LOCKED=");
      statement += ExtractedBy;
      // non è in salvataggio da parte di un altro proprietario
      statement += _T(" OR LOCKED=");
      statement += SavedBy;
      statement += _T(")");

      if (pConn->ExeCmd(statement, &RecordsAffected) == GS_BAD) return GS_BAD;

      if (RecordsAffected == 0)
      {
         C_STRING WrkSessionCodeStr, BlankStr, OwnerCodeAtTheMiddle, ReplaceSQLSyntax;
         C_STRING DBMSName;

         WrkSessionCodeStr = _T(" ");
         WrkSessionCodeStr += OwnerCode;
         WrkSessionCodeStr += _T(" ");
         if (pConn->Str2SqlSyntax(WrkSessionCodeStr) == GS_BAD) return GS_BAD;

         BlankStr = _T(" ");
         if (pConn->Str2SqlSyntax(BlankStr) == GS_BAD) return GS_BAD;

         OwnerCodeAtTheMiddle = pConn->get_MultiCharWildcard();
         OwnerCodeAtTheMiddle += _T(" ");
         OwnerCodeAtTheMiddle += OwnerCode;
         OwnerCodeAtTheMiddle += _T(" ");
         OwnerCodeAtTheMiddle += pConn->get_MultiCharWildcard();
         if (pConn->Str2SqlSyntax(OwnerCodeAtTheMiddle) == GS_BAD) return GS_BAD;
         
         DBMSName = pConn->get_DBMSName();
         // Mi ricavo la sintassi della funzione REPLACE
         // che ACCESS non supporta e che quindi va scritta in modo diverso.
         if (DBMSName.at(ACCESS_DBMSNAME, FALSE) != NULL) // è in SQL Jet (Microsoft Access)
         {
            // MID(Str, 1, INSTR(Str, 'StrToSearch') - 1) 
            //     + 'StrReplaceWith'
            //     + MID(Str, 
            //           INSTR(Str, 'StrToSearch') + LEN('StrToSearch'), 
            //           LEN(Str) - INSTR(Str, 'StrToSearch') - LEN('StrToSearch') + 1
            //           )
            ReplaceSQLSyntax = _T("MID(LOCKED,1,INSTR(LOCKED,");
            ReplaceSQLSyntax += WrkSessionCodeStr;
            ReplaceSQLSyntax += _T(")-1) & ");
            ReplaceSQLSyntax += BlankStr;
            ReplaceSQLSyntax += _T(" & MID(LOCKED,INSTR(LOCKED,");
            ReplaceSQLSyntax += WrkSessionCodeStr;
            ReplaceSQLSyntax += _T(")+LEN(");
            ReplaceSQLSyntax += WrkSessionCodeStr;
            ReplaceSQLSyntax += _T("),LEN(LOCKED)-INSTR(LOCKED,");
            ReplaceSQLSyntax += WrkSessionCodeStr;
            ReplaceSQLSyntax += _T(")-LEN(");
            ReplaceSQLSyntax += WrkSessionCodeStr;
            ReplaceSQLSyntax += _T(")+1)");
         }
         else
         {
            ReplaceSQLSyntax = _T("REPLACE(LOCKED,");
            ReplaceSQLSyntax += WrkSessionCodeStr;
            ReplaceSQLSyntax += _T(",");
            ReplaceSQLSyntax += BlankStr;
            ReplaceSQLSyntax += _T(")");
         }

         // Provo a rimuovere LOCK nel caso:
         // ci sia LOCK in estrazione a carico del proprietario e di altri
         // Es. di SQL per settare OWNER e LOCK della classe 2 alla sessione 1
         // UPDATE [GS_CLASS] SET LOCKED=REPLACE(LOCKED, ' 1 ', ' ') WHERE GS_ID=2 AND
         // (OWNER IS NULL OR OWNER=0 OR OWNER=1) AND
         // (LOCKED<>'EXTRACTED BY 1 ' AND LOCKED LIKE 'EXTRACTED BY *' AND LOCKED LIKE '* 1 *')

         statement = _T("UPDATE ");
         statement += ClassesTableRef;
         statement += _T(" SET LOCKED=");
         statement += ReplaceSQLSyntax;
         if (UpdateLastEnt && get_category() != CAT_EXTERN && ptr_info()) // Aggiorno LAST_ENT
         {
            statement += _T(", LAST_ENT=");
            statement += ptr_info()->OldLastId;
         }
         if (UpdateLastSaveDate) // Aggiorno LAST_SAVE_DATE
         {
            C_STRING CreationDateTime;

            // setto la data e l'ora di creazione
            gsc_current_DateTime(CreationDateTime);
            // Correggo la stringa "time-stamp" secondo la sintassi SQL 
            pConn->Str2SqlSyntax(CreationDateTime, pConn->ptr_DataTypeList()->search_Type(adDBTimeStamp, FALSE));

            statement += _T(", LAST_SAVE_DATE=");
            statement += CreationDateTime;
         }

         statement += _T(" WHERE GS_ID=");
         statement += id.code;
         // non è in accesso esclusivo da parte di un altro proprietario
         statement += _T(" AND ");
         statement += NotInExclusiveUseByAnother;
         // non è in estrazione da parte del proprietario (per proteggersi dal fatto che nel
         // frattempo qualcuno può aver rilasciato il proprio lock)
         statement += _T(" AND (LOCKED<>");
         statement += ExtractedBy;

         ExtractedBy = _T("EXTRACTED BY ");
         ExtractedBy += pConn->get_MultiCharWildcard();
         if (pConn->Str2SqlSyntax(ExtractedBy) == GS_BAD) return GS_BAD;

         // non è in salvataggio da parte di un altro proprietario
         statement += _T(" AND LOCKED LIKE ");
         statement += ExtractedBy;
         statement += _T(" AND LOCKED LIKE ");
         statement += OwnerCodeAtTheMiddle;
         statement += _T(")");

         if (pConn->ExeCmd(statement, &RecordsAffected) == GS_BAD) return GS_BAD;
      }
   }

   // se è già bloccata da un'altra sessione
   if (RecordsAffected == 0)
   { 
      if (GS_CURRENT_WRK_SESSION && GS_CURRENT_WRK_SESSION->get_id() == OwnerCode)
         GS_CURRENT_WRK_SESSION->AddClsToUnlockWaitingClsList(id.code);

      GS_ERR_COD = eGSClassLocked;
      return GS_BAD;
   }

   // Aggiorno LAST_ENT per le sottoclassi
   if (UpdateLastEnt && get_category() == CAT_EXTERN)
   {
      _RecordsetPtr pRs;
      C_RB_LIST     ColValues;

      ColValues << acutBuildList(RTLB, RTLB, RTSTR, _T("LAST_ENT"), RTNIL, RTLE, RTLE, 0);

      statement = _T("SELECT LAST_ENT FROM ");
      statement += ClassesTableRef;
      statement += _T(" WHERE GS_ID=");
      statement += id.code;
      statement += _T(" AND SUB_GS_ID>0 ORDER BY SUB_GS_ID");

      // leggo le riga della tabella per aggiornare LAST_ENT
      if (pConn->ExeCmd(statement, pRs, adOpenDynamic, adLockOptimistic) == GS_BAD) return GS_BAD;

      C_SUB *pSub = (C_SUB *) ptr_sub_list()->get_head();
      while (gsc_isEOF(pRs) == GS_BAD && pSub)
      {
         if (pSub->ptr_info())
         {
            ColValues.CdrAssocSubst(_T("LAST_ENT"), pSub->ptr_info()->OldLastId);
            gsc_DBUpdRow(pRs, ColValues); // non controllo esito tanto ormai ho sbloccato...
         }

         pSub = (C_SUB *) ptr_sub_list()->get_next();
         gsc_Skip(pRs);
      }
      gsc_DBCloseRs(pRs);
   }

   if (Notify == GS_GOOD)
   {
      // "Messaggio GEOsim: La sessione n°.%ld ha sbloccato la classe <%s>."
      TCHAR Msg[256];
      get_CompleteName(statement);
      swprintf(Msg, 256, gsc_msg(273), OwnerCode, statement);
      gsc_NotifyWaitForSave(id.pPrj->get_key(), id.code, Msg);
      gsc_NotifyWaitForExtraction(id.pPrj->get_key(), id.code, Msg);       
   }

   return GS_GOOD;
}


/*********************************************************/
/*.doc C_CLASS::is_inExclusiveUse             <internal> */
/*+
  Questa funzione segnala attraverso GS_CLASS se una sessione di lavoro sta 
  bloccando in modo esclusivo la classe.
  Parametri:
  long *SessionCode; Codice della sessione proprietaria (0 se nessuna sessione)

  Restituisce GS_GOOD in caso di successo sia bloccata in modo esclusivo 
  altrimenti restituisce GS_BAD. 
-*/  
/*********************************************************/
int C_CLASS::is_inExclusiveUse(long *SessionCode)
{
   int         Mode, State;
   C_LONG_LIST LockedBy;

   if (gsc_get_class_lock(get_PrjId(), id.code, LockedBy, &Mode, &State) == GS_GOOD &&
       Mode == EXCLUSIVEBYANOTHER &&       // se è già bloccata in modo esclusivo
       LockedBy.get_count() > 0)
   {
      *SessionCode = ((C_LONG*) LockedBy.get_head())->get_id();
      return GS_GOOD;
   }
   else
      return GS_BAD;
}


/*********************************************************/
/*.doc C_CLASS::is_DynSegmentationSupported   <internal> */
/*+
  Questa funzione ritorna se la classe supporta la segmentazione dinamica.

  Restituisce true in caso di successo altrimenti restituisce false.
-*/  
/*********************************************************/
bool C_CLASS::is_DynSegmentationSupported(void)
{
   if (get_category() == CAT_EXTERN)
   {
      C_SUB *pSub = (C_SUB *) ptr_sub_list()->get_head();

      while (pSub)
      {
         if (pSub->is_DynSegmentationSupported()) return true; // basta una sola sottoclasse
         pSub = (C_SUB *) ptr_sub_list()->get_next();
      }

      return false;
   }

   if (ptr_fas() == NULL) return false;

   C_SINTH_SEC_TAB_LIST SinthSecList;

   if (get_pPrj()->getSinthClsSecondaryTabList(id.code, id.sub_code, SinthSecList) == GS_BAD) return false;
   SinthSecList.FilterOnDynSegmentationSupportedOnly();

   return (SinthSecList.get_count() > 0) ? true : false;
}

      
/*********************************************************/
/*.doc del_tab_class <internal> */
/*+
  Questa funzione cancella la tabella della classe o sottoclasse.

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/  
/*********************************************************/
int C_CLASS::del_tab_class(void)
{
   C_INFO         *p_info = ptr_info();
   C_DBCONNECTION *pConn;

   if (!p_info) { GS_ERR_COD = eGSInvClassType; return GS_BAD; }

   // Se si tratta di una tabella collegata non posso cancellare la tabella
   if (p_info->LinkedTable) return GS_GOOD;

   // ricavo connessione OLE-DB
   if ((pConn = p_info->getDBConnection(OLD)) == NULL) return GS_GOOD;
   if (pConn->ExistTable(p_info->OldTableRef) == GS_BAD) return GS_GOOD;

   // cancello la tabella
   if (pConn->DelTable(p_info->OldTableRef.get_name()) == GS_BAD) return GS_BAD;

   if (id.view_enabled == true) // classe che ha delle viste associate
      gsc_del_pgview(this);
   
   return GS_GOOD;
}

  
/*********************************************************/
/*.doc default_to_db <internal> */
/*+
  Questa funzione modifica i valori di default della classe.
  Parametri:
  C_ATTRIB_LIST *p_attrib_list;  lista attributi
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/  
/*********************************************************/
int C_CLASS::default_to_db(C_ATTRIB_LIST *p_attrib_list)
{
   C_INFO         *p_info = ptr_info();
   C_DBCONNECTION *pConn;

   if (!p_attrib_list) { GS_ERR_COD = eGSInvalidArg; return GS_BAD; }
   if (!p_info) { GS_ERR_COD = eGSInvClassType; return GS_BAD; }

   // Se si tratta di una tabella collegata non posso cambiare i valori di default
   if (p_info->LinkedTable) { GS_ERR_COD = eGSClassLocked; return GS_BAD; }

   // ricavo connessione OLE-DB
   if ((pConn = p_info->getDBConnection(OLD)) == NULL) return GS_BAD;
   if (gsc_default_to_db(pConn, p_info->OldTableRef.get_name(), p_info->key_attrib.get_name(), 
                         ptr_attrib_list(), p_attrib_list) == GS_BAD)
      return GS_BAD;
    
   return GS_GOOD;   
}

  
/*********************************************************/
/*.doc create_tab <internal> */
/*+
  Questa funzione crea la tabella della classe.
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
  N.B.: per la riuscita della funzione il direttorio della tabella
        non deve esistere !!!
-*/  
/*********************************************************/
int C_CLASS::create_tab(void)
{
   C_STRING PrimaryKey;

   // verifico abilitazione
   if (gsc_check_op(opCreateClass) == GS_BAD) return GS_BAD;

   if (!ptr_info() || !ptr_attrib_list()) { GS_ERR_COD = eGSInvClassType; return GS_BAD; }

   // Se si tratta di una tabella collegata
   if (ptr_info()->LinkedTable)
   {
      // Verifico la sua esistenza
      if (ptr_info()->getDBConnection(OLD)->ExistTable(ptr_info()->OldTableRef) == GS_BAD)
         { GS_ERR_COD = eGSTableNotExisting; return GS_BAD; }
      return GS_GOOD;
   }
   else
   {
      if (ptr_info()->get_PrimaryKeyName(PrimaryKey) == GS_BAD) return GS_BAD;
      // creo tabella
      return gsc_create_tab(ptr_info()->OldTableRef, ptr_info()->getDBConnection(OLD),
                            ptr_attrib_list(), PrimaryKey, ptr_info()->key_attrib);
   }
}   
   

/*********************************************************/
/*.doc modi_tab                               <internal> */
/*+
  Questa funzione modifica la struttura della tabella della classe.
  La variabile globale GS_RESBUF deve contenere una lista così composta:
  ((definizione nuova struttura) (struct link list))
  Vedere funzione gsc_updstruct e gs_alloc_mod_stru().
  Parametri:
  C_ATTRIB_LIST *p_attrib_list; nuova struttura
  presbuf       link;           lista di link con vecchia struttura
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_CLASS::modi_tab(C_ATTRIB_LIST *p_attrib_list, presbuf link)
{
   C_INFO         *p_info = ptr_info();
   C_RB_LIST      Values, def_stru;
   C_ATTRIB       *p_attrib;
   C_STRING       value, temp_val, dir;
   C_DBCONNECTION *pConn;
   int            result;
   
   // verifico abilitazione
   if (gsc_check_op(opModClass) == GS_BAD) return GS_BAD;
   if (id.abilit != GSUpdateableData) { GS_ERR_COD = eGSClassLocked; return GS_BAD; }

   if (!p_info || ! ptr_attrib_list()) { GS_ERR_COD = eGSInvClassType; return GS_BAD; }

   // ricavo connessione OLE-DB
   if ((pConn = p_info->getDBConnection(OLD)) == NULL) return GS_BAD;

   // Se si tratta di una tabella collegata non posso cambiare la struttura
   if (p_info->LinkedTable) { GS_ERR_COD = eGSClassLocked; return GS_BAD; }

   if (p_attrib_list->is_empty() == TRUE || link == NULL)
      { GS_ERR_COD = eGSInvalidArg; return GS_BAD; } 

   // creo la lista dei valori da inserire nelle colonne della nuova tabella
   if ((Values << gsc_rblistcopy(link)) == NULL) return GS_BAD;
   // elimino l'ultima parentesi chiusa
   if (Values.remove_tail() == GS_BAD) return GS_BAD;

   p_attrib = (C_ATTRIB *) p_attrib_list->get_head();
   while (p_attrib)
   {
      if (gsc_assoc(p_attrib->get_name(), link) == NULL)
      { // inserisco i valori di default per le nuove colonne
         if (p_attrib->def)
         {
            if ((Values += acutBuildList(RTLB,
                                         RTSTR, p_attrib->get_name(), 0)) == GS_BAD)
               return GS_BAD;

            if (p_attrib->def->restype == RTSTR)
            {
               if ((value.paste(gsc_rb2str(p_attrib->def))) == NULL) return GS_BAD;
               // Correggo la stringa secondo la sintassi SQL 
               if (pConn->Str2SqlSyntax(value) == GS_BAD) return GS_BAD;
               if ((Values += acutBuildList(RTSTR, value.get_name(), 0)) == GS_BAD)
                  return GS_BAD;
            }
            else
               if ((Values += gsc_copybuf(p_attrib->def)) == GS_BAD) return GS_BAD;

            if ((Values += acutBuildList(RTLE, 0)) == GS_BAD) return GS_BAD;
         }
      }
      p_attrib = (C_ATTRIB *) p_attrib->get_next();
   }
   if ((Values += acutBuildList(RTLE, 0)) == NULL) return GS_BAD;
   
   // ricavo la struttura della nuova tabella
   if ((def_stru << p_attrib_list->to_rb_db()) == NULL) return GS_BAD;
   
   // blocco la classe in modo esclusivo GS_CLASS usando come semaforo
   // il codice della sessione attiva, se esistente, altrimenti il codice utente 
   long OwnerCode = (GS_CURRENT_WRK_SESSION) ? GS_CURRENT_WRK_SESSION->get_id() : GEOsimAppl::GS_USER.code * -1;
   if (set_exclusive_use(OwnerCode, &result) == GS_BAD || result == GS_BAD)
      return GS_BAD;
                    
   // modifico struttura tabella                                  
   if (pConn->UpdStruct(p_info->OldTableRef.get_name(), def_stru.get_head(), Values.get_head()) == GS_BAD)
   {
      set_share_use(); // sblocco classe
      return GS_BAD;
   }
   // devo reindicizzare per ripristinare la chiave primaria
   if (reindexTab() == GS_BAD)
   {
      set_share_use(); // sblocco classe
      return GS_BAD;
   }

   if (set_share_use() == GS_BAD) return GS_BAD; // sblocco classe

   return GS_GOOD;
}   


/*********************************************************/
/*.doc ins_cls_to_gs_class <internal> */
/*+
  Questa funzione inserisce una nuova classe in GS_CLASS.
  La lista resbuf viene modificata cosi come la C_ID della classe.
  Parametri:
  C_RB_LIST &ColValues;       lista colonna-valore
  
  Restituisce codice classe in caso di successo altrimenti restituisce GS_BAD. 
-*/  
/*********************************************************/
int C_CLASS::ins_cls_to_gs_class(C_RB_LIST &ColValues)
{
   C_DBCONNECTION *pConn;
   presbuf        p;
   TCHAR          name[MAX_LEN_CLASSNAME];
   C_STRING       TableRef;
   int            new_code, n_test = 0, gs_id, sub_gs_id;
   C_INFO         *p_info = ptr_info();
                                 
   // setto il riferimento di GS_CLASS (<catalogo>.<schema>.<tabella>)
   if (get_pPrj()->getClassesTabInfo(&pConn, &TableRef) == GS_BAD)
      return GS_BAD;
      
   if ((p = ColValues.CdrAssoc(_T("UDL_FILE"))) != NULL)
   {
      if (ptr_info() && p->restype == RTSTR && wcslen(p->resval.rstring) > 0)
      {  // traduco dir relativo in dir assoluto
         C_STRING Path(p->resval.rstring);

         if (gsc_path_exist(Path) == GS_GOOD)
            if (gsc_drive2nethost(Path) == GS_BAD) return GS_BAD;
         if (Path.len() > ACCESS_MAX_LEN_FIELDCHAR)
            { GS_ERR_COD = eGSStringTooLong; return GS_BAD; }
         if (gsc_RbSubst(p, Path.get_name()) == GS_BAD) return GS_BAD;
      }
      else
         if (gsc_RbSubst(p, GS_EMPTYSTR) == GS_BAD) return GS_BAD;

      if ((p = ColValues.CdrAssoc(_T("UDL_PROP"))) != NULL)
      {
         if (ptr_info() && p->restype == RTSTR && wcslen(p->resval.rstring) > 0)
         {
            C_STRING AbsUDLProperties(p->resval.rstring);

            if (AbsUDLProperties.len() > 0)
            {
               C_DBCONNECTION *pConn;

               // Conversione path UDLProperties da dir relativo in assoluto
               if ((pConn = ptr_info()->getDBConnection(OLD)) == NULL) return GS_BAD;
               if (pConn->UDLProperties_drive2nethost(AbsUDLProperties) == GS_BAD) return GS_BAD;
               if (gsc_RbSubst(p, AbsUDLProperties.get_name()) == GS_BAD) return GS_BAD;
            }
         }
      }

      if ((p = ColValues.CdrAssoc(_T("TABLE_REF"))) != NULL)
      {
         if (ptr_info() && p->restype == RTSTR && wcslen(p->resval.rstring) > 0)
         {
            C_STRING AbsUDLProperties(p->resval.rstring);

            if (AbsUDLProperties.len() > 0)
            {
               C_DBCONNECTION *pConn;

               // Conversione riferimento tabella da dir relativo in assoluto
               if ((pConn = ptr_info()->getDBConnection(OLD)) == NULL) return GS_BAD;
               if (AbsUDLProperties.paste(pConn->FullRefTable_drive2nethost(p->resval.rstring)) == NULL)
                  return GS_BAD;
               if (gsc_RbSubst(p, AbsUDLProperties.get_name()) == GS_BAD) return GS_BAD;
            }
         }
      }
   }

   // leggo nome classe
   if ((p = ColValues.CdrAssoc(_T("NAME"))) == NULL) return GS_BAD;
   if (p->resval.rstring == NULL) { GS_ERR_COD = eGSInvalidArg; return GS_BAD; }
   wcscpy(name, p->resval.rstring);

   if ((p = ColValues.CdrAssoc(_T("VERSION"))) == NULL)
   { // aggiungo lista resbuf
      ColValues.get_tail()->restype = RTLB;
      if ((ColValues += (p = acutBuildList(RTSTR, _T("VERSION"), RTSTR, GS_EMPTYSTR,
                                           RTLE, RTLE, 0))) == NULL)
         return GS_BAD;
      p = p->rbnext;
   }
   if (p->restype != RTSTR) { GS_ERR_COD = eGSInvRBType; return GS_BAD; }
   if (p->resval.rstring) free(p->resval.rstring);
   if ((p->resval.rstring = gsc_tostring(gsc_msg(130))) == NULL) return GS_BAD; // Versione attuale di GEOsim

   // ciclo di GS_NUM_TEST tentativi per inserire una nuova classe
   do
   {
      if (is_subclass() == GS_BAD)
      { // cerco nuovo codice per la classe   
         if ((new_code = get_pPrj()->getNextClassId()) == 0)
            return GS_BAD;

         // modifico codice e sottocodice in resbuf per scrittura in GS_CLASS
         p = ColValues.CdrAssoc(_T("GS_ID"));
         gsc_RbSubst(p, new_code);
         gs_id = new_code;
         p = ColValues.CdrAssoc(_T("SUB_GS_ID"));
         gsc_RbSubst(p, 0);
         sub_gs_id = 0;
      }
      else
      { // cerco nuovo sottocodice per la sottoclasse   
         if (gsc_newsubcode(pConn, TableRef, id.code, &new_code) == GS_BAD)
            return GS_BAD;
         gs_id = id.code;
         // modifico sottocodice in resbuf per scrittura in GS_CLASS
         p = ColValues.CdrAssoc(_T("SUB_GS_ID"));
         gsc_RbSubst(p, new_code);
         sub_gs_id = new_code;
      }

      // eseguo calcolo del campo CHECKNAME per verifica univocità nome classe
      if ((p = ColValues.CdrAssoc(_T("CHECKNAME"))) == NULL)
      { // aggiungo lista resbuf
         ColValues.get_tail()->restype = RTLB;
         if ((ColValues += (p = acutBuildList(RTSTR, _T("CHECKNAME"), RTSTR, GS_EMPTYSTR,
                                              RTLE, RTLE, 0))) == NULL)
            return GS_BAD;
         p = p->rbnext;
      }
      if (p->restype != RTSTR) { GS_ERR_COD = eGSInvRBType; return GS_BAD; }
      if (p->resval.rstring) free(p->resval.rstring);
      if (sub_gs_id == 0)
      {
         if ((p->resval.rstring = gsc_tostring(name)) == NULL) return GS_BAD;
      }
      else
      {
         if ((p->resval.rstring = gsc_tostring(gs_id)) == NULL) return GS_BAD;
         if ((p->resval.rstring = gsc_strcat(p->resval.rstring, name)) == NULL) return GS_BAD;
      }
      
      // inserisco nuova riga in GS_CLASS
      if (pConn->InsRow(TableRef.get_name(), ColValues, ONETEST) == GS_GOOD) break;
             
      n_test++;
      if (n_test >= GEOsimAppl::GLOBALVARS.get_NumTest()) return GS_BAD;
      
      // se l'errore non era dovuto perchè il codice esisteva già, attendi
      if (GS_ERR_COD != eGSIntConstr) gsc_wait(GEOsimAppl::GLOBALVARS.get_WaitTime());
   }
   while (1);
                           
   if (is_subclass() == GS_BAD)
   {
      id.code     = new_code;
      id.sub_code = 0;
   }
   else id.sub_code = new_code;

   if (p_info) p_info->TempLastId = p_info->OldLastId = 0;

   return new_code;
}
    

/*********************************************************/
/*.doc mod_cls_to_gs_class <internal> */
/*+
  Questa funzione modifica una classe già esistente in GS_CLASS.
  La lista resbuf viene modificata cosi come la C_ID della classe.
  Parametri:
  C_RB_LIST &ColValues;    Lista colonna-valore
  _RecordsetPtr &RsCls;    Recordset che blocca in GS_CLASS
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/  
/*********************************************************/
int C_CLASS::mod_cls_to_gs_class(C_RB_LIST &ColValues, _RecordsetPtr &RsCls)
{
   presbuf p;
   C_INFO  *p_info = ptr_info();

   // alcuni valori non possono essere modificati in GS_CLASS
   if ((p = ColValues.CdrAssoc(DEFAULT_KEY_ATTR)) != NULL)
      if (gsc_RbSubst(p, id.code) == GS_BAD) return GS_BAD;

   if ((p = ColValues.CdrAssoc(_T("SUB_GS_ID"))) != NULL)
      if (gsc_RbSubst(p, id.sub_code) == GS_BAD) return GS_BAD;

   if ((p = ColValues.CdrAssoc(_T("TYPE"))) != NULL)
      if (gsc_RbSubst(p, id.type) == GS_BAD) return GS_BAD;

   if ((p = ColValues.CdrAssoc(_T("CATEGORY"))) != NULL)
      if (gsc_RbSubst(p, id.category) == GS_BAD) return GS_BAD;

   if ((p = ColValues.CdrAssoc(_T("ABILIT"))) != NULL)
      if (gsc_RbSubst(p, id.abilit) == GS_BAD) return GS_BAD;

   if ((p = ColValues.CdrAssoc(_T("UDL_FILE"))) != NULL)
   {
      if (ptr_info() && p->restype == RTSTR && wcslen(p->resval.rstring) > 0)
      {  // traduco dir relativo in dir assoluto
         C_STRING Path(p->resval.rstring);

         if (gsc_path_exist(Path) == GS_GOOD)
            if (gsc_drive2nethost(Path) == GS_BAD) return GS_BAD;
         if (Path.len() > ACCESS_MAX_LEN_FIELDCHAR)
            { GS_ERR_COD = eGSStringTooLong; return GS_BAD; }
         if (gsc_RbSubst(p, Path.get_name()) == GS_BAD) return GS_BAD;
      }
      else
         if (gsc_RbSubst(p, GS_EMPTYSTR) == GS_BAD) return GS_BAD;

      if ((p = ColValues.CdrAssoc(_T("UDL_PROP"))) != NULL)
      {
         if (ptr_info() && p->restype == RTSTR && wcslen(p->resval.rstring) > 0)
         {
            C_STRING AbsUDLProperties(p->resval.rstring);

            if (AbsUDLProperties.len() > 0)
            {
               C_DBCONNECTION *pConn;

               // Conversione path UDLProperties da dir relativo in assoluto
               if ((pConn = ptr_info()->getDBConnection(OLD)) == NULL) return GS_BAD;
               if (pConn->UDLProperties_drive2nethost(AbsUDLProperties) == GS_BAD) return GS_BAD;
               if (gsc_RbSubst(p, AbsUDLProperties.get_name()) == GS_BAD) return GS_BAD;
            }
         }
      }

      if ((p = ColValues.CdrAssoc(_T("TABLE_REF"))) != NULL)
      {
         if (ptr_info() && p->restype == RTSTR && wcslen(p->resval.rstring) > 0)
         {
            C_STRING AbsUDLProperties(p->resval.rstring);

            if (AbsUDLProperties.len() > 0)
            {
               C_DBCONNECTION *pConn;

               // Conversione riferimento tabella da dir relativo in assoluto
               if ((pConn = ptr_info()->getDBConnection(OLD)) == NULL) return GS_BAD;
               if (AbsUDLProperties.paste(pConn->FullRefTable_drive2nethost(p->resval.rstring)) == NULL)
                  return GS_BAD;
               if (gsc_RbSubst(p, AbsUDLProperties.get_name()) == GS_BAD) return GS_BAD;
            }
         }
      }
   }

   if ((p = ColValues.CdrAssoc(_T("NAME"))) != NULL)
   { // si vuole modificare il nome della classe
      TCHAR name[MAX_LEN_CLASSNAME];

      if (p->restype != RTSTR || p->resval.rstring == NULL || wcslen(p->resval.rstring) == 0)
         { GS_ERR_COD = eGSInvalidArg; return GS_BAD; }
      wcscpy(name, p->resval.rstring);

      // eseguo calcolo del campo CHECKNAME per verifica univocità nome classe
      if ((p = ColValues.CdrAssoc(_T("CHECKNAME"))) == NULL)
      { // aggiungo lista resbuf
         ColValues.get_tail()->restype = RTLB;
         if ((p = acutBuildList(RTSTR, _T("CHECKNAME"), RTSTR, GS_EMPTYSTR, RTLE, RTLE, 0)) == NULL)
            { GS_ERR_COD = eGSOutOfMem; return GS_BAD; }
         ColValues += p;
         p = p->rbnext;
      }
      if (p->resval.rstring) free(p->resval.rstring);
      if (id.sub_code == 0) p->resval.rstring = gsc_tostring(name);
      else
      {
         if ((p->resval.rstring = gsc_tostring(id.code)) == NULL) return GS_BAD;
         if ((p->resval.rstring = gsc_strcat(p->resval.rstring, name)) == NULL) return GS_BAD;
      }
   }

   // modifico la riga del cursore vedi "lock_class"
   if (gsc_DBUpdRow(RsCls, ColValues) == GS_BAD) return GS_BAD;

   return GS_GOOD;
}
    

/*********************************************************/
/*.doc mod_id <internal> */
/*+
  Questa funzione modifica una C_ID di una classe già esistente in GS_CLASS.
  Parametri:
  C_ID *p_id;           puntatore a oggetto C_ID
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/  
/*********************************************************/
int C_CLASS::mod_id(C_ID *p_id)
{
   presbuf        p;
   C_RB_LIST      ColValuesNewID;
   C_DBCONNECTION *pConn;
   _RecordsetPtr  pRs;
   C_STRING       ClassesTableRef, statement;
   int            result;

   // verifico abilitazione
   if (gsc_check_op(opModClass) == GS_BAD) return GS_BAD;
   if (ptr_id()->abilit != GSUpdateableData) { GS_ERR_COD = eGSClassLocked; return GS_BAD; }

   if ((ColValuesNewID << acutBuildList(RTLB, 0)) == NULL) return GS_BAD;
   
   // C_ID
   if (p_id->to_rb_db(&p) == GS_BAD) return GS_BAD;
   
   ColValuesNewID += p;
   if ((ColValuesNewID += acutBuildList(RTLE, 0)) == NULL) return GS_BAD;

   if (get_pPrj()->getClassesTabInfo(&pConn, &ClassesTableRef) == GS_BAD) return GS_BAD;

   // seleziono riga del progetto in GS_PRJ
   statement = _T("SELECT * FROM ");
   statement += ClassesTableRef;
   statement += _T(" WHERE GS_ID=");
   statement += id.code;
   statement += _T(" AND SUB_GS_ID=");
   statement += id.sub_code;

   // blocco la classe in modo esclusivo GS_CLASS usando come semaforo
   // il codice della sessione attiva, se esistente, altrimenti il codice utente 
   long OwnerCode = (GS_CURRENT_WRK_SESSION) ? GS_CURRENT_WRK_SESSION->get_id() : GEOsimAppl::GS_USER.code * -1;
   if (set_exclusive_use(OwnerCode, &result) == GS_BAD || result == GS_BAD)
      return GS_BAD;

   if (pConn->OpenRecSet(statement, pRs, adOpenDynamic, adLockOptimistic) == GS_BAD)
      { set_share_use(); return GS_BAD; }
   if (gsc_isEOF(pRs) == GS_GOOD)
      { gsc_DBCloseRs(pRs); set_share_use(); return GS_BAD; }
   // modifico riga in GS_CLASS
   if (mod_cls_to_gs_class(ColValuesNewID, pRs) == GS_BAD)
      { gsc_DBCloseRs(pRs); set_share_use(); return GS_BAD; }
   gsc_DBCloseRs(pRs);

   // sblocco classe
   if (set_share_use() == GS_BAD) return GS_BAD;

   wcscpy(id.name, p_id->name);
   id.Descr = p_id->Descr;
   id.view_enabled = p_id->view_enabled;
   id.history_enabled = p_id->history_enabled;

   // memorizzo il codice del progetto in GEOSIM.INI
   gsc_setLastUsedPrj(get_PrjId());

   return GS_GOOD;
}

    
/*********************************************************/
/*.doc mod_fas <internal> */
/*+
  Questa funzione modifica una C_FAS di una classe già esistente in GS_CLASS.
  Parametri:
  C_FAS *p_fas;         puntat. a oggetto C_FAS già allocato e inizializzato
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/  
/*********************************************************/
int C_CLASS::mod_fas(C_FAS *p_fas)
{
   int result;
   
   // verifico abilitazione
   if (gsc_check_op(opModClass) == GS_BAD) return GS_BAD;
   if (ptr_id()->abilit != GSUpdateableData) { GS_ERR_COD = eGSClassLocked; return GS_BAD; }
   
   if (id.category == CAT_GROUP || ptr_fas() == NULL)
      { GS_ERR_COD = eGSInvClassType; return GS_BAD; }

   // blocco la classe in modo esclusivo GS_CLASS usando come semaforo
   // il codice della sessione attiva, se esistente, altrimenti il codice utente 
   long OwnerCode = (GS_CURRENT_WRK_SESSION) ? GS_CURRENT_WRK_SESSION->get_id() : GEOsimAppl::GS_USER.code * -1;
   if (set_exclusive_use(OwnerCode, &result) == GS_BAD || result == GS_BAD)
      return GS_BAD;

   // modifico riga in DB
   if (p_fas->to_db(get_pPrj(), id.code, id.sub_code) == GS_BAD)
      { set_share_use(); return GS_BAD; }
   
   if (set_share_use() == GS_BAD) return GS_BAD; // sblocco classe

   // memorizzo il codice del progetto in GEOSIM.INI
   gsc_setLastUsedPrj(get_PrjId());

   // modifico classe in memoria
   return p_fas->copy(ptr_fas());
}

    
/*********************************************************/
/*.doc mod_conct <internal> */
/*+
  Questa funzione modifica una C_CONNECT_LIST di una classe già esistente 
  in GS_CLASS.
  Parametri:
  C_CONNECT_LIST *p_conct; puntat. a oggetto C_CONNECT_LIST già allocato 
                           e inizializzato
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/  
/*********************************************************/
int C_CLASS::mod_conct(C_CONNECT_LIST *p_conct)
{
   int            result;
   C_CONNECT_LIST CpyConctList;

   // verifico abilitazione
   if (gsc_check_op(opModClass) == GS_BAD) return GS_BAD;
   if (ptr_id()->abilit != GSUpdateableData) { GS_ERR_COD = eGSClassLocked; return GS_BAD; }
  
    // valido solo per le categorie semplici
   if (id.category != CAT_SIMPLEX) { GS_ERR_COD = eGSInvClassType; return GS_BAD; }
   p_conct->copy(&CpyConctList);

   // modifico classe in memoria
   if (ptr_connect_list()->mod(p_conct) == GS_BAD) return GS_BAD;

   result = GS_BAD;

   do
   {
      // verifico connect list
      if (is_validconnectlist() == GS_BAD) break;

      // blocco la classe in modo esclusivo GS_CLASS usando come semaforo
      // il codice della sessione attiva, se esistente, altrimenti il codice utente 
      long OwnerCode = (GS_CURRENT_WRK_SESSION) ? GS_CURRENT_WRK_SESSION->get_id() : GEOsimAppl::GS_USER.code * -1;
      if (set_exclusive_use(OwnerCode, &result) == GS_BAD || result == GS_BAD)
         break;
      result = GS_BAD;
      // modifico righe in GS_CONCT
      if (to_db_connectlist(p_conct) == GS_BAD)
         { set_share_use(); break; }
      if (set_share_use() == GS_BAD) break; // sblocco classe
      
      result = GS_GOOD;
   }
   while (0);
   
   if (result == GS_BAD) CpyConctList.copy(p_conct);

   // memorizzo il codice del progetto in GEOSIM.INI
   gsc_setLastUsedPrj(get_PrjId());

   return result;
}

                          
/*********************************************************/
/*.doc is_valid <internal> */
/*+
  Questa funzione verifica la correttezza della C_CONNECT_LIST.

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
  N.B.: Se il codice della classe = 0 significa che si tratta della stessa
  classe (creazione di una classe e connessione con se stessa).
-*/  
/*********************************************************/
int C_CLASS::is_validconnectlist(void)
{  
   C_INT_INT      *pconct;
   C_CLASS        *pCls;
   int            class_code, indice = 1, cat, tip, conct_code;
   C_CONNECT_LIST *p_connect_list;
   
   if ((p_connect_list = ptr_connect_list()) == NULL)
      { GS_ERR_COD = eGSInvClassType; return GS_BAD; }
   
   // verifico che una classe sia selezionata una volta sola
   if (p_connect_list->once_selclass() == GS_BAD) return GS_BAD; 

   pconct = (C_INT_INT *) p_connect_list->get_head();
   while (pconct != NULL)
   {  
      class_code = pconct->get_key();
      if (class_code != 0)
      {
         // Ritorna il puntatore alla classe cercata
         if ((pCls = get_pPrj()->find_class(class_code)) == NULL)
            { GS_ERR_COD = eGSInvalidConct; return GS_BAD; }
         cat = pCls->get_category();
         tip = pCls->get_type();
      }
      else   // stessa classe
      {
         cat = get_category();
         tip = get_type();
      }
      // verifico che il tipo di collegamento sia corretto
      conct_code = pconct->get_type();
      if (gsc_is_validconnect(conct_code, cat, tip) == GS_BAD) return GS_BAD;
      
      pconct = (C_INT_INT *) p_connect_list->get_next();
   }
   
   return GS_GOOD;
}  
                                             

/*********************************************************/
/*.doc is_validinfo <internal> */
/*+
  Questa funzione verifica la correttezza della C_INFO.
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_CLASS::is_validinfo()
{                   
   C_STRING       Catalog, Schema, Table;
   C_INFO         *pinfo = ptr_info();
   C_ATTRIB_LIST  *p_attrib_list = ptr_attrib_list();
   C_DBCONNECTION *pConn;
   
   if (!pinfo || !p_attrib_list) { GS_ERR_COD = eGSInvClassType; return GS_BAD; }

   if ((pConn = pinfo->getDBConnection(OLD)) == NULL) return GS_BAD;

   if (pConn->split_FullRefTable(pinfo->OldTableRef, Catalog, Schema, Table) == GS_BAD)
      return GS_BAD;

   // verifico correttezza nome tabella
   if (pConn->IsValidTabName(Table) == GS_BAD) return GS_BAD;
   if (!pinfo->LinkedTable) // correggo OldTableRef solo se è una tabella gestita da GEOsim
      if (pinfo->OldTableRef.paste(pConn->get_FullRefTable(Catalog, Schema, Table)) == NULL)
         return GS_BAD;
   if (gsc_valid_attrib_name(pinfo->key_attrib, pConn, p_attrib_list) == GS_BAD)
      { GS_ERR_COD = eGSInvalidKey; return GS_BAD; }
   
   return GS_GOOD;
}

    
/*********************************************************/
/*.doc C_CLASS::is_validid <internal> */
/*+
  Questa funzione verifica che siano validi i codici di categoria e tipo.
  Parametri:
  int category;   codice di categoria
  int type;       codice di tipo

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_CLASS::is_validid()
{
   switch (id.category)
   {
      case CAT_SIMPLEX :   // SEMPLICE
         switch (id.type)
         {
            case TYPE_POLYLINE:  // POLILINEA
            case TYPE_TEXT:      // TESTO
            case TYPE_NODE:      // NODO
            case TYPE_SURFACE:   // SUPERFICIE
               break;
            default:
               GS_ERR_COD = eGSInvClassType;
               return GS_BAD;
         }
         break;
      case CAT_GROUP :   // GRUPPO-FINE
         if (id.type != TYPE_GROUP)
            { GS_ERR_COD = eGSInvClassType; return GS_BAD; }
         break;
      case CAT_GRID :     // GRIGLIA
         if (id.type != TYPE_GRID)
            { GS_ERR_COD = eGSInvClassType; return GS_BAD; }
         break;
      case CAT_EXTERN :    // simulazione
         return GS_GOOD;
      case CAT_SPAGHETTI : // SPAGHETTI
         if (id.type != TYPE_SPAGHETTI)
            { GS_ERR_COD = eGSInvClassType; return GS_BAD; }
         break;
      default:
         GS_ERR_COD = eGSInvCategoryType;
         return GS_BAD;
   }

   if (gsc_validclassname(id.name) == GS_BAD) return GS_BAD;
   
   return GS_GOOD;
}

    
/*********************************************************/
/*.doc (new 2) C_CLASS::CheckValidFuncOnData <internal> */
/*+
  Questa funzione verifica le funzioni di validità della classe
  prendendole da una struttura passata come parametro. Verifica che
  eventuali dati già presenti soddisfino le funzioni.
  Parametri:
  C_ATTRIB_LIST *p_attrib_list;  lista attributi da cui leggere le funzioni
                                 di validità

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_CLASS::CheckValidFuncOnData(C_ATTRIB_LIST *p_attrib_list)
{
   C_INFO *p_info = ptr_info();
	int	 res;

   if (!p_info) { GS_ERR_COD = eGSInvClassType; return GS_BAD; }
   // carico eventuali funzioni di calcolo in GSL.GSL del progetto della classe
   gsc_load_gsl(get_pPrj()->get_dir());

   res = gsc_CheckValidFuncOnData(p_info->getDBConnection(OLD), p_info->OldTableRef.get_name(),
                                   p_attrib_list, p_info->key_attrib.get_name());
	// ricarico GSL.GSL giusto
	gs_gsl_reload();

	return res;
}

    
/*********************************************************/
/*.doc (new 2) C_CLASS::ChangeCalcFuncOnData <internal> */
/*+
  Questa funzione ricalcola i campi calcolati con le funzioni di calcolo
  prendendole da una struttura passata come parametro.
  Parametri:
  C_ATTRIB_LIST *p_attrib_list;  lista attributi da cui leggere le funzioni
                                 di validità

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_CLASS::ChangeCalcFuncOnData(C_ATTRIB_LIST *p_attrib_list)
{
   C_INFO *p_info = ptr_info();
	int    res;

   if (!p_info) { GS_ERR_COD = eGSInvClassType; return GS_BAD; }
   // carico eventuali funzioni di calcolo in GSL.GSL del progetto della classe
   gsc_load_gsl(get_pPrj()->get_dir());

   res = gsc_ChangeCalcFuncOnData(p_info->getDBConnection(OLD), p_info->OldTableRef.get_name(),
                                   p_attrib_list, p_info->key_attrib.get_name());
   // ricarico GSL.GSL giusto
	gs_gsl_reload();

	return res;

}

    
/*********************************************************/
/*.doc (new 2) C_CLASS::CheckMandatoryOnData <internal> */
/*+
  Questa funzione verifica che i campi con il flag di obbligatorietà
  attivo non abbiano valore vuoto.
  Parametri:
  C_ATTRIB_LIST *p_attrib_list;  lista attributi da cui leggere gli
                                 attributi obbligatori
  bool           AssignDefault;  Flag, se = TRUE se viene incontrato un 
                                 attributo che non soddisfa l'obbligatorietà 
                                 viene settato il valore di default
                                 (default = FALSE)
  bool       *VisAttribModified; Usato solo se il parametro "AssignDefault" = TRUE
                                 viene impostato a TRUE se è stato modificato il valore
                                 di qualche attributo visibile (default = NULL)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_CLASS::CheckMandatoryOnData(C_ATTRIB_LIST *p_attrib_list, bool AssignDefault,
                                  bool *VisAttribModified)
{
   C_INFO *p_info = ptr_info();

   if (!p_info) { GS_ERR_COD = eGSInvClassType; return GS_BAD; }

   return gsc_CheckMandatoryOnData(p_info->getDBConnection(OLD), p_info->OldTableRef.get_name(),
                                   p_attrib_list, AssignDefault, VisAttribModified);
}


/*********************************************************/
/*.doc C_CLASS::GetLPN4OLD                    <internal> */
/*+
  Questa funzione ricava il LPN per la tabella OLD della classe e restituisce
  il suo nome.
  Parametri:
  C_STRING  *LPNName;   Nome del LPN
  int       Create;     Flag; se = GS_GOOD la funzione crea il LPN (se non 
                        esistente) altrimenti restituisce solo il nome;
                        default = GS_GOOD.

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_CLASS::GetLPN4OLD(C_STRING &LPNName, int Create)
{
   if (getLPNameOld(LPNName) == GS_BAD) return GS_BAD;

   // se si vuole creare il LPN
   if (Create == GS_GOOD && ptr_info())
   {
      C_DBCONNECTION *pConn = ptr_info()->getDBConnection(OLD);
   
      if (!pConn) return GS_BAD;
      // creo il LPT per la classe (il file UDL si chiama come il LPT)
      if (gsc_CreateLinkName(LPNName.get_name(), LPNName.get_name(), pConn, 
                             ptr_info()->OldTableRef.get_name(),
                             ptr_info()->key_attrib.get_name()) == GS_BAD)
         return GS_BAD;
   }

   return GS_GOOD;
}


/***************************************************************/
/*.doc (new 2) C_CLASS::DisconnectAse4OLD           <internal> */
/*+
  Questa funzione sconnette ASE per la tabella OLD.
-*/  
/***************************************************************/
int C_CLASS::DisconnectAse4OLD(void)
{
   if (id.category == CAT_EXTERN)
   {
      C_SUB *pSub = (C_SUB *) ptr_sub_list()->get_head();

      while (pSub)
      {
         if (pSub->DisconnectAse4OLD() == GS_BAD) return GS_BAD;
         pSub = (C_SUB *) pSub->get_next();
      }
   }
   else
      if (ptr_info() && ptr_attrib_list())
      {
         C_STRING OldLPN;

         GetLPN4OLD(OldLPN, GS_BAD); // ricavo il LPN senza crearlo
         if (gsc_LPNDisconnectAse(OldLPN.get_name()) == GS_BAD)
            return GS_BAD;
      }         
   
   return GS_GOOD;
}


int C_CLASS::allocGraphInfo(GraphDataSourceEnum Type)
   { GS_ERR_COD = eGSInvClassType; return GS_BAD; }
void C_CLASS::deallocGphInfo(void) {}


/******************************************************************************/
/*.doc C_CLASS::GphDetach                                         <external>  */
/*+
  Funzione per il rilascio della sorgente dati geometrica della classe.
  Parametri:

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/******************************************************************************/
int C_CLASS::GphDetach(void)
{
   if (ptr_GphInfo() == NULL) return GS_GOOD;
   return ptr_GphInfo()->Detach();
}


/*********************************************************/
/*.doc C_CLASS::reindex_sec <internal> */
/*+
  Questa funzione reindicizza le tabelle secondarie della classe.
  bool OnlyTemp;        Flag, se true indica che devono essere considerate solo
                        le tabelle temporanee (default = false)
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_CLASS::reindex_sec(bool OnlyTemp)
{
   C_SINTH_SEC_TAB_LIST SinthSecList;
   C_SINTH_SEC_TAB      *pSinthSec;
   C_SECONDARY          *psecondary;

   if (ptr_attrib_list() == NULL)
      { GS_ERR_COD = eGSInvClassType; return GS_BAD; }

   // leggo la lista delle tabelle secondarie
   if (get_pPrj()->getSinthClsSecondaryTabList(id.code, id.sub_code, SinthSecList) == GS_BAD) return GS_BAD;

   pSinthSec = (C_SINTH_SEC_TAB *) SinthSecList.get_head();
   while (pSinthSec)
   {
      if (pSinthSec->get_type() == GSInternalSecondaryTable)
      {
         if ((psecondary = (C_SECONDARY *) find_sec(pSinthSec->get_key())) == NULL)
            return GS_BAD;

         psecondary->reindex(OnlyTemp);
      }
      pSinthSec = (C_SINTH_SEC_TAB *) SinthSecList.get_next();
   }

   return GS_GOOD;
}


/*********************************************************/
/*.doc C_CLASS::RefreshSecTempLastId          <internal> */
/*+
  Questa funzione aggiorna il membro TempLastId delle tabelle
  secondarie interne.
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_CLASS::RefreshSecTempLastId(void)
{
   C_SINTH_SEC_TAB_LIST SinthSecList;
   C_SINTH_SEC_TAB      *pSinthSec;
   C_SECONDARY          *psecondary;

   if (ptr_attrib_list() == NULL)
      { GS_ERR_COD = eGSInvClassType; return GS_BAD; }

   // leggo la lista delle tabelle secondarie
   if (get_pPrj()->getSinthClsSecondaryTabList(id.code, id.sub_code, SinthSecList) == GS_BAD) return GS_BAD;

   pSinthSec = (C_SINTH_SEC_TAB *) SinthSecList.get_head();
   while (pSinthSec)
   {
      if (pSinthSec->get_type() == GSInternalSecondaryTable)
      {
         if ((psecondary = (C_SECONDARY *) find_sec(pSinthSec->get_key())) == NULL)
            return GS_BAD;

         psecondary->RefreshTempLastId();
      }
      pSinthSec = (C_SINTH_SEC_TAB *) SinthSecList.get_next();
   }

   return GS_GOOD;
}


/*********************************************************/
/*.doc C_CLASS::RefreshOldLastId              <internal> */
/*+
  Questa funzione aggiorna il membro OldLastId.
  Parametri:
  bool SetTempLastIdEqualToOldLastId; Opzionale; Flag per impostare il
                                      codice massimo delle tabelle
                                      TEMP uguale a quello OLD (default = true)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
  N.B. Non chiamare questa funzione se la classe a cui appartiene la C_INFO
       è usata nella sessione di lavoro corrente a meno che si stia salvando.
-*/  
/*********************************************************/
int C_CLASS::RefreshOldLastId(bool SetTempLastIdEqualToOldLastId)
{
   if (ptr_info() == NULL) { GS_ERR_COD = eGSInvClassType; return GS_BAD; }
   return ptr_info()->RefreshOldLastId(SetTempLastIdEqualToOldLastId);
}


/**********************************************************/
/*.doc C_CLASS::synchronize_sec                <internal> */
/*+
  Questa funzione sincronizza le tabelle secondarie della classe.
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/**********************************************************/
int C_CLASS::synchronize_sec(void)
{
   C_SINTH_SEC_TAB_LIST SinthSecList;
   C_SINTH_SEC_TAB      *pSinthSec;
   C_SECONDARY          *psecondary;

   if (ptr_attrib_list() == NULL)
      { GS_ERR_COD = eGSInvClassType; return GS_BAD; }

   // leggo la lista delle tabelle secondarie
   if (get_pPrj()->getSinthClsSecondaryTabList(id.code, id.sub_code, SinthSecList) == GS_BAD) return GS_BAD;

   pSinthSec = (C_SINTH_SEC_TAB *) SinthSecList.get_head();
   while (pSinthSec)
   {
      if (pSinthSec->get_type() == GSInternalSecondaryTable)
      {
         if ((psecondary = (C_SECONDARY *) find_sec(pSinthSec->get_key())) == NULL)
            return GS_BAD;

         psecondary->synchronize();
      }
      pSinthSec = (C_SINTH_SEC_TAB *) SinthSecList.get_next();
   }

   return GS_GOOD;
}


/*********************************************************/
/*.doc C_CLASS::Check_KeyPri_On_Sec           <internal> */
/*+
  Questa funzione verifica se la classe ha delle tabelle secondarie e
  per ogniuna controlla se il campo della classe usato per il collegamento con la
  tabella secondaria (key_pri) esista ancora.
  Da usare in modifica della struttura della classe.
  Parametri:
  C_ATTRIB_LIST &NewAttribList;  Nuova struttura

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_CLASS::Check_KeyPri_On_Sec(C_ATTRIB_LIST &NewAttribList)
{
   C_SINTH_SEC_TAB_LIST SinthSecList;
   C_SINTH_SEC_TAB      *pSinthSec;

   if (!ptr_attrib_list()) { GS_ERR_COD = eGSInvClassType; return GS_BAD; }

   // leggo la lista delle tabelle secondarie
   if (get_pPrj()->getSinthClsSecondaryTabList(id.code, id.sub_code, SinthSecList) == GS_BAD) return GS_BAD;

   pSinthSec = (C_SINTH_SEC_TAB *) SinthSecList.get_head();
   while (pSinthSec)
   {
      if (NewAttribList.search_name(pSinthSec->get_KeyPriAttrib()) == NULL)
         { GS_ERR_COD = eGSInvLinkSec; return GS_BAD; }

      pSinthSec = (C_SINTH_SEC_TAB *) SinthSecList.get_next();
   }

   return GS_GOOD;
}


/******************************************************************************/
/*.doc C_CLASS::Backup <internal>                                             */
/*+
  Questa funzione esegue il backup dei file della classe.
  Il nome della tabella sarà composto da: "B"+prj+cls+sub (alcuni DBMS non supportano 
  i nomi di tabella che inizino con un numero; es. Oracle).
  Parametri:
  BackUpModeEnum Mode; Flag di modalità: Creazione , restore o cancellazione
                        del backup esistente (default = GSCreateBackUp).
  int What;            Cosa trattare: GRAPHICAL solo i DWG, RECORD solo le tabelle
                       (tabella dati), ALL per tutto (default = ALL).
  int MsgToVideo;      Flag, se = GS_GOOD stampa a video i messaggi (default = GS_GOOD)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
  N.B. Le tabelle GS_CLASS e GS_ATTR non vengono trattate perchè, essendo in ACCESS,
       utilizzano la tecnica del commit/rollback.
-*/  
/******************************************************************************/
int C_CLASS::Backup(BackUpModeEnum Mode, int What, int MsgToVideo)
{
   int    result = GS_GOOD;
   TCHAR  *cod36prj = NULL, *cod36cls = NULL, *cod36sub = NULL;
   C_INFO *pInfo = ptr_info();

   result = GS_GOOD;

   if (gsc_long2base36(&cod36prj, get_PrjId(), 2) == GS_BAD || !cod36prj) return GS_BAD;
   if (gsc_long2base36(&cod36cls, id.code, 3) == GS_BAD || !cod36cls)
      { free(cod36prj); return GS_BAD; }

   // blocco la classe in modo esclusivo GS_CLASS usando come semaforo
   // il codice della sessione attiva, se esistente, altrimenti il codice utente 
   long OwnerCode = (GS_CURRENT_WRK_SESSION) ? GS_CURRENT_WRK_SESSION->get_id() : GEOsimAppl::GS_USER.code * -1;
   if (set_exclusive_use(OwnerCode, &result) == GS_BAD || result == GS_BAD)
      return GS_BAD;

   if (MsgToVideo == GS_GOOD)
      switch (Mode)
      {
         case GSCreateBackUp: // crea backup
            acutPrintf(gsc_msg(643), id.name); // "\nCreazione backup classe %s..."
            break;
         case GSRemoveBackUp: // cancella backup
            acutPrintf(gsc_msg(270), id.name); // "\nCancellazione backup classe %s..."
            break;
         case GSRestoreBackUp: // ripristina backup
            acutPrintf(gsc_msg(272), id.name); // "\nRipristino backup classe %s..."
            break;
      }

   // tabelle
   if (pInfo && (What == RECORD || What == ALL))
   {
      C_STRING       Catalog, Schema, Table, BackUpTable;
      C_DBCONNECTION *pConn;
      int            conf = GS_BAD;

      if (id.category == CAT_EXTERN)
      {
         C_SUB *pSub = (C_SUB *) ptr_sub_list()->get_head();
         pInfo = pSub->ptr_info();

         if (gsc_long2base36(&cod36sub, pSub->ptr_id()->sub_code, 2) == GS_BAD)
            { free(cod36prj); free(cod36cls); set_share_use(); return GS_BAD; }
      }

      pConn = pInfo->getDBConnection(OLD);
      int IsTransactionSupported = pConn->BeginTrans();

      do
      {
         if (pConn->split_FullRefTable(pInfo->OldTableRef, Catalog, Schema, Table) == GS_BAD)
            { result = GS_BAD; break; }

         // se il riferimento completo è una path di un file (il catalogo è il direttorio)
         if (pConn->get_CatalogResourceType() == DirectoryRes)
            Catalog += _T("\\BACKUP"); // eseguo/ ripristino/cancello il backup nel sottodirettorio "BACKUP"
         BackUpTable = _T('B');
         BackUpTable += cod36prj;
         BackUpTable += cod36cls;
         if (cod36sub) BackUpTable += cod36sub;
      
         if (BackUpTable.paste(pConn->get_FullRefTable(Catalog, Schema,
                                                       BackUpTable)) == NULL)
            { result = GS_BAD; break; }

         switch (Mode)
         {
            case GSCreateBackUp: // crea backup
               // Se si tratta di una tabella collegata non posso fare il backup
               if (pInfo->LinkedTable) break;

               if (pConn->get_CatalogResourceType() == DirectoryRes && Catalog.get_name())
                  if (gsc_mkdir(Catalog.get_name()) == GS_BAD) 
                  { result = GS_BAD; break; }
               if (pConn->ExistTable(BackUpTable) == GS_GOOD)
               {
                  if (conf == GS_BAD)
                  {  // nel caso di ciclo viene chiesto solo la prima volta                
                     // "Tabella di backup già esistente. Sovrascrivere la tabella ?"
                     if (gsc_ddgetconfirm(gsc_msg(793), &conf) == GS_BAD) 
                        { result = GS_BAD; break; }
                     if (conf != GS_GOOD) { result = GS_CAN; break; }
                  }

                  if (pConn->DelTable(BackUpTable.get_name()) == GS_BAD)
                     { result = GS_BAD; break; }
               }

               // Non copio gli indici (Oracle e PG non ammettono nomi di indici uguali)
               if (pConn->CopyTable(pInfo->OldTableRef.get_name(), BackUpTable.get_name(),
                                    GSStructureAndDataCopyType, GS_BAD) == GS_BAD)
                  { result = GS_BAD; break; }

               break;

            case GSRemoveBackUp: // cancella backup
               // Se si tratta di una tabella collegata non posso rimuovere il backup
               if (pInfo->LinkedTable) break;

               if (pConn->ExistTable(BackUpTable) == GS_GOOD)
                  if (pConn->DelTable(BackUpTable.get_name()) == GS_BAD)
                     { result = GS_BAD; break; }
               if (pConn->get_CatalogResourceType() == DirectoryRes && Catalog.get_name())
                  gsc_rmdir(Catalog);
               break;

            case GSRestoreBackUp: // ripristina backup
            {
               C_STRING IndexRef;

               // Se si tratta di una tabella collegata non posso ripristinare il backup
               if (pInfo->LinkedTable) break;

               if (pConn->ExistTable(pInfo->OldTableRef.get_name()) == GS_GOOD)
                  if (pConn->DelTable(pInfo->OldTableRef.get_name()) == GS_BAD)
                     { result = GS_BAD; break; }
               if (pConn->CopyTable(BackUpTable.get_name(), pInfo->OldTableRef.get_name()) == GS_BAD)
                  { result = GS_BAD; break; }

               pConn->DelTable(BackUpTable.get_name());
               break;
            }

            default:
               break;  
         }
         if (result == GS_BAD) break;

         // gestione backup per GS_ATTRIB
         if (gsc_Backup_gs_attrib(Mode, get_pPrj(), id.code, id.sub_code) == GS_BAD)
            { result = GS_BAD; break; }

         if (id.category == CAT_EXTERN)
         {
            C_SUB *pSub = (C_SUB *) ptr_sub_list()->get_next();
            if (!pSub) break; // fine delle sottoclassi
            
            pInfo = pSub->ptr_info();
            if (cod36sub) { free(cod36sub); cod36sub = NULL; }
            if (gsc_long2base36(&cod36sub, pSub->ptr_id()->sub_code, 2) == GS_BAD)
               { result = GS_BAD; break; }
         }
         else break;
      }
      while (1);  

      if (result != GS_GOOD)
      {
         if (IsTransactionSupported == GS_GOOD) pConn->RollbackTrans();
         free(cod36prj);
         free(cod36cls);
         if (cod36sub) free(cod36sub);
         set_share_use();

         return GS_BAD;
      }
      else
      {
         // reindicizzo per ripristinare le chiavi primarie
         if (reindexTab() == GS_BAD)
         {
            free(cod36prj);
            free(cod36cls);
            if (cod36sub) free(cod36sub);
            set_share_use();

            return GS_BAD;        
         }

         if (IsTransactionSupported == GS_GOOD) pConn->CommitTrans();
         if (Mode == GSRestoreBackUp) // ripristina backup
            if (pConn->get_CatalogResourceType() == DirectoryRes && Catalog.get_name())
               gsc_rmdir(Catalog);
      }
   }
   if (cod36sub) { free(cod36sub); cod36sub = NULL; }

   // disegni
   if (What == GRAPHICAL || What == ALL)
   {
      // se simulazione leggo dalla prima sottoclasse
      if (id.category == CAT_EXTERN)
      {
         C_NODE *ptr  = ptr_sub_list()->get_cursor(); // posiz. precedente
         C_SUB  *pSub = (C_SUB *) ptr_sub_list()->get_head(), *pPrevSub;

         do
         {
            if (pSub->ptr_GphInfo()->Backup(Mode, MsgToVideo) == GS_BAD)
               { result = GS_BAD; break; }
            // Se si tratta di ripristino cancello il back-up ripristinato
            if (Mode == GSRestoreBackUp) 
               if (pSub->ptr_GphInfo()->Backup(GSRemoveBackUp, GS_BAD) == GS_BAD)
                  { result = GS_BAD; break; }

            pPrevSub = pSub;
            // vado alla sottoclasse successiva
            pSub = (C_SUB *) ptr_sub_list()->get_next();
            while (pSub)
            {
               // verifico se questa sottoclasse usa risorse grafiche
               // già usate dalle sottoclassi precedenti
               while (pSub->ptr_GphInfo()->IsTheSameResource(pPrevSub->ptr_GphInfo()) == false)
                  if ((pPrevSub = (C_SUB *) pPrevSub->get_prev()) == NULL) break;
               
               // Se NON esiste una sottoclase che usa le stesse risorse grafiche
               if (!pPrevSub) break; // esco dal ciclo

               pSub = (C_SUB *) ptr_sub_list()->get_next();
            }
         }
         while (pSub);
         ptr_sub_list()->getpos(ptr);
      }
      else // classi NON simulazioni
         if (ptr_GphInfo())
            if (ptr_GphInfo()->Backup(Mode, MsgToVideo) == GS_BAD)
               result = GS_BAD;
            else
               // Se si tratta di ripristino cancello il back-up ripristinato
               if (Mode == GSRestoreBackUp) 
                  if (ptr_GphInfo()->Backup(GSRemoveBackUp, GS_BAD) == GS_BAD)
                     result = GS_BAD;
   }

   free(cod36prj);
   free(cod36cls);

   if (set_share_use() == GS_BAD) return GS_BAD; // sblocco classe

   return result;
}


/*****************************************************************************/
/*.doc Backup_gs_class <internal> */
/*+
  Questa funzione esegue il backup della tabella principale GS_CLASS che descrive
  una classe/sottoclasse.
  Parametri:
  BackUpModeEnum Mode; Flag di modalità: Creazione , restore o cancellazione
                        del backup esistente.
  C_PROJECT *pPrj;  puntatore a progetto
  int cls;          Codice classe
  int sub;          Codice sottoclasse (default -1)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*****************************************************************************/
static int Backup_gs_class(BackUpModeEnum mode, C_PROJECT *pPrj, int cls, int sub)
{
   C_STRING       statement, TableRef, BackupTableRef, Cat, Sch, Tab;
   C_DBCONNECTION *pConn;
   _RecordsetPtr  pSourceRs;
   _CommandPtr    pInsCmd;
   int            Result = GS_BAD;

   if (pPrj->getClassesTabInfo(&pConn, &TableRef) == GS_BAD) return GS_BAD;
   BackupTableRef = TableRef;
   if (pConn->split_FullRefTable(TableRef, Cat, Sch, Tab) == GS_BAD) return GS_BAD;
   Tab += _T("B");
   if (BackupTableRef.paste(pConn->get_FullRefTable(Cat, Sch, Tab)) == NULL)
      return GS_BAD;

   if (pConn->ExistTable(BackupTableRef.get_name()) == GS_BAD)
      if (mode == GSCreateBackUp) // crea backup
      {
         // Non copio gli indici (Oracle e PG non ammettono nomi di indici uguali)
         if (pConn->CopyTable(TableRef.get_name(), BackupTableRef.get_name(), 
                              GSStructureOnlyCopyType, GS_BAD) == GS_BAD)
            return GS_BAD;
      }
      else
         return GS_GOOD; // non esiste il backup

   int IsTransactionSupported = pConn->BeginTrans();

   do
   {
      statement = _T("DELETE FROM ");
      statement += (mode == GSCreateBackUp || mode == GSRemoveBackUp) ? BackupTableRef : TableRef;
      statement += _T(" WHERE GS_ID=");
      statement += cls;
      if (sub > 0)
      {
         statement += _T(" AND SUB_GS_ID=");
         statement += sub;
      }     
      if (pConn->ExeCmd(statement) == GS_BAD) break;

      if (mode == GSCreateBackUp || mode == GSRestoreBackUp) // creazione/ripristino backup
      {
         statement = _T("SELECT * FROM ");
         statement += (mode == GSCreateBackUp) ? TableRef : BackupTableRef;
         statement += _T(" WHERE GS_ID=");
         statement += cls;
         if (sub > 0)
         {
            statement += _T(" AND SUB_GS_ID=");
            statement += sub;
         }     

         if (pConn->InitInsRow(TableRef.get_name(), pInsCmd) == GS_BAD)
            break;

         // creo record-set
         // prima era adOpenKeyset poi adOpenDynamic ma postgresql 
         // in una transazione fa casino (al secondo recordset che viene aperto)
         if (pConn->OpenRecSet(statement, pSourceRs, adOpenForwardOnly, adLockReadOnly) == GS_BAD)
            break;

         // copio i dati
         if (gsc_DBInsRowSet(pInsCmd, pSourceRs) == GS_BAD)
            { gsc_DBCloseRs(pSourceRs); break; }

         gsc_DBCloseRs(pSourceRs);
      }

      Result = GS_GOOD;
   }
   while (0);

   if (Result == GS_GOOD)
      { if (IsTransactionSupported == GS_GOOD) pConn->CommitTrans(); }
   else
      { if (IsTransactionSupported == GS_GOOD) pConn->RollbackTrans(); }

   return Result;
}


/*****************************************************************************/
/*.doc gsc_Backup_gs_attrib                                       <external> */
/*+
  Questa funzione esegue il backup della tabella principale GS_ATTRIB che descrive
  una classe/sottoclasse/secondaria.
  Parametri:
  BackUpModeEnum Mode; Flag di modalità: Creazione , restore o cancellazione
                        del backup esistente.
  C_PROJECT *pPrj;   puntatore a progetto
  int cls;           Codice classe
  int sub;           Codice sottoclasse
  int sec;           Codice secondaria (default -1)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*****************************************************************************/
int gsc_Backup_gs_attrib(BackUpModeEnum Mode, C_PROJECT *pPrj, int cls, int sub, int sec)
{
   C_STRING       statement, Cat, Sch, Tab;
   C_STRING       TableRef, BackupTableRef, GraphTableRef, BackupGraphTableRef;
   C_DBCONNECTION *pConn;
   _RecordsetPtr  pSourceRs;
   _CommandPtr    pInsCmd;
   int            Result = GS_BAD;

   int BackUp = GS_GOOD;

   // Informazioni NON grafiche degli attributi
   if (pPrj->getAttribsTabInfo(&pConn, &TableRef) == GS_BAD) return GS_BAD;
   if (pPrj->getAttribsTabInfo(&pConn, &BackupTableRef, BackUp) == GS_BAD) return GS_BAD;
   if (pConn->ExistTable(BackupTableRef) == GS_BAD)
      if (Mode == GSCreateBackUp)
      {  // Crea backup
         // Non copio gli indici (Oracle e PG non ammettono nomi di indici uguali)
         if (pConn->CopyTable(TableRef.get_name(), BackupTableRef.get_name(),
                              GSStructureOnlyCopyType, GS_BAD) == GS_BAD)
            return GS_BAD;
      }
      else
         return GS_GOOD; // non esiste il backup

   // Informazioni grafiche degli attributi
   if (pPrj->getGraphAttribsTabInfo(&pConn, &GraphTableRef) == GS_BAD) return GS_BAD;
   if (pPrj->getGraphAttribsTabInfo(&pConn, &BackupGraphTableRef, BackUp) == GS_BAD) return GS_BAD;
   if (pConn->ExistTable(BackupGraphTableRef) == GS_BAD)
      if (Mode == GSCreateBackUp)
      {  // Crea backup
         // Non copio gli indici (Oracle e PG non ammettono nomi di indici uguali)
         if (pConn->CopyTable(GraphTableRef.get_name(), BackupGraphTableRef.get_name(),
                              GSStructureOnlyCopyType, GS_BAD) == GS_BAD)
            return GS_BAD;
      }
      else
         return GS_GOOD; // non esiste il backup

   int IsTransactionSupported = pConn->BeginTrans();

   do
   {
      /////////////////////////////////////////////////////////////////////////
      // Informazioni NON grafiche degli attributi
      statement = _T("DELETE FROM ");
      // creazione/cancellazione backup
      statement += (Mode == GSCreateBackUp || Mode == GSRemoveBackUp) ? BackupTableRef : TableRef;
      statement += _T(" WHERE CLASS_ID=");
      statement += cls;
      statement += _T(" AND SUB_CL_ID=");
      statement += sub;
      if (sec > 0)
      {
         statement += _T(" AND SEC_ID=");
         statement += sec;
      }
      if (pConn->ExeCmd(statement) == GS_BAD) break;

      if (Mode == GSCreateBackUp || Mode == GSRestoreBackUp) // creazione/ripristino backup
      {
         statement = _T("SELECT * FROM ");
         // creazione backup
         statement += (Mode == GSCreateBackUp) ? TableRef : BackupTableRef;
         statement += _T(" WHERE CLASS_ID=");
         statement += cls;
         statement += _T(" AND SUB_CL_ID=");
         statement += sub;
         if (sec > 0)
         {
            statement += _T(" AND SEC_ID=");
            statement += sec;
         }

         if (pConn->InitInsRow((Mode == GSCreateBackUp) ? BackupTableRef.get_name() : TableRef.get_name(),
                               pInsCmd) == GS_BAD)
            break;

         // creo record-set
         // prima era adOpenKeyset poi adOpenDynamic ma postgresql 
         // in una transazione fa casino (al secondo recordset che viene aperto)
         if (pConn->OpenRecSet(statement, pSourceRs, adOpenForwardOnly, adLockReadOnly) == GS_BAD)
            break;

         // copio i dati
         if (gsc_DBInsRowSet(pInsCmd, pSourceRs) == GS_BAD)
            { gsc_DBCloseRs(pSourceRs); break; }

         gsc_DBCloseRs(pSourceRs);
      }

      // mi fermo qui se si tratta di tabella secondaria
      if (sec > 0) { Result = GS_GOOD; break; }

      /////////////////////////////////////////////////////////////////////////
      // Informazioni grafiche degli attributi
      statement = _T("DELETE FROM ");
      // creazione/cancellazione backup
      statement += (Mode == GSCreateBackUp || Mode == GSRemoveBackUp) ? BackupGraphTableRef : GraphTableRef;
      statement += _T(" WHERE CLASS_ID=");
      statement += cls;
      statement += _T(" AND SUB_CL_ID=");
      statement += sub;
      if (pConn->ExeCmd(statement) == GS_BAD) break;

      if (Mode == GSCreateBackUp || Mode == GSRestoreBackUp) // creazione/ripristino backup
      {
         statement = _T("SELECT * FROM ");
         // creazione backup
         statement += (Mode == GSCreateBackUp) ? GraphTableRef : BackupGraphTableRef;
         statement += _T(" WHERE CLASS_ID=");
         statement += cls;
         statement += _T(" AND SUB_CL_ID=");
         statement += sub;

         if (pConn->InitInsRow((Mode == GSCreateBackUp) ? BackupGraphTableRef.get_name() : GraphTableRef.get_name(),
                               pInsCmd) == GS_BAD)
            break;

         // creo record-set
         // prima era adOpenKeyset poi adOpenDynamic ma postgresql 
         // in una transazione fa casino (al secondo recordset che viene aperto)
         if (pConn->OpenRecSet(statement, pSourceRs, adOpenForwardOnly, adLockReadOnly) == GS_BAD)
            break;

         // copio i dati
         if (gsc_DBInsRowSet(pInsCmd, pSourceRs) == GS_BAD)
            { gsc_DBCloseRs(pSourceRs); break; }

         gsc_DBCloseRs(pSourceRs);
      }

      Result = GS_GOOD;
   }
   while (0);

   if (Result == GS_GOOD)
      { if (IsTransactionSupported == GS_GOOD) pConn->CommitTrans(); }
   else
      { if (IsTransactionSupported == GS_GOOD) pConn->RollbackTrans(); }
   
   return Result;
}


/*****************************************************************************/
/*.doc C_CLASS::UpdGraphData <internal> */
/*+
  Questa funzione aggiorna tutti gli oggetti grafici della classe per allinearli
  al cambio di struttura.
  Parametri:
  int change_fas;    flag, se = GS_GOOD vengono cambiate le caratteristiche grafiche
                     secondo le impostazioni della FAS di default della classe.
  long *BitForFAS;   flag a bit indicante le caratteristiche grafiche da cambiare,
                     opzionale, se = NULL significa tutta la FAS (default = NULL)
  int AttribsDABlocksToUpd; flag indicante se si devono aggiornare i singoli attributi
                            dei blocchi DA (default = GS_GOOD)
  int MoveOldVisAttrib; flag indicante se si devono mantenere (GS_BAD) o meno (GS_GOOD)
                        le posizioni degli attributi visibili già inseriti;
                        (default = GS_BAD)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*****************************************************************************/
int C_CLASS::UpdGraphData(int change_fas, long *BitForFAS, int AttribsDABlocksToUpd, 
                          int MoveOldVisAttrib)
{
   int            result = GS_BAD, OldOp;
   C_COLOR        PrevColor;
   int            IsRecordsetCloseable = GS_BAD;
   C_RB_LIST      env_variab, VisValues, ColValues;
   C_INT_LIST     cls_list_2_extract;
   C_INT          *pcls_2_extract;
   C_STRING       session_dir;
   C_WRK_SESSION  WrkSession(get_pPrj());
   C_LINK         Link;
   long           qty = 0, key_val, ndx, BitForChangeFAS;
   C_INFO         *p_info = ptr_info();
   C_FAS          *p_fas = ptr_fas();
   C_ATTRIB_LIST  *p_attrib_list = ptr_attrib_list();
   ads_name       DA_block, ent;
   C_SELSET       DABlocks, GraphObjs, EntSS, ClassSS, ErasedHatch;
   C_PREPARED_CMD pFromOldCmd;
   _RecordsetPtr  pRs;
   C_STATUSLINE_MESSAGE StatusLineMsg(gsc_msg(1081)); // "Riallineamento banca dati"

   if (!p_info || !p_attrib_list) { GS_ERR_COD = eGSInvClassType; return GS_BAD; }

   // Se si tratta di una tabella collegata non posso cambiare i dati di tutta la tabella
   if (p_info->LinkedTable) { GS_ERR_COD = eGSClassLocked; return GS_BAD; }

   // setto i valori di UNDO, BLIPMODE, HIGHLIGHT per avere massima velocità di ACAD
   if ((env_variab << gsc_setVarForCommandSpeed()) == NULL) return GS_BAD;
   gsc_disableUndoRecording(true);

   // Setto l'operazione corrente
   OldOp = set_GS_CURRENT_OPERATION(MODIFY);

   do
   {
      session_dir = _T("GEOSIM_UPD_GRAPH_CLS");
      session_dir += id.code;
      if (WrkSession.set_name(session_dir.get_name()) == GS_BAD) break;

      session_dir = get_pPrj()->get_dir();
      session_dir += _T("\\GSUPDGPH_CLS");
      session_dir += id.code;
      if (WrkSession.set_dir(session_dir.get_name()) == GS_BAD) break;
      WrkSession.set_level(GSUpdateableData);
   
      // Alloca un oggetto C_INT
      if ((pcls_2_extract = new C_INT(id.code)) == NULL)
         { GS_ERR_COD = eGSOutOfMem; break; }
      cls_list_2_extract.add_tail(pcls_2_extract);

      // seleziono classe da estrarre, ed eseguo estrazione
      // effettuo estrazione rendendo la classe in sola lettura alle altre sessioni
      if (gsc_extract_classes(get_pPrj(), WrkSession, cls_list_2_extract, TRUE) == GS_BAD) break;

      // copio le informazioni della ID (questo oggetto potrebbe essere una copia 
      // della classe originale)
      get_pPrj()->find_class(id.code, id.sub_code)->ptr_id()->copy(&id);

      // se la classe è stata in modifica
      // (perchè bloccata da un'altra sessione di lavoro)
      if (id.abilit != GSUpdateableData) { GS_ERR_COD = eGSClassLocked; break; }

      if (gsc_callCmd(_T("_.ZOOM"), RTSTR, _T("_E"), 0) != RTNORM) break;

      // ricavo quali sono le caratteristiche grafiche modificabili della classe
      BitForChangeFAS = what_is_graph_updateable();

      if (BitForFAS) // se specificato
      {  // se si vuole cambiare la scala di una classe di tipo polilinea 
         // si intende la scala del tipolinea
         if (id.type == TYPE_POLYLINE && (*BitForFAS & GSBlockScaleSetting))
            *BitForFAS += GSLineTypeScaleSetting;
         BitForChangeFAS = BitForChangeFAS & *BitForFAS; // and a bit
      }

      // ricavo il gruppo di selezione di tutti gli oggetti della classe
      if (get_SelSet(ClassSS) != GS_GOOD) { result = GS_GOOD; break; }

      // preparo il comando per la ricerca e la modifica di un record
      if (prepare_data(pFromOldCmd, OLD) == GS_BAD) break;

      result = GS_GOOD;
      StatusLineMsg.Init(gsc_msg(310), LITTLE_STEP); // ogni 10 "%ld entità GEOsim elaborate."

      while (ClassSS.entname(0, ent) == GS_GOOD)
      {
         // leggo il valore chiave e il gruppo di selezione
         if (get_Key_SelSet(ent, &key_val , EntSS) == GS_BAD)
            { result = GS_BAD; break; }

         // ricavo un gruppo di selezione per gli oggetti grafici e uno per i blocchi DA
         if (EntSS.copy(GraphObjs) == GS_BAD || GraphObjs.intersectType(GRAPHICAL) == GS_BAD)
            { result = GS_BAD; break; }
         if (EntSS.copy(DABlocks) == GS_BAD || DABlocks.intersectType(DA_BLOCK) == GS_BAD)
            { result = GS_BAD; break; }

         if (change_fas == GS_GOOD)  // imposto la FAS di default
         {
            // cambio le caratteristiche grafiche degli oggetti principali
            if (gsc_modifyEntToFas(GraphObjs, p_fas, BitForChangeFAS) == GS_BAD)
               { result = GS_BAD; break; }

            if (id.type == TYPE_SURFACE)
            {
               if (EntSS.copy(ErasedHatch) == GS_BAD) { result = GS_BAD; break; }
               // Aggiorno i riempimenti modificando dummy
               // (solo i link con eventuali riempimenti modificati)
               if (gsc_UpdToDefHatch(EntSS, p_fas->hatch, p_fas->hatch_scale,
                                     p_fas->hatch_rotation, &(p_fas->hatch_color),
                                     p_fas->hatch_layer) == GS_BAD)
                  { result = GS_BAD; break; }
               ErasedHatch.subtract(EntSS); // i riempimenti cancellati
            }
         }

         // cerco nell'old bloccando il record
         if (gsc_get_data(pFromOldCmd, key_val, pRs, &IsRecordsetCloseable) != GS_GOOD)
         {  // Notifico in file log
            TCHAR Msg[MAX_LEN_MSG];
            swprintf(Msg, MAX_LEN_MSG, _T("Invalid key: key %ld, prj %d, class %d, subclass %d."), key_val,
                     get_PrjId(), id.code, id.sub_code);
            acutPrintf(_T("\n%s\n"), Msg);
            gsc_write_log(Msg);
            result = GS_BAD; break;
         }

         // lettura record
         if (gsc_DBReadRow(pRs, ColValues) == GS_BAD)
         {  // Notifico in file log
            TCHAR Msg[MAX_LEN_MSG];
            swprintf(Msg, MAX_LEN_MSG, _T("No graphical update: key %ld, prj %d, class %d, subclass %d."), key_val,
                     get_PrjId(), id.code, id.sub_code);
            acutPrintf(_T("\n%s\n"), Msg);
            gsc_write_log(Msg);
         }
         else
         {
            // validazione e ricalcolo dati
            if (CalcValidData(ColValues, MODIFY_ON_STRUCT_UPD, &EntSS) == GS_BAD)
               { result = GS_BAD; break; }
            // aggiorno il record
            if (gsc_DBUpdRow(pRs, ColValues) == GS_BAD)   // Converto campi data
               { result = GS_BAD; break; }
            if (IsRecordsetCloseable == GS_GOOD) gsc_DBCloseRs(pRs);

            if (AttribsDABlocksToUpd == GS_GOOD)
            {
               // aggiorno gli attributi visibili
               if (updtoDA(EntSS, ColValues, GS_GOOD) == GS_BAD)
                  { result = GS_BAD; break; }

               // Se non si tratta di testi
               if (!(id.category == CAT_SIMPLEX && id.type == TYPE_TEXT))
               {
                  ads_name NewDA;

                  // ricavo gli attributi visibili
                  if ((VisValues << p_attrib_list->get_vis_values(ColValues)) == GS_BAD)
                     { result = GS_BAD; break; }

                  ndx = 0;
                  while (DABlocks.entname(ndx++, DA_block) == GS_GOOD)
                  {
                     // aggiorno la lista degli attributi visibili
                     // aggiornando colore, (definizione da eventuale
                     // blocco di riferimento), layer (non per i singoli attributi)
                     if (gsc_upd_DA_attrib_list(DA_block, VisValues, key_val, 
                                                p_fas, NewDA, change_fas, MoveOldVisAttrib) == GS_BAD)
                        { result = GS_BAD; break; }
                     EntSS.add(NewDA);
                  }

                  if (result == GS_BAD) break;
               }

					// se esistono funzioni di calcolo grafico vengono applicate ora
					if (graph_calc(ColValues, &EntSS) == GS_BAD)
                  { result = GS_BAD; break; }
            }
            else
				{
					if (change_fas == GS_GOOD)  // imposto la FAS di default
					{
                  int DA_BitForChangeFAS = BitForChangeFAS;

                  // considero blocco, scala
                  // come caratteristiche dei blocchi DA che non vanno variate
                  if (DA_BitForChangeFAS & GSBlockNameSetting) DA_BitForChangeFAS -= GSBlockNameSetting;  // blocco
                  if (DA_BitForChangeFAS & GSBlockScaleSetting) DA_BitForChangeFAS -= GSBlockScaleSetting;  // scala

						// Il colore di default degli attributi del blocco è da blocco,
						// il colore del blocco per ora viene derivato dal colore del layer.
						// Questo anche se è una incongruenza torna utile in fase di stampa in cui lo
						// spessore del tratto è in funzione del colore e quindi si può cambiare il
						// colore degli attributi in modo agevole.
						PrevColor = p_fas->color;

						p_fas->color.setByLayer(); // DALAYER
						// cambio le caratteristiche grafiche degli oggetti DA
						if (gsc_modifyEntToFas(DABlocks, p_fas, DA_BitForChangeFAS) == GS_BAD)
							{ p_fas->color = PrevColor; result = GS_BAD; break; }
						p_fas->color = PrevColor;
					}

					// se esistono funzioni di calcolo grafico vengono applicate ora
					if (graph_calc(ColValues, &EntSS) == GS_BAD) return GS_BAD;
				}
         }

         if (gsc_addSS2savess(EntSS) == GS_BAD) { result = GS_BAD; break; }
         // elimino il gruppo di selezione dal gruppo della classe
         if (ClassSS.subtract(EntSS) == GS_BAD) { result = GS_BAD; break; }
         if (ErasedHatch.length() > 0)
         {
            if (gsc_addSS2savess(ErasedHatch) == GS_BAD) { result = GS_BAD; break; }
            if (ClassSS.subtract(ErasedHatch) == GS_BAD) { result = GS_BAD; break; }
            ErasedHatch.clear();
         }

         StatusLineMsg.Set(++qty); // "%ld entità GEOsim elaborate."
      }
      
      if (IsRecordsetCloseable == GS_GOOD) gsc_DBCloseRs(pRs);

      StatusLineMsg.End(gsc_msg(310), qty); // "%ld entità GEOsim elaborate."

      if (result == GS_BAD) break;

      // salvataggio della parte grafica delle entità di GEOsim considerando
      // la sorgente grafica della classe originale (che è quella usata per l'estrazione
      // e che quindi contiene tutti i link tra grafica e db in caso geometrica in DB)
      if (get_pPrj()->find_class(id.code)->save_GeomData() == GS_BAD)
         { result = GS_BAD; break; }

      result = GS_GOOD;
   }
   while (0);

   // Setto l'operazione corrente
   set_GS_CURRENT_OPERATION(OldOp);

   // rispristino i valori precedenti di UNDO, BLIPMODE, HIGHLIGHT
   gsc_disableUndoRecording(false);
   gsc_setVarForCommandNormal(env_variab.get_head());

   // uscita dalla sessione di lavoro
   if (GS_CURRENT_WRK_SESSION)
   { 
      // Inizializzo queste variabili prima di chiamare gsc_ExitCurrSession che 
      // toglie dalla memoria questa classe
      TCHAR Msg[256];
      int  Prj = get_PrjId(), Cls = id.code; 
      swprintf(Msg, 256, gsc_msg(289), id.name);

      // rilascio tutti i DWG della classe altrimenti non si potrebbe
      // ristorare il backup dei DWG che risulterebbero in uso
      GphDetach();
		// uscita dalla sessione di lavoro
      if (gsc_ExitCurrSession() == GS_GOOD)
      {
         // "Messaggio GEOsim: La classe <%s> non è più in uso esclusivo."
         gsc_NotifyWaitForSave(Prj, Cls, Msg);
         gsc_NotifyWaitForExtraction(Prj, Cls, Msg);
      }
   }

   return result;
}


/*****************************************************************************/
/*.doc C_SPAGHETTI::UpdGraphData <internal> */
/*+
  Questa funzione aggiorna tutti gli oggetti grafici della classe per allinearli
  al cambio di FAS.
  Parametri:
  int change_fas;    usato solo per compatibilità
  long *BitForFAS;   flag a bit indicante le caratteristiche grafiche da cambiare,
                     opzionale, se = NULL significa tutta la FAS (default = NULL)
  int AttribsDABlocksToUpd;   usato per compatibilità
  int MoveOldVisAttrib;       usato per compatibilità

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*****************************************************************************/
int C_SPAGHETTI::UpdGraphData(int change_fas, long *BitForFAS, int AttribsDABlocksToUpd,
                              int MoveOldVisAttrib)
{
   int        result = GS_BAD;
   C_RB_LIST  env_variab;
   C_INT_LIST cls_list_2_extract;
   C_INT      *pcls_2_extract;
   C_STRING   session_dir;
   C_WRK_SESSION WrkSession(get_pPrj());
   long       qty, BitForChangeFAS;
   C_FAS      *p_fas = ptr_fas();
   ads_name   GraphObjs;
   C_ID       *p_id = ptr_id();

   // setto i valori di UNDO, BLIPMODE, HIGHLIGHT per avere massima velocità di ACAD
   if ((env_variab << gsc_setVarForCommandSpeed()) == NULL) return GS_BAD;
   gsc_disableUndoRecording(true);

   ads_name_clear(GraphObjs);
   
   do
   {
      session_dir = _T("GEOSIM_UPD_GRAPH_CLS");
      session_dir += id.code;
      if (WrkSession.set_name(session_dir.get_name()) == GS_BAD) break;

      session_dir = get_pPrj()->get_dir();
      session_dir += _T("\\GSUPDGPH_CLS");
      session_dir += id.code;
      if (WrkSession.set_dir(session_dir.get_name()) == GS_BAD) break;
      WrkSession.set_level(GSUpdateableData);

      // Alloca un oggetto C_INT
      if ((pcls_2_extract = new C_INT(id.code)) == NULL)
         { GS_ERR_COD = eGSOutOfMem; break; }
      cls_list_2_extract.add_tail(pcls_2_extract);
      
      // seleziono classe da estrarre, ed eseguo estrazione
      // effettuo estrazione rendendo la classe in sola lettura alle altre sessioni
      if (gsc_extract_classes(get_pPrj(), WrkSession, cls_list_2_extract, TRUE) == GS_BAD) break;

      // copio le informazioni della ID (questo oggetto potrebbe essere una copia 
      // della classe originale)
      get_pPrj()->find_class(id.code, id.sub_code)->ptr_id()->copy(p_id);

      // se la classe è stata in modifica
      // (perchè bloccata da un'altra sessione di lavoro)
      if (p_id->abilit != GSUpdateableData) { GS_ERR_COD = eGSClassLocked; break; }

      if (gsc_callCmd(_T("_.ZOOM"), RTSTR, _T("_E"), 0) != RTNORM) break;
 
      // ricavo quali sono le caratteristiche grafiche modificabili della classe
      BitForChangeFAS = what_is_graph_updateable();

      if (BitForFAS) // se specificato
         BitForChangeFAS = BitForChangeFAS & *BitForFAS; // and a bit

      result = GS_GOOD;

      // seleziono tutti gli oggetti della classe
      if (acedSSGet(_T("_X"), NULL, NULL, NULL, GraphObjs) != RTNORM) break;

      if (gsc_modifyEntToFas(GraphObjs, p_fas, BitForChangeFAS) == GS_BAD)
         { result = GS_BAD; break; }

      ads_sslength(GraphObjs, &qty);
      acutPrintf(gsc_msg(491), qty); // "\n%ld entità GEOsim elaborate.\n"

      if (gsc_addSS2savess(GraphObjs) == GS_BAD) { result = GS_BAD; break; }

      // salvataggio della parte grafica delle entità di GEOsim considerando
      // la sorgente grafica della classe originale (che è quella usata per l'estrazione
      // e che quindi contiene tutti i link tra grafica e db in caso geometrica in DB)
      if (get_pPrj()->find_class(id.code)->save_GeomData() == GS_BAD)
         { result = GS_BAD; break; }

      result = GS_GOOD;
   }
   while (0);

   if (!ads_name_nil(GraphObjs)) ads_ssfree(GraphObjs);

   // rispristino i valori precedenti di UNDO, BLIPMODE, HIGHLIGHT
   gsc_disableUndoRecording(false);
   gsc_setVarForCommandNormal(env_variab.get_head());

   // uscita dalla sessione di lavoro
   if (GS_CURRENT_WRK_SESSION)
   {
      // Inizializzo queste variabili prima di chiamare gsc_ExitCurrSession che 
      // toglie dalla memoria questa classe
      TCHAR Msg[256];
      int  Prj = get_PrjId(), Cls = id.code; 
      swprintf(Msg, 256, gsc_msg(289), id.name);
      
      // rilascio tutti i DWG della classe altrimenti non si potrebbe
      // ristorare il backup dei DWG che risulterebbero in uso
      GphDetach();
      // uscita dalla sessione di lavoro
      if (gsc_ExitCurrSession() == GS_BAD) return GS_BAD;

      // "Messaggio GEOsim: La classe <%s> non è più in uso esclusivo."
      gsc_NotifyWaitForSave(Prj, Cls, Msg);
      gsc_NotifyWaitForExtraction(Prj, Cls, Msg);
   }

   return result;
}


/********************************************************************************/
/*.doc AlignGraphDataOnCopyClass                                     <internal> */
/*+
  Questa funzione copia tutti gli oggetti grafici della classe
  in una nuova classe e allineando i marker ed eventualmente la fas.
  Parametri:
  C_CLASS *new_cls;   puntatore alla classe destinazione della copia

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
  N.B. in caso di simulazione bisogna passare esclusivamente la classe madre e non la
       singola sotto-classe !!
-*/  
/********************************************************************************/
int C_CLASS::AlignGraphDataOnCopyClass(C_CLASS *new_cls)
{
   int            result = GS_GOOD, AttribsDABlocksToUpd = GS_BAD, OldCMDDIA;
   int            OldPrj, NewPrj, OldCls, NewCls;
   C_RB_LIST      env_variab, VisValues, ColValues;
   C_INT_LIST     cls_list_2_extract;
   C_INT          *pcls_2_extract;
   C_STRING       session_dir, oldtable, newtable;
   C_WRK_SESSION  WrkSession(get_pPrj());
   long           qty = 0, key_val, ndx, BitForChangeFAS, BitForDiffFAS;
   C_FAS          *p_old_fas, *p_new_fas;
   ads_name       DA_block, ent;
   C_MAP_ENV      AdeEnv;
   C_EED          eed;
   C_CLASS        *pNewClass, *pOldClass;
   C_ID           *p_old_id, *p_new_id;
   C_SELSET       DABlocks, GraphObjs, EntSS, ClassSS, GlobalSS;
   C_LINK         Link;
   C_LINK_SET     LinkSet;
   C_PREPARED_CMD pFromOldCmd;
   C_STATUSLINE_MESSAGE StatusLineMsg(gsc_msg(1081)); // "Riallineamento banca dati"

   if (GS_CURRENT_WRK_SESSION) { GS_ERR_COD = eGSSessionsFound; return GS_BAD; }

   // setto i valori di UNDO, BLIPMODE, HIGHLIGHT per avere massima velocità di ACAD
   if ((env_variab << gsc_setVarForCommandSpeed()) == NULL) return GS_BAD;
   gsc_disableUndoRecording(true);

   OldPrj = get_pPrj()->get_key();
   NewPrj = new_cls->ptr_id()->pPrj->get_key();
   OldCls = id.code;
   NewCls = new_cls->ptr_id()->code;

   do
   {
      gsc_set_cmddia(0, &OldCMDDIA); // Setto CMDDIA a 0

      session_dir = _T("GEOSIM_COPY_GRAPH_CLS");
      session_dir += OldCls;
      if (WrkSession.set_name(session_dir.get_name()) == GS_BAD) break;

      session_dir = get_pPrj()->get_dir();
      session_dir += _T("\\GSCOPYGPH_CLS");
      session_dir += OldCls;
      if (WrkSession.set_dir(session_dir.get_name()) == GS_BAD) break;
      
      WrkSession.set_level(GSUpdateableData);

      // imposto lo srid della sessione corrente come quello della classe sorgente
      C_GPH_INFO *pGphInfo; // roby
      C_STRING   *pAutocadSRID = NULL;
      if (get_category() == CAT_EXTERN)
         pGphInfo = ((C_SUB *) ptr_sub_list()->get_head())->ptr_GphInfo();
      else
         pGphInfo = ptr_GphInfo();

      if (pGphInfo->getDataSourceType() == GSDBGphDataSource)
         pAutocadSRID = ((C_DBGPH_INFO *) pGphInfo)->get_ClsSRID_converted_to_AutocadSRID();
      else
         pAutocadSRID = &(pGphInfo->coordinate_system);
      if (pAutocadSRID) WrkSession.set_coordinate(pAutocadSRID->get_name());

      // seleziono la classe origine per la prossima estrazione
      if ((pcls_2_extract = new C_INT(OldCls)) == NULL)
         { GS_ERR_COD = eGSOutOfMem; break; }
      cls_list_2_extract.add_tail(pcls_2_extract);

      // seleziono classe da estrarre, ed eseguo estrazione
      // effettuo estrazione rendendo la classe in sola lettura alle altre sessioni
      if (gsc_extract_classes(get_pPrj(),             // progetto
                              WrkSession,             // sessione di lavoro
                              cls_list_2_extract,     // lista classi
                              TRUE,                   // estrazione in esclusiva
                              NULL,                   // condizione spaziale
                              NULL,                   // condizione di proprietà
                              FALSE,                  // forma NOT oppure no
                              EXTRACTION,             // modo di estrazione
                              &GlobalSS) == GS_BAD)   // gruppo di selezione estratto
         break;

      GphDetach(); // rilascio tutti i DWG della classe sorgente

      if (gsc_callCmd(_T("_.ZOOM"), RTSTR, _T("_E"), 0) != RTNORM) break;

      acutPrintf(_T("%s %s..."), gsc_msg(394), id.name);//"\nAggiornamento dati classe"
      StatusLineMsg.Init(gsc_msg(310), LITTLE_STEP); // ogni 10 "%ld entità GEOsim elaborate."

      if (get_category() == CAT_EXTERN)
      {
         pOldClass = (C_SUB *) ptr_sub_list()->get_head();
         pNewClass = (C_SUB *) new_cls->ptr_sub_list()->get_head();
      }
      else
      {
         pOldClass = this;
         pNewClass = new_cls;
      }

      acutPrintf(GS_LFSTR);
      do
      {
         p_new_fas = pNewClass->ptr_fas();
         p_old_id  = pOldClass->ptr_id();
         p_old_fas = pOldClass->ptr_fas();

         if (get_category() == CAT_EXTERN)
            // Filtro gli oggetti appartenenti alla sotto-classe
            GlobalSS.copyIntersectClsCode(ClassSS, OldCls, p_old_id->sub_code);
         else
            GlobalSS.copy(ClassSS);
        
         // Verifico le caratteristiche variate rispetto alla FAS originale
         BitForDiffFAS = p_old_fas->get_GraphDifferences(*p_new_fas);

         if (BitForDiffFAS != GSNoneSetting)  // cambio la FAS
         {
            // preparo il comando per la ricerca e la modifica di un record della vecchia classe
            if (pOldClass->prepare_data(pFromOldCmd, OLD) == GS_BAD)
               { result = GS_BAD; break; }
            ColValues.remove_all();

            // ricavo un gruppo di selezione per gli oggetti grafici della classe o sottoclasse corrente
            if (ClassSS.copy(GraphObjs) == GS_BAD || GraphObjs.intersectType(GRAPHICAL) == GS_BAD)
               { result = GS_BAD; break; }

            // ricavo quali sono le caratteristiche grafiche modificabili della nuova classe
            BitForChangeFAS = pNewClass->what_is_graph_updateable();

            // considero elevazione, rotazione
            // come caratteristiche geometriche che non vanno variate in fase di copia
            if (BitForChangeFAS & GSElevationSetting) BitForChangeFAS -= GSElevationSetting;
            if (BitForChangeFAS & GSRotationSetting) BitForChangeFAS -= GSRotationSetting;

            // Considero solo le caratteristiche variate rispetto alla FAS della 
            // classe originale
            BitForChangeFAS = BitForChangeFAS & BitForDiffFAS;

            // cambio la FAS
            if (gsc_modifyEntToFas(GraphObjs, p_new_fas, BitForChangeFAS) == GS_BAD)
               { result = GS_BAD; break; }

            // flag indicante se si devono aggiornare i singoli attributi dei blocchi DA
            // se la classe utilizza una funzione di calcolo grafico
            if (p_new_fas && p_new_fas->is_graph_calculated() == GS_GOOD)
               AttribsDABlocksToUpd = GS_GOOD;
            // se la classe utilizza un blocco di riferimento
            if (p_new_fas && p_new_fas->ref_block && wcslen(p_new_fas->ref_block) > 0)
               AttribsDABlocksToUpd = GS_GOOD;

            while (ClassSS.entname(0, ent) == GS_GOOD)
            {  
               // leggo il valore chiave e il gruppo di selezione
               if (pOldClass->get_Key_SelSet(ent, &key_val, EntSS) == GS_BAD)
                  { result = GS_BAD; break; }

               // ricavo un gruppo di selezione per gli oggetti grafici e uno per i blocchi DA
               if (EntSS.copy(GraphObjs) == GS_BAD || GraphObjs.intersectType(GRAPHICAL) == GS_BAD)
                  { result = GS_BAD; break; }
               if (EntSS.copy(DABlocks) == GS_BAD || DABlocks.intersectType(DA_BLOCK) == GS_BAD)
                  { result = GS_BAD; break; }

               if (AttribsDABlocksToUpd == GS_GOOD)
               {
                  // cerco nell'old
                  if (gsc_get_data(pFromOldCmd, key_val, ColValues) == GS_BAD)
                  {  // Notifico in file log
                     TCHAR Msg[MAX_LEN_MSG];
                     swprintf(Msg, MAX_LEN_MSG, _T("No graphical update: key %ld, prj %d, class %d, subclass %d."), key_val,
                              get_PrjId(), p_old_id->code, p_old_id->sub_code);
                     gsc_write_log(Msg);
                     acutPrintf(Msg);
                     result = GS_BAD;
                     break;
                  }

                  // se non è testo
                  if (!(p_old_id->category == CAT_SIMPLEX && p_old_id->type == TYPE_TEXT))
                  {
                     // ricavo gli attributi visibili
                     if ((VisValues << pOldClass->ptr_attrib_list()->get_vis_values(ColValues)) == GS_BAD)
                        return GS_BAD;

                     ndx = 0;
                     while (DABlocks.entname(ndx++, DA_block) == GS_GOOD)
                     {
                        // aggiorno la lista degli attributi visibili
                        // aggiornando colore, (definizione da eventuale
                        // blocco di riferimento), layer (non per i singoli attributi)
                        if (gsc_upd_DA_attrib_list(DA_block, VisValues, key_val, 
                                                   p_new_fas, NULL, GS_GOOD) == GS_BAD) // roby 2015
                           { result = GS_BAD; break; }
                     }        

                     if (result == GS_BAD) break;
                  }

					   // se esistono funzioni di calcolo grafico vengono applicate ora
					   if (pNewClass->graph_calc(ColValues, &EntSS) == GS_BAD)
                     { result = GS_BAD; break; }
               }
               else
               {
                  int DA_BitForChangeFAS = BitForChangeFAS;

                  // considero blocco, scala
                  // come caratteristiche dei blocchi DA 
                  // che non vanno variate in fase di copia 
                  if (DA_BitForChangeFAS & GSBlockNameSetting) DA_BitForChangeFAS -= GSBlockNameSetting;  // blocco
                  if (DA_BitForChangeFAS & GSBlockScaleSetting) DA_BitForChangeFAS -= GSBlockScaleSetting;  // scala
               
                  // imposto la FAS di default
                  if (gsc_modifyEntToFas(DABlocks, p_new_fas, DA_BitForChangeFAS) == GS_BAD)
                     { result = GS_BAD; break; }
               }

               if (result == GS_BAD) break;

               // elimino il gruppo di selezione dal gruppo della classe
               if (ClassSS.subtract(EntSS) == GS_BAD) { result = GS_BAD; break; }

               StatusLineMsg.Set(++qty); // "%ld entità GEOsim elaborate."
            }
            if (result == GS_BAD) break;
         }

         // uscita in caso di classe non simulazione (non ha sotto-classi)
         if (get_category() != CAT_EXTERN) break;

         pNewClass = (C_SUB *) new_cls->ptr_sub_list()->get_next();
         pOldClass = (C_SUB *) ptr_sub_list()->get_next();
      }
      while (pNewClass && pOldClass);

      StatusLineMsg.End(gsc_msg(310), qty); // "%ld entità GEOsim elaborate."

      if (result == GS_BAD) break;

      // Cambio codice classe nella tabella dei link
      C_STRING       Statement, TableRef;
      C_DBCONNECTION *pConn;

      if (GS_CURRENT_WRK_SESSION->getLinksTabInfo(&pConn, &TableRef) == GS_BAD) { result = GS_BAD; break; }
      Statement = _T("UPDATE ");
      Statement += TableRef;
      Statement += _T(" SET CLASS_ID=");
      Statement += NewCls;
      if (pConn->ExeCmd(Statement) == GS_BAD) { result = GS_BAD; break; }

      // se sono stati re-inseriti dei blocchi DA devo ricavare nuovamente il gruppo di entità della classe
      gsc_ssget(_T("_X"), NULL, NULL, NULL, GlobalSS);

      ndx = 0; // cambio solo le EED
      while (GlobalSS.entname(ndx++, ent) == GS_GOOD)
         // L'entità viene aggiunta anche in GEOsimAppl::SAVE_SS
	      eed.set_cls(ent, NewCls);

      if (get_category() == CAT_EXTERN)
      {
         pOldClass = (C_SUB *) ptr_sub_list()->get_head();
         pNewClass = (C_SUB *) new_cls->ptr_sub_list()->get_head();
      }
      else
      {
         pOldClass = this;
         pNewClass = new_cls;
      }

      do
      {
         p_new_id = pNewClass->ptr_id();
         p_old_id = pOldClass->ptr_id();

         // Filtro gli oggetti appartenenti alla classe o sotto-classe
         GlobalSS.copyIntersectClsCode(ClassSS, OldCls, p_old_id->sub_code);

         // cambio il nome della tabella OD
         // ricavo il nome della vecchia tabella interna 
         gsc_getODTableName(OldPrj, OldCls, p_old_id->sub_code, oldtable);
         // ricavo il nome della nuova tabella interna creandola se non esiste
         gsc_setODTable(NewPrj, NewCls, p_new_id->sub_code, &newtable);

         acutPrintf(gsc_msg(56), oldtable.get_name(), newtable.get_name()); // "\nCambio tabella dati oggetto (da %s a %s)...\n"
         ndx    = 0;
         while (ClassSS.entname(ndx++, ent) == GS_GOOD)
            // L'entità viene aggiunta anche in GEOsimAppl::SAVE_SS
            if (gsc_renODTable(ent, oldtable, newtable) == GS_BAD)
               { result = GS_BAD; break; }

         // cancello la vecchia tabella della classe
         if (gsc_oddeletetab(oldtable.get_name()) != GS_GOOD) { result = GS_BAD; break; }

         // uscita in caso di classe non simulazione (non ha sotto-classi)
         if (get_category() != CAT_EXTERN) break;

         pNewClass = (C_SUB *) new_cls->ptr_sub_list()->get_next();
         pOldClass = (C_SUB *) ptr_sub_list()->get_next();
      }
      while (pNewClass && pOldClass);

      if (result == GS_BAD) break;

      // salvataggio modifiche degli oggetti nei disegni di origine
      if (new_cls->save_GeomData() == GS_BAD)
		   { result = GS_BAD; break; }

      result = GS_GOOD;
   }
   while (0);

   // rispristino i valori precedenti di UNDO, BLIPMODE, HIGHLIGHT
   gsc_disableUndoRecording(false);
   gsc_setVarForCommandNormal(env_variab.get_head());
   // Rispristino CMDDIA
   gsc_set_cmddia(OldCMDDIA);

   // inizializzo le variabili d'ambiente ADE per GEOsim
   AdeEnv.SetEnv4GEOsim();

   if (GS_CURRENT_WRK_SESSION)
   {  // rilascio tutti i DWG della classe destinazione 
      // altrimenti non si potrebbe
      // ristorare il backup dei DWG che risulterebbero in uso
      new_cls->GphDetach();
      // uscita dalla sessione di lavoro
      if (gsc_ExitCurrSession() == GS_BAD) return GS_BAD;
   }

   return result;
}
//int C_CLASS::AlignGraphDataOnCopyClass(C_CLASS *new_cls)
//{
//   int            result = GS_BAD, AttribsDABlocksToUpd = GS_BAD, OldCMDDIA;
//   int            OldPrj, NewPrj, OldCls, NewCls;
//   C_RB_LIST      env_variab, VisValues, ColValues;
//   C_INT_LIST     cls_list_2_extract;
//   C_INT          *pcls_2_extract;
//   C_STRING       session_dir, oldtable, newtable;
//   C_WRK_SESSION  WrkSession(get_pPrj());
//   long           qty = 0, key_val, ndx, BitForChangeFAS, BitForDiffFAS;
//   C_FAS          *p_old_fas, *p_new_fas;
//   ads_name       DA_block, ent;
//   C_MAP_ENV      AdeEnv;
//   C_EED          eed;
//   C_CLASS        *pNewClass, *pOldClass;
//   C_ATTRIB_LIST  *p_new_attr_list;
//   C_ID           *p_old_id, *p_new_id;
//   C_SELSET       DABlocks, GraphObjs, EntSS, ClassSS, GlobalSS;
//   C_LINK         Link;
//   C_LINK_SET     LinkSet;
//   C_PREPARED_CMD pFromOldCmd;
//   C_STATUSLINE_MESSAGE StatusLineMsg(gsc_msg(1081)); // "Riallineamento banca dati"
//
//   if (GS_CURRENT_WRK_SESSION) { GS_ERR_COD = eGSSessionsFound; return GS_BAD; }
//
//   // setto i valori di UNDO, BLIPMODE, HIGHLIGHT per avere massima velocità di ACAD
//   if ((env_variab << gsc_setVarForCommandSpeed()) == NULL) return GS_BAD;
//   gsc_disableUndoRecording(true);
//
//   OldPrj = get_pPrj()->get_key();
//   NewPrj = new_cls->ptr_id()->pPrj->get_key();
//   OldCls = id.code;
//   NewCls = new_cls->ptr_id()->code;
//
//   do
//   {
//      gsc_set_cmddia(0, &OldCMDDIA); // Setto CMDDIA a 0
//
//      session_dir = _T("GEOSIM_COPY_GRAPH_CLS");
//      session_dir += OldCls;
//      if (WrkSession.set_name(session_dir.get_name()) == GS_BAD) break;
//
//      session_dir = get_pPrj()->get_dir();
//      session_dir += _T("\\GSCOPYGPH_CLS");
//      session_dir += OldCls;
//      if (WrkSession.set_dir(session_dir.get_name()) == GS_BAD) break;
//      
//      WrkSession.set_level(GSUpdateableData);
//
//      // imposto lo srid della sessione corrente come quello della classe sorgente
//      C_GPH_INFO *pGphInfo;
//      C_STRING   *pAutocadSRID = NULL;
//      if (get_category() == CAT_EXTERN)
//         pGphInfo = ((C_SUB *) ptr_sub_list()->get_head())->ptr_GphInfo();
//      else
//         pGphInfo = ptr_GphInfo();
//
//      if (pGphInfo->getDataSourceType() == GSDBGphDataSource)
//         pAutocadSRID = ((C_DBGPH_INFO *) pGphInfo)->get_ClsSRID_converted_to_AutocadSRID();
//      else
//         pAutocadSRID = &(pGphInfo->coordinate_system);
//      if (pAutocadSRID) WrkSession.set_coordinate(pAutocadSRID->get_name());
//
//      // seleziono la classe origine per la prossima estrazione
//      if ((pcls_2_extract = new C_INT(OldCls)) == NULL)
//         { GS_ERR_COD = eGSOutOfMem; break; }
//      cls_list_2_extract.add_tail(pcls_2_extract);
//
//      // seleziono classe da estrarre, ed eseguo estrazione
//      // effettuo estrazione rendendo la classe in sola lettura alle altre sessioni
//      if (gsc_extract_classes(get_pPrj(),             // progetto
//                              WrkSession,             // sessione di lavoro
//                              cls_list_2_extract,     // lista classi
//                              TRUE,                   // estrazione in esclusiva
//                              NULL,                   // condizione spaziale
//                              NULL,                   // condizione di proprietà
//                              FALSE,                  // forma NOT oppure no
//                              EXTRACTION,             // modo di estrazione
//                              &GlobalSS) == GS_BAD)   // gruppo di selezione estratto
//         break;
//
//      GphDetach(); // rilascio tutti i DWG della classe sorgente
//
//      if (gsc_callCmd(_T("_.ZOOM"), RTSTR, _T("_E"), 0) != RTNORM) break;
//
//      acutPrintf(_T("%s %s..."), gsc_msg(394), id.name);//"\nAggiornamento dati classe"
//
//      // Cambio codice classe nella tabella dei link
//      C_STRING       Statement, TableRef;
//      C_DBCONNECTION *pConn;
//
//      StatusLineMsg.Init(gsc_msg(310), LITTLE_STEP); // ogni 10 "%ld entità GEOsim elaborate."
//
//      if (GS_CURRENT_WRK_SESSION->getLinksTabInfo(&pConn, &TableRef) == GS_BAD) break;
//      Statement = _T("UPDATE ");
//      Statement += TableRef;
//      Statement += _T(" SET CLASS_ID=");
//      Statement += NewCls;
//      if (pConn->ExeCmd(Statement) == GS_BAD) break;
//
//      ndx = 0; // cambio solo le EED
//      while (GlobalSS.entname(ndx++, ent) == GS_GOOD)
//         // L'entità viene aggiunta anche in GEOsimAppl::SAVE_SS
//	      eed.set_cls(ent, NewCls);
//
//      if (get_category() == CAT_EXTERN)
//      {
//         pOldClass = (C_SUB *) ptr_sub_list()->get_head();
//         pNewClass = (C_SUB *) new_cls->ptr_sub_list()->get_head();
//      }
//      else
//      {
//         ads_name SelSet;
//
//         pOldClass = this;
//         pNewClass = new_cls;
//         GlobalSS.get_selection(SelSet);
//         ClassSS << SelSet;
//         GlobalSS.ReleaseAllAtDistruction(GS_BAD);
//      }
//
//      acutPrintf(GS_LFSTR);
//      do
//      {
//         p_new_attr_list = pNewClass->ptr_attrib_list();
//         p_new_id        = pNewClass->ptr_id();
//         p_new_fas       = pNewClass->ptr_fas();
//         p_old_id        = pOldClass->ptr_id();
//         p_old_fas       = pOldClass->ptr_fas();
//
//         if (get_category() == CAT_EXTERN)
//            // Filtro gli oggetti appartenenti alla sotto-classe
//            GlobalSS.copyIntersectClsCode(ClassSS, NewCls, p_new_id->sub_code);
//
//         // cambio il nome della tabella OD
//         // ricavo il nome della vecchia tabella interna 
//         gsc_getODTableName(OldPrj, OldCls, p_old_id->sub_code, oldtable);
//         // ricavo il nome della nuova tabella interna creandola se non esiste
//         gsc_setODTable(NewPrj, NewCls, p_new_id->sub_code, &newtable);
//
//         acutPrintf(gsc_msg(56), oldtable.get_name(), newtable.get_name()); // "\nCambio tabella dati oggetto (da %s a %s)...\n"
//         ndx    = 0;
//         result = GS_GOOD;
//         while (ClassSS.entname(ndx++, ent) == GS_GOOD)
//            // L'entità viene aggiunta anche in GEOsimAppl::SAVE_SS
//            if (gsc_renODTable(ent, oldtable, newtable) == GS_BAD)
//               { result = GS_BAD; break; }
//
//         if (result == GS_BAD) break;
//         
//         // Verifico le caratteristiche variate rispetto alla FAS originale
//         BitForDiffFAS = p_old_fas->get_GraphDifferences(*p_new_fas);
//
//         if (BitForDiffFAS != GSNoneSetting)  // cambio la FAS
//         {
//            // preparo il comando per la ricerca e la modifica di un record della nuova classe
//            if (pNewClass->prepare_data(pFromOldCmd, OLD) == GS_BAD)
//               { result = GS_BAD; break; }
//            ColValues.remove_all();
//
//            // ricavo un gruppo di selezione per gli oggetti grafici della classe o sottoclasse corrente
//            if (ClassSS.copy(GraphObjs) == GS_BAD || GraphObjs.intersectType(GRAPHICAL) == GS_BAD)
//               { result = GS_BAD; break; }
//
//            // ricavo quali sono le caratteristiche grafiche modificabili della nuova classe
//            BitForChangeFAS = pNewClass->what_is_graph_updateable();
//
//            // considero elevazione, rotazione
//            // come caratteristiche geometriche che non vanno variate in fase di copia
//            if (BitForChangeFAS & GSElevationSetting) BitForChangeFAS -= GSElevationSetting;  // elevazione
//            if (BitForChangeFAS & GSRotationSetting) BitForChangeFAS -= GSRotationSetting;  // rotazione
//
//            // Considero solo le caratteristiche variate rispetto alla FAS della 
//            // classe originale
//            BitForChangeFAS = BitForChangeFAS & BitForDiffFAS;
//
//            // cambio la FAS
//            if (gsc_modifyEntToFas(GraphObjs, p_new_fas, BitForChangeFAS) == GS_BAD)
//               { result = GS_BAD; break; }
//
//            // flag indicante se si devono aggiornare i singoli attributi dei blocchi DA
//            // se la classe utilizza una funzione di calcolo grafico
//            if (p_new_fas && p_new_fas->is_graph_calculated() == GS_GOOD)
//               AttribsDABlocksToUpd = GS_GOOD;
//            // se la classe utilizza un blocco di riferimento
//            if (p_new_fas && p_new_fas->ref_block && wcslen(p_new_fas->ref_block) > 0)
//               AttribsDABlocksToUpd = GS_GOOD;
//
//            while (ClassSS.entname(0, ent) == GS_GOOD)
//            {  
//               // leggo il valore chiave e il gruppo di selezione
//               if (pNewClass->get_Key_SelSet(ent, &key_val, EntSS) == GS_BAD)
//                  { result = GS_BAD; break; }
//
//               // ricavo un gruppo di selezione per gli oggetti grafici e uno per i blocchi DA
//               if (EntSS.copy(GraphObjs) == GS_BAD || GraphObjs.intersectType(GRAPHICAL) == GS_BAD)
//                  { result = GS_BAD; break; }
//               if (EntSS.copy(DABlocks) == GS_BAD || DABlocks.intersectType(DA_BLOCK) == GS_BAD)
//                  { result = GS_BAD; break; }
//
//               if (AttribsDABlocksToUpd == GS_GOOD)
//               {
//                  // se non è testo
//                  if (!(p_new_id->category == CAT_SIMPLEX && p_new_id->type == TYPE_TEXT))
//                  {
//                     // cerco nell'old
//                     if (gsc_get_data(pFromOldCmd, key_val, ColValues) == GS_BAD)
//                     {  // Notifico in file log
//                        TCHAR Msg[MAX_LEN_MSG];
//                        swprintf(Msg, MAX_LEN_MSG, _T("No graphical update: key %ld, prj %d, class %d, subclass %d."), key_val,
//                                 get_PrjId(), ptr_id()->code, ptr_id()->sub_code);
//                        gsc_write_log(Msg);
//                        acutPrintf(Msg);
//                        result = GS_BAD;
//                        break;
//                     }
//
//                     // ricavo gli attributi visibili
//                     if ((VisValues << p_new_attr_list->get_vis_values(ColValues)) == GS_BAD)
//                        return GS_BAD;
//
//                     ndx = 0;
//                     while (DABlocks.entname(ndx++, DA_block) == GS_GOOD)
//                     {
//                        // aggiorno la lista degli attributi visibili
//                        // aggiornando colore, (definizione da eventuale
//                        // blocco di riferimento), layer (non per i singoli attributi)
//                        if (gsc_upd_DA_attrib_list(DA_block, VisValues, key_val, 
//                                                   p_new_fas, NULL, GS_GOOD) == GS_BAD)
//                           { result = GS_BAD; break; }
//                     }        
//
//                     if (result == GS_BAD) break;
//                  }
//               }
//               else
//               {
//                  int DA_BitForChangeFAS = BitForChangeFAS;
//
//                  // considero blocco, scala
//                  // come caratteristiche dei blocchi DA 
//                  // che non vanno variate in fase di copia 
//                  if (DA_BitForChangeFAS & GSBlockNameSetting) DA_BitForChangeFAS -= GSBlockNameSetting;  // blocco
//                  if (DA_BitForChangeFAS & GSBlockScaleSetting) DA_BitForChangeFAS -= GSBlockScaleSetting;  // scala
//               
//                  // imposto la FAS di default
//                  if (gsc_modifyEntToFas(DABlocks, p_new_fas, DA_BitForChangeFAS) == GS_BAD)
//                     { result = GS_BAD; break; }
//               }
//
//               if (result == GS_BAD) break;
//
//               // elimino il gruppo di selezione dal gruppo della classe
//               if (ClassSS.subtract(EntSS) == GS_BAD) { result = GS_BAD; break; }
//
//               StatusLineMsg.Set(++qty); // "%ld entità GEOsim elaborate."
//            }
//            if (result == GS_BAD) break;
//         }
//
//         // cancello la vecchia tabella della classe
//         if (gsc_oddeletetab(oldtable.get_name()) != GS_GOOD) { result = GS_BAD; break; }
//
//         // uscita in caso di classe non simulazione (non ha sotto-classi)
//         if (get_category() != CAT_EXTERN) break;
//
//         pNewClass = (C_SUB *) new_cls->ptr_sub_list()->get_next();
//         pOldClass = (C_SUB *) ptr_sub_list()->get_next();
//      }
//      while (pNewClass && pOldClass);
//
//      StatusLineMsg.End(gsc_msg(310), qty); // "%ld entità GEOsim elaborate."
//
//      if (result == GS_BAD) break;
//
//      // salvataggio modifiche degli oggetti nei disegni di origine
//      if (new_cls->save_GeomData() == GS_BAD)
//		   { result = GS_BAD; break; }
//
//      result = GS_GOOD;
//   }
//   while (0);
//
//   // rispristino i valori precedenti di UNDO, BLIPMODE, HIGHLIGHT
//   gsc_disableUndoRecording(false);
//   gsc_setVarForCommandNormal(env_variab.get_head());
//   // Rispristino CMDDIA
//   gsc_set_cmddia(OldCMDDIA);
//
//   // inizializzo le variabili d'ambiente ADE per GEOsim
//   AdeEnv.SetEnv4GEOsim();
//
//   if (GS_CURRENT_WRK_SESSION)
//   {  // rilascio tutti i DWG della classe destinazione 
//      // altrimenti non si potrebbe
//      // ristorare il backup dei DWG che risulterebbero in uso
//      new_cls->GphDetach();
//      // uscita dalla sessione di lavoro
//      if (gsc_ExitCurrSession() == GS_BAD) return GS_BAD;
//   }
//
//   return result;
//}


/*********************************************************/
/*.doc C_CLASS::is_inarea <internal> */
/*+
  Questa funzione restituisce in result se la classe è presente
  in una sessione di lavoro.
  Parametri:
  long *SessionCode; Codice sessione di lavoro o 0 se non esiste
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/  
/*********************************************************/
int C_CLASS::is_inarea(long *SessionCode)
{
   return gsc_is_inarea(id.pPrj->get_key(), id.code, SessionCode);
}


/*********************************************************/
/*.doc C_CLASS::is_extracted
/*+
  Questa funzione restituisce GS_GOOD se la classe è stata
  estratta nella sessione di lavoro corrente.
-*/  
/*********************************************************/
int C_CLASS::is_extracted(void)
{
   return (ptr_id()->sel == EXTRACTED || ptr_id()->sel == EXTR_SEL) ? GS_GOOD : GS_BAD;
}

int C_CLASS::copy(C_CLASS* out)        { GS_ERR_COD = eGSInvClassType; return GS_BAD; }

int C_CLASS::is_validfas(int type, C_DBCONNECTION *pConn, C_ATTRIB_LIST *p_attrib_list)
   { GS_ERR_COD = eGSInvClassType; return GS_BAD; }


/*********************************************************************/
/*.doc C_CLASS::what_is_graph_updateable                  <external> */
/*+
  Questa funzione, restituisce un flag contenente la codifica 
  delle caratteristiche grafiche modificabili secondo GraphSettingsEnum.
-*/  
/*********************************************************************/
long C_CLASS::what_is_graph_updateable(void)
{
   // se già inizializzato
   if (m_BitForUpdateableFAS != GSNoneSetting) return m_BitForUpdateableFAS;

   long GraphMod, flag_set;

   // Questa funzione esamina il corpo della funzione di calcolo grafico 
   // restituendo quali caratteristiche grafiche sono modificate
   // dalle funzioni di calcolo grafico
   if ((GraphMod = gsc_WhatIsGraphModified(this)) == -1) return GSNoneSetting;

   // restituisce le caratteristiche evidenziabili
   if ((flag_set = gsc_WhatFas4Evid(this)) == -1) return GSNoneSetting;

   // Elimino le caratteristiche modificate dalle funzioni di calcolo grafico
   GraphMod = ~GraphMod; // ne faccio il not
   m_BitForUpdateableFAS = flag_set & GraphMod; // lo metto in and

   return m_BitForUpdateableFAS;
}

int C_CLASS::ToFile_info(C_STRING &filename)
{
   TCHAR sez[SEZ_PROFILE_LEN]; 

   if (!ptr_info()) { GS_ERR_COD = eGSInvClassType; return GS_BAD; }
   swprintf(sez, SEZ_PROFILE_LEN, _T("%d.%d"), id.code, id.sub_code);
   return ptr_info()->ToFile(filename, sez);
}
int C_CLASS::ToFile_info(C_PROFILE_SECTION_BTREE &ProfileSections)
{
   TCHAR sez[SEZ_PROFILE_LEN]; 

   if (!ptr_info()) { GS_ERR_COD = eGSInvClassType; return GS_BAD; }
   swprintf(sez, SEZ_PROFILE_LEN, _T("%d.%d"), id.code, id.sub_code);
   return ptr_info()->ToFile(ProfileSections, sez);
}

//-----------------------------------------------------------------------//
int C_CLASS::ToFile_gphInfo(C_STRING &filename)
{
   TCHAR sez[SEZ_PROFILE_LEN]; 

   if (!ptr_GphInfo()) { GS_ERR_COD = eGSInvClassType; return GS_BAD; }
   swprintf(sez, SEZ_PROFILE_LEN, _T("%d.%d"), id.code, id.sub_code);
   return ptr_GphInfo()->ToFile(filename, sez);
}
int C_CLASS::ToFile_gphInfo(C_PROFILE_SECTION_BTREE &ProfileSections)
{
   TCHAR sez[SEZ_PROFILE_LEN]; 

   if (!ptr_GphInfo()) { GS_ERR_COD = eGSInvClassType; return GS_BAD; }
   swprintf(sez, SEZ_PROFILE_LEN, _T("%d.%d"), id.code, id.sub_code);
   return ptr_GphInfo()->ToFile(ProfileSections, sez);
}

int C_CLASS::load_info(TCHAR *filename) { GS_ERR_COD = eGSInvClassType; return GS_BAD; }
int C_CLASS::ToFile_grid(C_STRING &filename)
{
   TCHAR sez[SEZ_PROFILE_LEN]; 

   if (!ptr_grid()) { GS_ERR_COD = eGSInvClassType; return GS_BAD; }
   swprintf(sez, SEZ_PROFILE_LEN, _T("%d.%d"), id.code, id.sub_code);
   return ptr_grid()->ToFile(filename, sez);
}
int C_CLASS::ToFile_grid(C_PROFILE_SECTION_BTREE &ProfileSections)
{
   TCHAR sez[SEZ_PROFILE_LEN]; 

   if (!ptr_grid()) { GS_ERR_COD = eGSInvClassType; return GS_BAD; }
   swprintf(sez, SEZ_PROFILE_LEN, _T("%d.%d"), id.code, id.sub_code);
   return ptr_grid()->ToFile(ProfileSections, sez);
}

int C_CLASS::load_grid(TCHAR *filename) { GS_ERR_COD = eGSInvClassType; return GS_BAD; }
int C_CLASS::ToFile_connect_list(C_STRING &filename)
{
   TCHAR sez[SEZ_PROFILE_LEN]; 

   if (!ptr_connect_list()) { GS_ERR_COD = eGSInvClassType; return GS_BAD; }
   swprintf(sez, SEZ_PROFILE_LEN, _T("%d.%d"), id.code, id.sub_code);
   return ptr_connect_list()->ToFile(filename, sez);
}
int C_CLASS::ToFile_connect_list(C_PROFILE_SECTION_BTREE &ProfileSections)
{
   TCHAR sez[SEZ_PROFILE_LEN]; 

   if (!ptr_connect_list()) { GS_ERR_COD = eGSInvClassType; return GS_BAD; }
   swprintf(sez, SEZ_PROFILE_LEN, _T("%d.%d"), id.code, id.sub_code);
   return ptr_connect_list()->ToFile(ProfileSections, sez);
}

int C_CLASS::load_connect_list(TCHAR *filename)
   { GS_ERR_COD=eGSInvClassType; return GS_BAD; }
int C_CLASS::ToFile_group_list(C_STRING &filename)
{
   TCHAR sez[SEZ_PROFILE_LEN]; 

   if (!ptr_group_list()) { GS_ERR_COD = eGSInvClassType; return GS_BAD; }
   swprintf(sez, SEZ_PROFILE_LEN, _T("%d.0"), id.code);
   return ptr_group_list()->ToFile(filename, sez);
}
int C_CLASS::ToFile_group_list(C_PROFILE_SECTION_BTREE &ProfileSections)
{
   TCHAR sez[SEZ_PROFILE_LEN]; 

   if (!ptr_group_list()) { GS_ERR_COD = eGSInvClassType; return GS_BAD; }
   swprintf(sez, SEZ_PROFILE_LEN, _T("%d.0"), id.code);
   return ptr_group_list()->ToFile(ProfileSections, sez);
}

int C_CLASS::load_group_list(TCHAR *filename)
   { GS_ERR_COD = eGSInvClassType; return GS_BAD; }
int C_CLASS::ToFile(C_STRING &filename) { GS_ERR_COD = eGSInvClassType; return GS_BAD; }
int C_CLASS::ToFile(C_PROFILE_SECTION_BTREE &ProfileSections) { GS_ERR_COD = eGSInvClassType; return GS_BAD; }

int C_CLASS::load(TCHAR *filename, int cl)
   { GS_ERR_COD = eGSInvClassType; return GS_BAD; }
int C_CLASS::load(C_PROFILE_SECTION_BTREE &ProfileSections, int cl)
   { GS_ERR_COD = eGSInvClassType; return GS_BAD; }

int C_CLASS::load(TCHAR *filename, int cl, int sub)
   { GS_ERR_COD = eGSInvClassType; return GS_BAD; }
int C_CLASS::load(C_PROFILE_SECTION_BTREE &ProfileSections, int cl, int sub)
   { GS_ERR_COD = eGSInvClassType; return GS_BAD; }

int C_CLASS::is_subclass() { return GS_BAD; }
// Interfaccia con strutture LISP (liste di resbuf)
resbuf *C_CLASS::to_rb(void)     { GS_ERR_COD = eGSInvClassType; return NULL; }
int C_CLASS::from_rb(resbuf *rb) { GS_ERR_COD = eGSInvClassType; return GS_BAD; }
// Interfaccia con il database
int C_CLASS::create (void)  { GS_ERR_COD = eGSInvClassType; return GS_BAD; }
int C_CLASS::del    (const TCHAR *Password)
   { GS_ERR_COD=eGSInvClassType; return GS_BAD; }
int C_CLASS::from_db(C_RB_LIST &ColValues, GSDataPermissionTypeEnum cod_level)
   { GS_ERR_COD = eGSInvClassType; return GS_BAD; }
// reindicizzazione
int C_CLASS::reindexTab(bool OnlyTemp)
  { GS_ERR_COD = eGSInvClassType; return GS_BAD; }
// stampa struttura in formato HTML
int C_CLASS::reportHTML(FILE *file, const TCHAR *Path, bool SynthMode)
  { GS_ERR_COD = eGSInvClassType; return GS_BAD; }
// sincronizzazione
int C_CLASS::synchronize(const TCHAR *DeletedObjsDWG, TCHAR *NextCmd) { return GS_GOOD; }


/****************************************************************************/
/*.doc C_CLASS::DWGOptimization                                  <external> */
/*+
  Questa funzione ottimizza i disegni della classe in modo tale che essi
  contengano oggetti della stessa zona.
  E' stimato che per ogni Mbyte di disegno ci siano :
  8000 oggetti per classi senza collegamento a DB
  9000 oggetti per classi testo
  8000 oggetti per classi con collegamento a DB senza blocchi DA
  4000 oggetti per classi con collegamento a DB con blocchi DA
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/
/******************************************************************************/
int C_CLASS::DWGOptimization(void)
{
   C_WRK_SESSION WrkSession(get_pPrj());
   C_SELSET   SSClass;
   C_RB_LIST  env_variab;
   C_STRING   session_dir, drive, dir, name, DirDwg, PrefixDWGName, ODTableName;
   C_INT      *pcls_2_extract;
   C_INT_LIST cls_list_2_extract;
   resbuf     rb;
   presbuf    pNameList = NULL, pAttrList = NULL;
   int        result = GS_BAD, nMbPerDwg, Prj = get_PrjId();
   long       nObjsPer1MbDwg;
   ads_point  pMax, pMin;
   C_DWG_LIST DwgList;
   C_GPH_INFO *pGraphInfo = ptr_GphInfo();

   // verifico abilitazione
   if (gsc_check_op(opDWGOptimization) == GS_BAD) return GS_BAD;

   if (id.category == CAT_EXTERN)
      pGraphInfo = ((C_SUB *) ptr_sub_list()->get_head())->ptr_GphInfo();
   else
   {
      if (!pGraphInfo) { GS_ERR_COD = eGSInvClassType; return GS_BAD; }

      if (id.category == CAT_SPAGHETTI)
         // ricavo il nome della tabella interna
         gsc_getODTableName(Prj, id.code, id.sub_code, ODTableName);
   }

   // Se i dati geometrici sono in tabelle DB
   if (pGraphInfo->getDataSourceType() == GSDBGphDataSource) return GS_GOOD;

   DirDwg = ((C_DWG_INFO *) pGraphInfo)->dir_dwg;

   // Carico la lista dei DWG
   if (DwgList.load(Prj, id.code) != GS_GOOD) return GS_BAD;

   if (gsc_getClsPrefixDWGName(Prj, id.code, PrefixDWGName) == GS_BAD)
      return GS_BAD;

   // cancello tutti i DWG temporanei (di ottimizzazione) della classe
   session_dir = GEOsimAppl::CURRUSRDIR;
   session_dir += _T('\\');
   session_dir += GEOTEMPDIR;
   session_dir += _T('\\');
   session_dir += PrefixDWGName;
   session_dir += _T("*.DWG");   
   pNameList = NULL; pAttrList = NULL;
   if (gsc_adir(session_dir.get_name(), &pNameList, NULL, NULL, &pAttrList) > 0)
   {
      presbuf pName, pAttr;

      pName = pNameList;
      pAttr = pAttrList;
      while (pName) 
      {
         // NON è un direttorio          
         if (pName->restype == RTSTR && *(pAttr->resval.rstring + 4) != _T('D'))
         {
            session_dir = GEOsimAppl::CURRUSRDIR;
            session_dir += _T('\\');
            session_dir += GEOTEMPDIR;
            session_dir += _T('\\');
            session_dir += pName->resval.rstring;
            if (gsc_delfile(session_dir) == GS_BAD) return GS_BAD;
         }
         pName = pName->rbnext;
         pAttr = pAttr->rbnext;
      }
   }
   if (pNameList) acutRelRb(pNameList);
   if (pAttrList) acutRelRb(pAttrList);

   // Eseguo backup dei disegni
   if (Backup(GSCreateBackUp, GRAPHICAL) == GS_BAD) return GS_BAD;
   
   // setto i valori di UNDO, BLIPMODE, HIGHLIGHT per avere massima velocità di ACAD
   if ((env_variab << gsc_setVarForCommandSpeed()) == NULL) return GS_BAD;
   gsc_disableUndoRecording(true);

   do
   {
      session_dir = _T("GEOSIM_DWGOPTIMIZATION_CLS");
      session_dir += id.code;
      if (WrkSession.set_name(session_dir.get_name()) == GS_BAD) break;

      session_dir = get_pPrj()->get_dir();
      session_dir += _T("\\GSDWGOPTIMIZATION_CLS");
      session_dir += id.code;
      if (WrkSession.set_dir(session_dir.get_name()) == GS_BAD) break;
      WrkSession.set_level(GSUpdateableData);
   
      // Alloca un oggetto C_INT
      if ((pcls_2_extract = new C_INT(id.code)) == NULL)
         { GS_ERR_COD = eGSOutOfMem; break; }
      cls_list_2_extract.add_tail(pcls_2_extract);

      // seleziono classe da estrarre, ed eseguo estrazione
      // effettuo estrazione rendendo la classe in sola lettura alle altre sessioni
      if (gsc_extract_classes((C_PROJECT *) id.pPrj,  // progetto
                              WrkSession,             // sessione di lavoro
                              cls_list_2_extract,     // lista classi
                              TRUE,                   // estrazione in esclusiva
                              NULL,                   // condizione spaziale
                              NULL,                   // condizione di proprietà
                              FALSE,                  // forma NOT oppure no
                              EXTRACTION,             // modo di estrazione
                              &SSClass) == GS_BAD)    // gruppo di selezione estratto
         break;

      // rilascio tutti i DWG altrimenti non si potrebbe ottimizzare
      // (la procedura genera nuovi DWG attaccati)
      gsc_AllDwgDetach();

      // se la classe è stata in modifica
      // (perchè bloccata da un'altra sessione di lavoro)
      if (id.abilit != GSUpdateableData) { GS_ERR_COD = eGSClassLocked; break; }

      if (gsc_callCmd(_T("_.ZOOM"), RTSTR, _T("_E"), 0) != RTNORM) break;

      acedGetVar(_T("EXTMAX"), &rb);
      ads_point_set(rb.resval.rpoint, pMax);

      acedGetVar(_T("EXTMIN"), &rb);
      ads_point_set(rb.resval.rpoint, pMin);

      // Ricavo quanti oggetti ci sono per Mb dividendo il numero di oggetti 
      // in grafica per la somma delle dimensioni dei DWG in Mbyte
      nObjsPer1MbDwg = (long) (SSClass.length() / (DwgList.get_size() / (1024.0 * 1024.0)));

      // La dimensione ottimale di un DWG è DEFAULT_DWG_DIM Mb
      nMbPerDwg = (get_pPrj()->get_dwg_dim() == 0) ? DEFAULT_DWG_DIM : get_pPrj()->get_dwg_dim();

      acutPrintf(GS_LFSTR);
      if (gsc_optimizeDWG(PrefixDWGName.get_name(), ODTableName,
                          pMin, pMax, SSClass, nObjsPer1MbDwg * nMbPerDwg) == GS_BAD)
         break;

      result = GS_GOOD;
   }
   while (0);

   // rispristino i valori precedenti di UNDO, BLIPMODE, HIGHLIGHT
   gsc_disableUndoRecording(false);
   gsc_setVarForCommandNormal(env_variab.get_head());

   // uscita dalla sessione di lavoro
   if (GS_CURRENT_WRK_SESSION)
   {       
      gsc_AllDwgDetach();

      // Se è andato tutto bene sostituisco i disegni della classe con quelli
      // creati dalla fuzione "gsc_optimizeDWG" 
      if (result == GS_GOOD)
      {
         C_DWG_LIST DwgList;

         if (DwgList.load(Prj, id.code) == GS_GOOD)
         {
            C_DWG *pDwg;

            // cancello tutti i DWG della classe
            pDwg = (C_DWG *) DwgList.get_head();
            while (pDwg)
            {
               if (gsc_delfile(pDwg->get_name()) == GS_BAD)
                  { result = GS_BAD; break; }

               // Cancello anche i .INF
               gsc_splitpath(pDwg->get_name(), &drive, &dir, &name, NULL);
               session_dir = drive;
               session_dir += dir;
               session_dir += name;
               session_dir += _T(".INF");

               if (gsc_path_exist(session_dir) == GS_GOOD)
                  if (gsc_delfile(session_dir) == GS_BAD)
                     { result = GS_BAD; break; }

               pDwg = (C_DWG *) DwgList.get_next();
            }
            
            // sposto tutti i DWG temporanei ottimizzati nominandoli in modo opportuno
            session_dir = GEOsimAppl::CURRUSRDIR;
            session_dir += _T('\\');
            session_dir += GEOTEMPDIR;
            session_dir += _T('\\');
            session_dir += PrefixDWGName;
            session_dir += _T("*.DWG");
            pNameList = NULL; pAttrList = NULL;
            if (gsc_adir(session_dir.get_name(), &pNameList, NULL, NULL, &pAttrList) > 0)
            {
               presbuf pName, pAttr;

               pName = pNameList;
               pAttr = pAttrList;
               while (pName) 
               {
                  // NON è un direttorio          
                  if (pName->restype == RTSTR && *(pAttr->resval.rstring + 4) != _T('D'))
                  {
                     C_STRING Dest;

                     Dest = DirDwg;
                     Dest += _T('\\');
                     Dest += pName->resval.rstring;

                     session_dir = GEOsimAppl::CURRUSRDIR;
                     session_dir += _T('\\');
                     session_dir += GEOTEMPDIR;
                     session_dir += _T('\\');
                     session_dir += pName->resval.rstring;

                     if (gsc_copyfile(session_dir, Dest) == GS_BAD)
                        { result = GS_BAD; break; }
                     if (gsc_delfile(session_dir) == GS_BAD)
                        { result = GS_BAD; break; }
                  }
                  pName = pName->rbnext;
                  pAttr = pAttr->rbnext;
               }
            }

            if (pNameList) acutRelRb(pNameList);
            if (pAttrList) acutRelRb(pAttrList);

            // Reindicizzo e costruisco i file di estensioni
            C_DWG_LIST DwgList;
            
            // inizializzo la lista dei dwg della classe corrente
            if (DwgList.load(Prj, id.code) == GS_GOOD)
            {
               DwgList.activate();
               DwgList.index(Prj, id.code);
               DwgList.regen_extents_from_dwg(GS_BAD);
               DwgList.detach();
            }
         }
      }

      // rilascio tutti i DWG altrimenti non si potrebbe
      // ristorare il backup dei DWG che risulterebbero in uso
      gsc_AllDwgDetach();

      if (result == GS_BAD)
      {
         // Ripristina backup dei disegni
         if (Backup(GSRestoreBackUp, NULL, GRAPHICAL) == GS_BAD)
            // "\nL'operazione è fallita. Ripristinare manualmente
            // \ni files di backup della classe (vedi manuale)."
            acutPrintf(gsc_msg(636));
      }
      else
         // Cancella backup dei disegni
         Backup(GSRemoveBackUp, GRAPHICAL);

		// uscita dalla sessione di lavoro
      gsc_ExitCurrSession();
   }

   // memorizzo il codice del progetto in GEOSIM.INI
   gsc_setLastUsedPrj(Prj);

   return result;
}


/*********************************************************/
/*.doc C_CLASS::getLPNameOld                  <internal> */
/*+
  Questa funzione ottiene il nome del LPN per la tabella OLD.
  Parametri:
  C_STRING &LPName;     Nome LPN
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_CLASS::getLPNameOld(C_STRING &LPName)
{
   // Non considero la FAS perchè anche il gruppi necessitano di collegamento
   // al database
   if (!ptr_info() || !ptr_attrib_list())
      { GS_ERR_COD = eGSInvClassType; return GS_BAD; }

   LPName = _T("PRJ");
   LPName += id.pPrj->get_key();
   LPName += _T("CLS");
   LPName += id.code;
   if (id.sub_code > 0)
   {
      LPName += _T("SUB");
      LPName += id.sub_code;
   }
   LPName += _T("OLD_LINK");

   return GS_GOOD;
}


/*********************************************************/
/*.doc C_CLASS::getLPNameTemp                 <internal> */
/*+
  Questa funzione ottiene il nome del LPN per la tabella TEMP.
  Parametri:
  C_STRING &LPName;     Nome LPN
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_CLASS::getLPNameTemp(C_STRING &LPName)
{
   if (!ptr_info() || !ptr_attrib_list())
      { GS_ERR_COD = eGSInvClassType; return GS_BAD; }

   LPName = _T("PRJ");
   LPName += id.pPrj->get_key();
   LPName += _T("CLS");
   LPName += id.code;
   if (id.sub_code > 0)
   {
      LPName += _T("SUB");
      LPName += id.sub_code;
   }
   LPName += _T("TEMP_LINK");

   return GS_GOOD;
}


/*********************************************************/
/*.doc C_CLASS::getTempTableRef               <internal> */
/*+
  Questa funzione ottiene il riferimento completo della tabella
  temporanea della classe. Se non esiste la tabella viene creata.
  Parametri:
  C_STRING &_TempTableRef;
  int      Create;        Se = GS_GOOD crea la tabella TEMP (default = GS_GOOD)
                          N.B. usare questo parametro = GS_BAD solo uscendo da una sessione di lavoro!
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_CLASS::getTempTableRef(C_STRING &_TempTableRef, int Create)
{
   C_INFO *pInfo = ptr_info();

   if (!pInfo) { GS_ERR_COD = eGSInvClassType; return GS_BAD; }

   if (!(pInfo->TempTableRef.get_name()))
   {
      C_DBCONNECTION *pTempConn;
      C_STRING       Table, pathfile;

      if (!GS_CURRENT_WRK_SESSION) { GS_ERR_COD = eGSNotCurrentSession; return GS_BAD; }

      Table = _T("CLS");
      Table += id.code;
      if (is_subclass() == GS_GOOD)
      {
         Table += _T("SUB");
         Table += id.sub_code;
      }

      pathfile = GS_CURRENT_WRK_SESSION->get_dir();
      pathfile += _T('\\');
      pathfile += GEOTEMPSESSIONDIR;
      pathfile += _T('\\');
      pathfile += GEOWRKSESSIONDB;

      // ricavo connessione OLE-DB per tabella TEMP
      if ((pTempConn = pInfo->getDBConnection(TEMP)) == NULL) return GS_BAD;

      _TempTableRef.paste(pTempConn->get_FullRefTable(pathfile.get_name(), NULL,
                                                      Table.get_name()));
      if (_TempTableRef.get_name() == NULL) return GS_BAD;

      // Se non esiste la tabella viene creata
      if (Create == GS_GOOD)
      {
         if (pTempConn->ExistTable(_TempTableRef) == GS_BAD)
         {
            C_DBCONNECTION *pOldConn;

            // ricavo connessione OLE-DB per tabella OLD
            if ((pOldConn = pInfo->getDBConnection(OLD)) == NULL)
               { pInfo->TempTableRef.clear(); return GS_BAD; }
         
            // solo ora inizializzo OldTableRef
            pInfo->TempTableRef = _TempTableRef;
            if (pOldConn->CopyTable(pInfo->OldTableRef.get_name(), *pTempConn, 
                                    pInfo->TempTableRef.get_name(), GSStructureOnlyCopyType) == GS_BAD)
               { pInfo->TempTableRef.clear(); return GS_BAD; }
         }
         else
            pInfo->TempTableRef = _TempTableRef;
      }
   }
   else 
   {
      _TempTableRef = pInfo->TempTableRef;

      // Se non esiste la tabella viene creata
      if (Create == GS_GOOD)
      {
         C_DBCONNECTION *pTempConn;

         // ricavo connessione OLE-DB per tabella TEMP
         if ((pTempConn = pInfo->getDBConnection(TEMP)) == NULL) return GS_BAD;

         if (pTempConn->ExistTable(pInfo->TempTableRef) == GS_BAD)
         {
            C_DBCONNECTION *pOldConn;

            // ricavo connessione OLE-DB per tabella OLD
            if ((pOldConn = pInfo->getDBConnection(OLD)) == NULL) return GS_BAD;
         
            // solo ora inizializzo OldTableRef
            if (pOldConn->CopyTable(pInfo->OldTableRef.get_name(), *pTempConn, 
                                    pInfo->TempTableRef.get_name(), GSStructureOnlyCopyType) == GS_BAD)
               return GS_BAD;
         }
      }
   }

   return GS_GOOD;
}


/*********************************************************/
/*.doc C_CLASS::getOldLnkTableRef             <internal> */
/*+
  Questa funzione ottiene il riferimento completo della tabella
  dei link della classe.
  Parametri:
  C_STRING &LinkTableRef;
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_CLASS::getOldLnkTableRef(C_STRING &LinkTableRef)
{
   C_INFO *pInfo = ptr_info();

   if (!pInfo) { GS_ERR_COD = eGSInvClassType; return GS_BAD; }

   if (!(pInfo->OldLnkTableRef.get_name()))
   {
      C_DBCONNECTION *pConn;
      C_STRING       Catalog, Schema, Table;

      // ricavo connessione OLE-DB per tabella
      if ((pConn = pInfo->getDBConnection(OLD)) == NULL) return GS_BAD;

      if (pConn->split_FullRefTable(pInfo->OldTableRef, Catalog, Schema, Table) == GS_BAD)
         return GS_BAD;
      Table += _T("L");  // "L" per Link

      pInfo->OldLnkTableRef.paste(pConn->get_FullRefTable(Catalog, Schema, Table));
      if (!(pInfo->OldLnkTableRef.get_name())) return GS_BAD;
   }
   LinkTableRef = pInfo->OldLnkTableRef;

   return GS_GOOD;
}


/*********************************************************/
/*.doc C_CLASS::getTempLnkTableRef            <internal> */
/*+
  Questa funzione ottiene il riferimento completo della tabella
  temporanea dei link della classe.
  Parametri:
  C_STRING &TempTableRef;
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_CLASS::getTempLnkTableRef(C_STRING &LinkTempTableRef)
{
   C_INFO *pInfo = ptr_info();

   // deve essere un gruppo
   if (!pInfo && !ptr_group_list())
      { GS_ERR_COD = eGSInvClassType; return GS_BAD; }

   if (!(pInfo->TempLnkTableRef.get_name()))
   {
      C_DBCONNECTION *pTempConn;
      C_STRING       Table, pathfile;

      if (!GS_CURRENT_WRK_SESSION) { GS_ERR_COD = eGSNotCurrentSession; return GS_BAD; }

      Table = _T("CLS");
      Table += id.code;
      if (is_subclass() == GS_GOOD)
      {
         Table += _T("SUB");
         Table += id.sub_code;
      }
      Table += _T("L");  // "L" per Link

      pathfile = GS_CURRENT_WRK_SESSION->get_dir();
      pathfile += _T('\\');
      pathfile += GEOTEMPSESSIONDIR;
      pathfile += _T('\\');
      pathfile += GEOWRKSESSIONDB;

      // ricavo connessione OLE-DB per tabella TEMP
      if ((pTempConn = pInfo->getDBConnection(TEMP)) == NULL) return GS_BAD;

      pInfo->TempLnkTableRef.paste(pTempConn->get_FullRefTable(pathfile.get_name(), NULL,
                                                               Table.get_name()));
      if (!(pInfo->TempLnkTableRef.get_name())) return GS_BAD;

      // Se non esiste la tabella viene creata
      if (pTempConn->ExistTable(pInfo->TempLnkTableRef) == GS_BAD)
      {
         C_DBCONNECTION *pOldConn;
         C_STRING       ProviderDescrUInt, OldLnkTableRef;
         long           lenUInt;
         int            decUInt;
         presbuf        p;
         C_RB_LIST      Stru;

         // ricavo connessione OLE-DB per tabella OLD
         if ((pOldConn = pInfo->getDBConnection(OLD)) == NULL)
            { pInfo->TempLnkTableRef.clear(); return GS_BAD; }
         if (getOldLnkTableRef(OldLnkTableRef) == GS_BAD)
            { pInfo->TempLnkTableRef.clear(); return GS_BAD; }

         int IsTransactionSupported = pTempConn->BeginTrans();

         // non copio gli indici perchè cambio la struttura (gli indici vengono creati alla fine)
         if (pOldConn->CopyTable(OldLnkTableRef.get_name(), *pTempConn, 
                                 pInfo->TempLnkTableRef.get_name(), 
                                 GSStructureOnlyCopyType, GS_BAD) == GS_BAD)
            { pInfo->TempLnkTableRef.clear(); return GS_BAD; }

         // Conversione tipologia per campo STATUS
         if (pTempConn->Type2ProviderType(adUnsignedTinyInt,       // DataType per campo STATUS
                                          FALSE,                   // IsLong
                                          FALSE,                   // IsFixedPrecScale
                                          RTT,                     // IsFixedLength
                                          TRUE,                    // IsWrite
                                          3,                       // Size
                                          0,                       // Prec
                                          ProviderDescrUInt,       // ProviderDescr
                                          &lenUInt, &decUInt) == GS_BAD)
         {
            pInfo->TempLnkTableRef.clear(); 
            if (IsTransactionSupported == GS_GOOD) pTempConn->RollbackTrans();
            return GS_BAD;
         }

         if ((p = pTempConn->ReadStruct(pInfo->TempLnkTableRef.get_name())) == NULL)
         {
            pInfo->TempLnkTableRef.clear();
            if (IsTransactionSupported == GS_GOOD) pTempConn->RollbackTrans();
            return GS_BAD;
         }
         // trasformo i tipi da codici ADO in descrizioni
         if ((Stru << pTempConn->getStruForCreatingTable(p)) == NULL)
         {
            pInfo->TempLnkTableRef.clear(); 
            if (IsTransactionSupported == GS_GOOD) pTempConn->RollbackTrans();
            return GS_BAD; 
         }

         Stru.remove_tail(); // elimino ultima tonda chiusa
         if ((Stru += acutBuildList(RTLB,
                                       RTSTR, _T("STATUS"),
                                       RTSTR, ProviderDescrUInt.get_name(),   // <tipo>
                                       RTSHORT, lenUInt,                      // <len>
                                       RTSHORT, decUInt,                      // <dec>
                                    RTLE, RTLE, 0)) == NULL)
         { 
            pInfo->TempLnkTableRef.clear(); 
            if (IsTransactionSupported == GS_GOOD) pTempConn->RollbackTrans();
            return GS_BAD; 
         }

         // Aggiungo alla struttura lo "STATUS" (UNMODIFIED, MODIFIED, ERASED, INSERTED ...)
         if (pTempConn->UpdStruct(pInfo->TempLnkTableRef.get_name(), Stru.get_head(),
                                  NULL) == GS_BAD)
         { 
            pInfo->TempLnkTableRef.clear();
            if (IsTransactionSupported == GS_GOOD) pTempConn->RollbackTrans();
            return GS_BAD; 
         }

         if (IsTransactionSupported == GS_GOOD) pTempConn->CommitTrans();

         reindexTab(true); // faccio gli indici solo delle tabelle temporanee
      }
   }
   LinkTempTableRef = pInfo->TempLnkTableRef;

   return GS_GOOD;
}


/*********************************************************/
/*.doc C_CLASS::restore_connectlist           <internal> */
/*+
  Questa funzione carica la lista dei collegamenti della classe dai database.
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/  
/*********************************************************/
int C_CLASS::restore_connectlist(void)
{                                                   
   int            cod_class, tipo_coll;
   presbuf        pID, pType;
   C_RB_LIST      ColValues;
   C_INT_INT      *pconnect;
   C_INT_INT_LIST *pconnect_list;
   C_DBCONNECTION *pConn;
   C_STRING       statement, TableRef;
   _RecordsetPtr  pRs;

   // setto il riferimento di GS_CONCT (<catalogo>.<schema>.<tabella>)
   if (get_pPrj()->getConnectionsTabInfo(&pConn, &TableRef) == GS_BAD) return GS_BAD;

   if ((pconnect_list = ptr_connect_list()) == NULL)
      { GS_ERR_COD = eGSInvClassType; return GS_BAD; }
   pconnect_list->remove_all();

   if (is_subclass() == GS_BAD)
   {
      statement = _T("SELECT LNK_CL_ID,TYPE FROM ");
   }
   else
      statement = _T("SELECT LNK_SUB_ID,TYPE FROM ");
  
   statement += TableRef;
   statement += _T(" WHERE CLASS_ID=");
   statement += id.code;
   statement += _T(" AND SUB_CL_ID=");
   statement += id.sub_code;

   // in PostgreSQL la select mi restituiva i record in ordine casuale (e non rispettando l'ordine di inserimento)
   // questo creava problemi in quanto la sottoclasse usata per inserire un entità a fine/inizio di un link
   // non era più il nodo (sottoclasse 1) ma ad esempio il regolatore (sottoclasse 3)
   if (is_subclass() == GS_BAD)
      statement += _T(" ORDER BY LNK_CL_ID");
   else
      statement += _T(" ORDER BY LNK_SUB_ID");

   // leggo le righe della tabella senza bloccarla
   if (pConn->ExeCmd(statement, pRs) == GS_BAD) return GS_BAD;

   if (gsc_InitDBReadRow(pRs, ColValues) == GS_BAD)
      { gsc_DBCloseRs(pRs); return GS_BAD; }

   pID   = ColValues.getptr_at(4);
   pType = ColValues.CdrAssoc(_T("TYPE"));

   // scorro l'elenco dei collegamenti
   while (gsc_isEOF(pRs) == GS_BAD)
   {
      if (gsc_DBReadRow(pRs, ColValues) == GS_BAD) { gsc_DBCloseRs(pRs); return GS_BAD; }

      // codice della classe (o sottoclasse) collegata 
      if (gsc_rb2Int(pID, &cod_class) == GS_BAD) { gsc_DBCloseRs(pRs); return GS_BAD; }
         
      // tipo del collegamento 
      if (gsc_rb2Int(pType, &tipo_coll) == GS_BAD) { gsc_DBCloseRs(pRs); return GS_BAD; }
      
      if ((pconnect = new C_INT_INT) == NULL)
          { gsc_DBCloseRs(pRs); GS_ERR_COD = eGSOutOfMem; return GS_BAD; }
      
      pconnect->set_key(cod_class);
      pconnect->set_type(tipo_coll);
      pconnect_list->add_tail((C_NODE *) pconnect);  // inserimento in lista

      gsc_Skip(pRs);
   }
    
   return gsc_DBCloseRs(pRs);
}


/*********************************************************/
/*.doc C_CLASS::del_db_conc <internal> */
/*+
  Questa funzione cancella la lista dei collegamenti della classe nei database.
  La cancellazione viene effettuata selezionando le connessioni della classe
  in oggetto ed in più, opzionalmente, le connessioni delle altre classi 
  che si connettono con la classe in oggetto (se mode = ALL).
  Parametri:
  int  mode;         flag di modo, se = ALL cancella le connessioni della classe
                     e delle altre classi che si connettono con la classe 
                     (default = ALL + 1)
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
  N.B.: Non vale per le sottoclassi !!! 
-*/  
/*********************************************************/
int C_CLASS::del_db_conc(int mode)
{
   if (id.category != CAT_EXTERN)
      if (ptr_connect_list() == NULL)
         { GS_ERR_COD = eGSInvClassType; return GS_BAD; }

   if (is_subclass() == GS_GOOD) { GS_ERR_COD = eGSInvClassType; return GS_BAD; }

   return gsc_del_db_conc(get_pPrj(), id.code, mode);
}   


/*********************************************************/
/*.doc C_CLASS::del_mem_conc <internal> */
/*+
  Questa funzione cancella per tutte le classi del progetto (caricate in 
  memoria) le connessioni con la classe in oggetto.
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
  N.B.: Non vale per le sottoclassi !!! 
-*/  
/*********************************************************/
int C_CLASS::del_mem_conc(void)
{
   if (is_subclass() == GS_GOOD) { GS_ERR_COD = eGSInvClassType; return GS_BAD; }

   return gsc_del_memconnect(get_pPrj(), id.code);
}

 
/*********************************************************/
/*.doc to_db_connectlist <internal> */
/*+
  Questa funzione scarica la lista dei collegamenti della classe nei database.
  Parametri:
  C_CONNECT_LIST *list_conct; lista connessioni
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
  N.B.: Se il codice della classe = 0 significa che si tratta della stessa
  classe (creazione di una classe e connessione con se stessa).
-*/  
/*********************************************************/
int C_CLASS::to_db_connectlist(C_CONNECT_LIST *list_conct)
{
   C_DBCONNECTION *pConn;
   C_STRING       statement, TableRef;
   C_RB_LIST      ColValues;
   presbuf        pType, pLinkCls, pLinkSub;
   C_INT_INT      *pconnect;
   int            Result = GS_GOOD;

   if (is_subclass() == GS_BAD)
      // cancellazione dei collegamenti della classe nei database (per sicurezza)
      if (del_db_conc() == GS_BAD) return GS_BAD;
   
   // setto il riferimento di GS_CONCT (<catalogo>.<schema>.<tabella>)
   if (get_pPrj()->getConnectionsTabInfo(&pConn, &TableRef) == GS_BAD) return GS_BAD;
      
   if ((ColValues << acutBuildList(RTLB,
                                   RTLB, RTSTR, _T("CLASS_ID"),  RTSHORT, id.code, RTLE,
                                   RTLB, RTSTR, _T("SUB_CL_ID"), RTSHORT, id.sub_code, RTLE,
                                   RTLB, RTSTR, _T("TYPE"),      RTSHORT,  0, RTLE,
                                   RTLB, RTSTR, _T("LNK_CL_ID"), RTSHORT,  0, RTLE,
                                   RTLB, RTSTR, _T("LNK_SUB_ID"), RTSHORT, 0, RTLE,
                                   RTLE, 0)) == NULL)
      return GS_BAD;
   pType    = ColValues.CdrAssoc(_T("TYPE"));
   pLinkCls = ColValues.CdrAssoc(_T("LNK_CL_ID"));
   pLinkSub = ColValues.CdrAssoc(_T("LNK_SUB_ID"));

   int IsTransactionSupported = pConn->BeginTrans();

   // scorro l'elenco dei collegamenti
   pconnect = (C_INT_INT *) list_conct->get_head();
   while (pconnect != NULL)
   {
      if (is_subclass() == GS_BAD)
      {
         if (pconnect->get_key() == 0)
            pconnect->set_key(id.code); // con se stessa

         gsc_RbSubst(pType, pconnect->get_type());    // tipo di connessione
         gsc_RbSubst(pLinkCls, pconnect->get_key());  // con quale classe
         gsc_RbSubst(pLinkSub, 0);
      }
      else
      {
         if (pconnect->get_key() == 0)
            pconnect->set_key(id.sub_code); // con se stessa

         gsc_RbSubst(pType, pconnect->get_type());    // tipo di connessione
         gsc_RbSubst(pLinkCls, id.code);  // con quale classe
         gsc_RbSubst(pLinkSub, pconnect->get_key());
      }

      if (pConn->InsRow(TableRef.get_name(), ColValues) == GS_BAD)
         { Result = GS_BAD; break; }
      
      pconnect = (C_INT_INT *) list_conct->get_next();
   }

   if (Result == GS_GOOD)
      { if (IsTransactionSupported == GS_GOOD) pConn->CommitTrans(); }
   else
      { if (IsTransactionSupported == GS_GOOD) pConn->RollbackTrans(); }
   
   return Result;
}                  


/*********************************************************/
/*.doc C_CLASS::mod_stru                      <external> */
/*+
  Questa funzione modifica la struttura della tabella associata alla classe.
    
  Restituisce GS_GOOD in caso di successo, GS_CAN se l'operazione viene abortita
  altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_CLASS::mod_stru(void)
{
   C_RB_LIST      new_stru, link, new_defvalues_list;
   C_ATTRIB_LIST  attrib_list, *p_attrib_list, OldStruct;
   C_INFO         *p_info;
   int            stru, charact, def, vis, calc, valid, mand, result;
   C_DBCONNECTION *pConn;
   int            Prj = id.pPrj->get_key(), Cls = id.code, Sub = id.sub_code;
   long           SessionId;

   // verifico abilitazione
   if (gsc_check_op(opModClass) == GS_BAD) return GS_BAD;

   if (!(p_info = ptr_info()) || !(p_attrib_list = ptr_attrib_list()))
      { GS_ERR_COD = eGSInvClassType; return GS_BAD; }

   // Se si tratta di una tabella collegata non posso cambiare i valori di default
   if (p_info->LinkedTable) { GS_ERR_COD = eGSClassLocked; return GS_BAD; }

   // vedi gsc_alloc_mod_stru
   if (GS_RESBUF == NULL) { GS_ERR_COD = eGSNotAllocVar; return GS_BAD; }
   
   // ricavo la struttura della nuova tabella
   if ((new_stru << gsc_nthcopy(1, GS_RESBUF)) == NULL)
      { GS_ERR_COD = eGSNotAllocVar; return GS_BAD; }
   if (new_stru.GetCount() <= 0) { GS_ERR_COD = eGSNotAllocVar; return GS_BAD; }
                                                         
   // ricavo la lista di link della nuova tabella
   if ((link << gsc_nthcopy(2, GS_RESBUF)) == NULL)
      { GS_ERR_COD = eGSNotAllocVar; return GS_BAD; }
   if (link.GetCount() <= 0)
      { GS_ERR_COD = eGSNotAllocVar; return GS_BAD; }

   // verifico se la classe fa parte di una sessione di lavoro
   if (is_inarea(&SessionId) == GS_BAD || SessionId > 0)
      { GS_ERR_COD = eGSSessionsFound; return GS_BAD; }
   result = GS_BAD;

   // copia di sicurezza
   p_attrib_list->copy(&OldStruct);

   if (attrib_list.from_rb(new_stru.get_head()) == GS_BAD) return GS_BAD;
   
   // ricavo connessione OLE-DB
   if ((pConn = p_info->getDBConnection(OLD)) == NULL) return GS_BAD;

   if (attrib_list.init_ADOType(pConn) == GS_BAD) return GS_BAD;
   // carico eventuali funzioni di calcolo in GSL.GSL del progetto della classe
   gsc_load_gsl(get_pPrj()->get_dir());
	// verifico attrib list
   if (attrib_list.is_valid(pConn) == GS_BAD)
      { gs_gsl_reload(); return GS_BAD; }
   if (attrib_list.is_valid(id.category, id.type, pConn, p_info->key_attrib,
                            ptr_fas()) == GS_BAD)
		{ gs_gsl_reload(); return GS_BAD; }
	// ricarico GSL.GSL giusto
	gs_gsl_reload();

   // verifico cosa è cambiato 
   if (p_attrib_list->WhatIsChanged(&attrib_list, link.get_head(),
                                    &stru, &charact, &def, &vis,
                                    &calc, &valid, &mand) == GS_BAD)
      return GS_BAD;

   // se è stata cambiata la struttura 
   if (stru == GS_GOOD)
      // verifico se la classe ha delle tabelle secondarie
      // verifico che il campo della classe usato per il collegamento con la
      // tabella secondaria (key_pri) esista ancora
      if (Check_KeyPri_On_Sec(attrib_list) == GS_BAD) return GS_BAD;

   if (vis == GS_GOOD)
   {
      int conf;

      // Non possono esserci sessioni di lavoro attive
      if (GS_CURRENT_WRK_SESSION)
         { GS_ERR_COD = eGSSessionsFound; return GS_BAD; }

      // "La modifica apportata richiede il riallineamento della banca dati che potrebbe impiegare molto tempo. Confermare la modifica."
      if (gsc_ddgetconfirm(gsc_msg(376), &conf) == GS_BAD) return GS_BAD;
      if (conf != GS_GOOD) return GS_CAN;
   }

   // creo backup
   if (Backup(GSCreateBackUp) == GS_BAD) return GS_BAD;

   do
   {
      // è stata modificata la struttura della tabella
      if (stru == GS_GOOD)
      {
         acutPrintf(gsc_msg(637), id.name); // "\nModifica struttura tabella classe %s"
         // modifico struttura tabella classe
         if (modi_tab(&attrib_list, link.get_head()) == GS_BAD) break;
      }
      // è stata modificata almeno una caratteristica degli attributi della tabella
      if (stru == GS_GOOD || charact == GS_GOOD || vis == GS_GOOD ||
          calc == GS_GOOD || valid == GS_GOOD || mand == GS_GOOD)
      {
         acutPrintf(gsc_msg(638), id.name); // "\nModifica caratteristiche degli attributi della classe %s"
         // modifico caratteristiche degli attributi
         if (carattattr_to_db(&attrib_list) == GS_BAD) break;
      }
      // è stato modificato almeno un valore di default degli attributi della tabella
      if (def == GS_GOOD)
      {
         acutPrintf(gsc_msg(639), id.name); // "\nModifica valori di default degli attributi della classe %s"
         // modifico default degli attributi
         if (default_to_db(&attrib_list) == GS_BAD) break;
      }
      // è stata modificata la funzione di calcolo di almeno un attributo della tabella
      // e non c'è l'aggiornamento grafico
      if (vis == GS_BAD && calc == GS_GOOD)
      { 
         acutPrintf(gsc_msg(640), id.name); // "\nCalcolo valori attributi tabella classe %s"
         // ricalcolo attributi tabella
         if (ChangeCalcFuncOnData(&attrib_list) == GS_BAD)
         {
            acutPrintf(gsc_msg(306)); // "\nAlcune schede non soddisfano la funzione di calcolo."
            break;
         }
      }
      // è stata modificata la funzione di validità di almeno un attributo della tabella
      // e non c'è l'aggiornamento grafico
      if (vis == GS_BAD && valid == GS_GOOD)
      { 
         acutPrintf(gsc_msg(641), id.name); // "\nVerifica validità valori attributi tabella classe %s"
         // verifico validità
         if (CheckValidFuncOnData(&attrib_list) == GS_BAD)
         {
            acutPrintf(gsc_msg(305)); // "\nAlcune schede non soddisfano la funzione di validità."
            break;
         }
      }
      // è stata modificata l'obbligatorietà di almeno un attributo della tabella
      if (mand == GS_GOOD)
      { 
         acutPrintf(gsc_msg(642), id.name); // "\nVerifica obbligatorietà valori attributi tabella classe %s"
         // verifico obbligatorietà
         if (CheckMandatoryOnData(&attrib_list) == GS_BAD)
         {
            int AssignDefault = GS_BAD;
            bool VisAttribModified;

            // "Alcune schede non soddisfano la regola di obbligatorietà, assegnare il valore di default ?"
            if (gsc_ddgetconfirm(gsc_msg(307), &AssignDefault) == GS_BAD ||
                AssignDefault == GS_BAD)
               break;
            // Assegno i valori di default agli attributi obblicgatori con valore nullo
            if (CheckMandatoryOnData(&attrib_list, TRUE, &VisAttribModified) == GS_BAD)
               break;
            // Se è stato modificato il valore di qualche attributo visibile
            if (VisAttribModified) vis = GS_GOOD;
         }
      }

      // devo settare la nuova struttura e i valori di default corretti
      if (p_attrib_list->from_rb(new_stru.get_head()) == GS_BAD) break;
      if (attrib_list.get_StaticDefValues(new_defvalues_list) == GS_BAD) break;
      if (p_attrib_list->set_default_values(new_defvalues_list) == GS_BAD) break;

      // è stata modificata la visualizzazione di almeno un attributo della tabella
      if (vis == GS_GOOD)
      {
         int MoveOldVisAttrib = GS_GOOD;

         if (id.type != TYPE_TEXT)
            // "Si desidera riposizionare gli attributi visibili in modo automatico ?"
            if (gsc_ddgetconfirm(gsc_msg(62), &MoveOldVisAttrib) == GS_BAD)
               return GS_BAD;

         // aggiorno la grafica senza aggiornare alle impostazioni FAS di default
         // (effettua i controlli di validità e ricalcolo e obbligatorietà)
         if (UpdGraphData(GS_BAD, NULL, GS_GOOD, MoveOldVisAttrib) == GS_BAD)
            break;
      }

      result = GS_GOOD;
   }
   while (0);

   switch (result)
   {
      case GS_GOOD: // se tutto OK
      {
         // è stata modificata la struttura della tabella
         if (stru == GS_GOOD)
         {  // se è entrato in UpdGraphData il puntatore alla classe non c'è più in fase di uscita da sessione
            C_CLASS *pCls = gsc_find_class(Prj, Cls, Sub);

            if (pCls->ptr_id()->view_enabled == true) // classe che ha delle viste associate
               gsc_pgview(pCls);

            if (pCls->ptr_id()->history_enabled == true) // classe che ha la storicizzazione abilitata
            {
               C_STRING HistoryGeomTableRef, HistoryAlfanumTableRef;
               gsc_CreateHistorySystem4Cls(pCls, HistoryGeomTableRef, HistoryAlfanumTableRef, false);
            }

            // se esiste un file SQL che deve essere eseguito
            C_STRING SQLFile;
            SQLFile = GEOsimAppl::GEODIR; // Directory server di GEOsim
            SQLFile += _T('\\');
            SQLFile += GEOCUSTOMDIR;
            SQLFile += _T("\\PRJ");
            SQLFile += Prj;
            SQLFile += _T("_CLS");
            SQLFile += Cls;
            if (Sub > 0)
            {
               SQLFile += _T("_SUB");
               SQLFile += Sub;
            }
            SQLFile += _T(".SQL");
            if (gsc_path_exist(SQLFile) == GS_GOOD)
               gsc_ExeCmdFromFile(SQLFile);
         }

         if (gsc_dealloc_GS_RESBUF() == GS_BAD) return GS_BAD;
         // cancello backup in subdirectory GS_BACK per DBF del direttorio della classe
         if (vis == GS_GOOD)
         {  // è stata modificata la visualizzazione di almeno un attributo della tabella
            C_CLASS *pCls = gsc_find_class(Prj, Cls, Sub);
            pCls->Backup(GSRemoveBackUp);
         }
         else
            Backup(GSRemoveBackUp);
         break;
      }
      case GS_CAN: // operazione annullata dall'utente
         break;
      case GS_BAD:
      {
         int error_code = GS_ERR_COD;

         // restora il backup da subdirectory GS_BACK per DBF del direttorio della classe
         if (vis == GS_GOOD)
         {  // è stata modificata la visualizzazione di almeno un attributo della tabella
            C_CLASS *pCls = gsc_find_class(Prj, Cls, Sub);
            if (pCls->Backup(GSRestoreBackUp) == GS_BAD)
               // "\nL'operazione è fallita. Ripristinare manualmente
               // \ni files di backup della classe (vedi manuale)."
               acutPrintf(gsc_msg(636));
            else
               pCls->Backup(GSRemoveBackUp); // cancello il backup
   
            OldStruct.copy(pCls->ptr_attrib_list()); // rispristino immagine classe in memoria
         }
         else
         {
            if (Backup(GSRestoreBackUp) == GS_BAD)
               // "\nL'operazione è fallita. Ripristinare manualmente
               // \ni files di backup della classe (vedi manuale)"
               acutPrintf(gsc_msg(636));
            else
               Backup(GSRemoveBackUp); // cancello il backup

            OldStruct.copy(p_attrib_list); // rispristino immagine classe in memoria
         }
         
         GS_ERR_COD = error_code;
         break;
      }
   }

   // memorizzo il codice del progetto in GEOSIM.INI
   gsc_setLastUsedPrj(Prj);
 
   return result;
}


/*********************************************************/
/*.doc C_CLASS::WriteDBConnToAutoCADUDL       <internal> */
/*+
  Questa funzione scrive un file .UDL nel direttorio di memorizzazione
  dei DataSource Files di AutoCAD contenente la descrizione della 
  connessione OLE-DB utilizzata per la tabella OLD della classe.
  Il nome del file è uguale a quello del LPT per la tabella OLD.

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_CLASS::WriteOLDDBConnToAutoCADUDL(void)
{
   C_STRING       LPNName;
   C_DBCONNECTION *pConn;

   if (!ptr_info() || !ptr_attrib_list()) 
      { GS_ERR_COD = eGSInvClassType; return GS_BAD; }

   if ((pConn = ptr_info()->getDBConnection(OLD)) == NULL) return GS_BAD;

   if (getLPNameOld(LPNName) == GS_BAD) return GS_BAD;

   return gsc_SetACADUDLFile(LPNName.get_name(), pConn, ptr_info()->OldTableRef.get_name());
}


/*********************************************************/
/*.doc C_CLASS::CheckValue                    <internal> */
/*+
  Questa funzione controlla la correttezza del valore
  verificando lunghezza, decimali, tipo, obbligatorietà. 
  Il valore viene modificato con quello corretto.
  Parametri:
  C_ATTRIB *pAttrib;    Puntatore all'attributo 
  presbuf   Value;      Nuovo valore dell'attributo

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_CLASS::CheckValue(C_ATTRIB *pAttrib, presbuf Value)
{
   if (!ptr_attrib_list() || !ptr_info()) { GS_ERR_COD = eGSInvClassType; return GS_BAD; }

   if (ptr_attrib_list()->init_ADOType(ptr_info()->getDBConnection(OLD)) == GS_BAD)
      return GS_BAD;

   return pAttrib->CheckValue(Value);
}
int C_CLASS::CheckValues(C_RB_LIST &ColValues, C_ATTRIB **pWrongAttrib)
{
   if (!ptr_attrib_list() || !ptr_info()) { GS_ERR_COD = eGSInvClassType; return GS_BAD; }

   if (ptr_attrib_list()->init_ADOType(ptr_info()->getDBConnection(OLD)) == GS_BAD)
      return GS_BAD;

   return ptr_attrib_list()->CheckValues(ColValues, pWrongAttrib);
}


//-----------------------------------------------------------------------//
presbuf C_CLASS::read_id(C_PROFILE_SECTION_BTREE &ProfileSections, const TCHAR *sub_gs_id)
{
   C_ID      m_id;
   C_RB_LIST list;

   if (m_id.load(ProfileSections, sub_gs_id) == GS_BAD) return NULL;
   
   // sovrascrivo il codice
   m_id.code = id.code;
      
   if ((list << acutBuildList(RTLB, 0)) == NULL) return NULL;
   list += m_id.to_rb();
   if ((list += acutBuildList(RTLE, 0)) == NULL) return NULL;
   list.ReleaseAllAtDistruction(GS_BAD);

   return list.get_head();
}
//-----------------------------------------------------------------------//
presbuf C_CLASS::read_fas(C_PROFILE_SECTION_BTREE &ProfileSections, const TCHAR *sub_gs_id)
{
   C_FAS     m_fas;
   C_RB_LIST list;

   // essendo richiamata anche dalla C_EXTERN la riga seguente 
   // deve essere commentata (di comodo)
   // if (!ptr_fas()) { GS_ERR_COD = eGSInvClassType; return NULL; }

   if (m_fas.load(ProfileSections, sub_gs_id) == GS_BAD) return NULL;
  
   if ((list << acutBuildList(RTLB, 0)) == NULL)   return NULL;
   list += m_fas.to_rb();
   if ((list += acutBuildList(RTLE, 0)) == NULL)   return NULL;
   list.ReleaseAllAtDistruction(GS_BAD);

   return list.get_head();
}
//-----------------------------------------------------------------------//
presbuf C_CLASS::read_info(C_PROFILE_SECTION_BTREE &ProfileSections, const TCHAR *sub_gs_id)
{
   C_BPROFILE_SECTION *pProfileSection;
   C_2STR_BTREE       *pProfileEntries;
   C_B2STR            *pProfileEntry;
   C_INFO    m_info;
   C_RB_LIST list;

   if (!(pProfileSection = (C_BPROFILE_SECTION *) ProfileSections.search(sub_gs_id))) return NULL;
   pProfileEntries = (C_2STR_BTREE *) pProfileSection->get_ptr_EntryList();
   if ((pProfileEntry = (C_B2STR *) pProfileEntries->search(_T("INFO.KEY_ATTRIB"))))
      // sovrascrivo l'attributo chiave
      m_info.key_attrib = pProfileEntry->get_name2();
      
   if ((list << acutBuildList(RTLB, 0)) == NULL) return NULL;
   list += m_info.to_rb();
   if ((list += acutBuildList(RTLE, 0)) == NULL) return NULL;
   list.ReleaseAllAtDistruction(GS_BAD);

   return list.get_head();
}
//-----------------------------------------------------------------------//
presbuf C_CLASS::read_GphInfo(C_PROFILE_SECTION_BTREE &ProfileSections, const TCHAR *sub_gs_id)
{
   C_GPH_INFO   *pGphInfo;
   C_STRING     dummy;
   C_RB_LIST    list;
   C_2STR_BTREE *pProfileEntries;
   C_B2STR      *pProfileEntry;
   C_BPROFILE_SECTION *pProfileSection;

   if (!(pProfileSection = (C_BPROFILE_SECTION *) ProfileSections.search(sub_gs_id))) return NULL;
   pProfileEntries = (C_2STR_BTREE *) pProfileSection->get_ptr_EntryList();
   if (!(pProfileEntry = (C_B2STR *) pProfileEntries->search(_T("GPH_INFO.SOURCE_TYPE"))))
      return NULL;

   dummy = pProfileEntry->get_name2();
   GraphDataSourceEnum dataSourceType = (GraphDataSourceEnum) dummy.toi();
   if (!(pGphInfo = gsc_alloc_GraphInfo(dataSourceType))) return NULL;

   if (pGphInfo->load(ProfileSections, sub_gs_id) == GS_BAD) return NULL;
  
   if ((list << acutBuildList(RTLB, 0)) == NULL)   return NULL;
   list += pGphInfo->to_rb();
   if ((list += acutBuildList(RTLE, 0)) == NULL)   return NULL;
   list.ReleaseAllAtDistruction(GS_BAD);

   return list.get_head();
}

// Le connessioni non sono gestite durante la creazione automatica della classe
// (ad eccezione delle simulazioni)
presbuf C_CLASS::read_connect(C_PROFILE_SECTION_BTREE &ProfileSections, const TCHAR *sub_gs_id)
   { GS_ERR_COD = eGSInvClassType; return NULL; }


/*********************************************************/
/*.doc C_CLASS::read_attrib <internal> */
/*+
  Questa funzione carica la struttura della tabella di una
  classe leggendola da file.
  Parametri:
  C_PROFILE_SECTION_BTREE &ProfileSections; File di profilo letto in memoria
  const TCHAR *sez;   nome della sezione
    
  Restituisce una lista di resbuf in caso di successo altrimenti restituisce NULL.
  N.B. : Tutti i tipi di attributi devono essere espressi in ACCESS 97 (Direct)
-*/  
/*********************************************************/
presbuf C_CLASS::read_attrib(C_PROFILE_SECTION_BTREE &ProfileSections, const TCHAR *sez)
{
   C_ATTRIB_LIST  attrib_list;
   C_RB_LIST      list;
   C_DBCONNECTION *pSrcConn, *pConn;

   // essendo richiamata anche dalla C_EXTERN la riga seguente 
   // deve essere commentata (di comodo)
   // if (!ptr_attrib_list()) { GS_ERR_COD = eGSInvClassType; return NULL; }

   // Connessione di default = ACCESS 97 (Direct)
   if ((pSrcConn = GEOsimAppl::DBCONNECTION_LIST.get_Connection()) == NULL) return NULL;

   if (attrib_list.load(ProfileSections, sez, pSrcConn) == GS_BAD) return NULL;
   // prima di convertirla nel Provider di destinazione verifico
   // la lista degli attributi (la funzione is_valid sistema eventuali
   // errori nella dimensione e nei decimali degli attributi numerici)
   if (attrib_list.is_valid(pSrcConn) == GS_BAD) return NULL;

   if ((pConn = ptr_info()->getDBConnection(OLD)) == NULL) return NULL;
   // Converto nei tipi della classe
   if (attrib_list.Convert2ProviderType(pSrcConn, pConn) != GS_GOOD) return NULL;

   if ((list << acutBuildList(RTLB, 0)) == NULL) return NULL;
   list += attrib_list.to_rb();
   if ((list += acutBuildList(RTLE, 0)) == NULL) return NULL;
   list.ReleaseAllAtDistruction(GS_BAD);

   return list.get_head();
}


/*********************************************************/
/*.doc C_CLASS::read_stru                     <internal> */
/*+
   Questa funzione carica la struttura della classe leggendola da file
   per la sua creazione in automatico.
   Parametri:
   C_PROFILE_SECTION_BTREE &ProfileSections; File di profilo letto in memoria
 
   Restituisce una lista di resbuf in caso di successo altrimenti restituisce NULL.
   N.B. La C_INFO, se esistente, deve avere il collegamento OLE-DB già inizializzato.
-*/  
/*********************************************************/
presbuf C_CLASS::read_stru(C_PROFILE_SECTION_BTREE &ProfileSections)
{
   C_RB_LIST list, rbPropList;
   presbuf   p;
    
   if ((list += acutBuildList(RTLB, 0)) == NULL) return NULL;
   // C_ID
   if ((p = read_id(ProfileSections)) == NULL) return NULL;
   list += p;

   // C_INFO
   if (ptr_info())
   {
      C_B2STR        *pProfileEntry;
      C_DBCONNECTION *pConn;
      C_STRING       OldTableRef, Catalog, Schema, Table, buffer;

      rbPropList << ptr_info()->UDLProperties.to_rb();

      if ((list += acutBuildList(RTLB, RTLB,
                                 RTSTR, (ptr_info()->ConnStrUDLFile.len() == 0) ? GS_EMPTYSTR : ptr_info()->ConnStrUDLFile.get_name(), // ConnStrUDLFile
                                 RTLB, 0)) == NULL) 
         return NULL;
      list += gsc_rblistcopy(rbPropList.get_head());
      // TABLE_REF
      if (!(pProfileEntry = ProfileSections.get_entry(_T("0"), _T("INFO_TABLEREF")))) return NULL;
      buffer = pProfileEntry->get_name2();
      buffer.alltrim();
      // Conversione riferimento tabella da dir assoluto in relativo
      if ((pConn = ptr_info()->getDBConnection(OLD)) == NULL) return NULL;
      if (OldTableRef.paste(pConn->FullRefTable_nethost2drive(buffer.get_name())) == NULL)
         return NULL;

      if (pConn->split_FullRefTable(OldTableRef, Catalog, Schema, Table) == GS_BAD)
         return NULL;
      if (ptr_info()->OldTableRef.len() > 0)
      {
         if (pConn->split_FullRefTable(ptr_info()->OldTableRef, Catalog, Schema, buffer) == GS_BAD)
            return NULL;
      }
      else
      {
         Catalog.clear();
         Schema.clear();
      }

      if ((list += acutBuildList(RTLE, RTLB,
                                 RTSTR, (Catalog.get_name()) ? Catalog.get_name() : GS_EMPTYSTR,
                                 RTSTR, (Schema.get_name()) ? Schema.get_name() : GS_EMPTYSTR,
                                 RTSTR, (Table.get_name()) ? Table.get_name() : GS_EMPTYSTR,
                                 RTLE, RTLE, RTLE, 0)) == NULL) 
         return NULL;
   }

   // C_FAS
   if (ptr_fas())
   {
      if ((p = read_fas(ProfileSections)) == NULL) return NULL;
      list += p;
   }

   // C_ATTRIB_LIST
   if (ptr_attrib_list())
   {
      if ((p = read_attrib(ProfileSections)) == NULL) return NULL;
      list += p;
   }

   if ((list += acutBuildList(RTLE, 0)) == NULL) return NULL;
   list.ReleaseAllAtDistruction(GS_BAD);

   return list.get_head();
}


/*********************************************************/
/*.doc C_CLASS::write_stru                    <internal> */
/*+
   Questa funzione scrive la struttura della classe in un file
   per generare file per la creazione automatica di classi.
   Parametri:
   C_STRING       &filename;  path del file
   C_DBCONNECTION *pConn;     Connessione OLE-DB da usare per scrivere la struttura
                              della tabella (default = NULL), se non indicata verrà
                              utilizzata la connessione di default di GEOsim.

   Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_CLASS::write_stru(C_STRING &filename, C_DBCONNECTION *pConn)
{
   C_PROFILE_SECTION_BTREE ProfileSections;
   bool                    Unicode = false;

   if (gsc_path_exist(filename) == GS_GOOD)
      if (gsc_read_profile(filename, ProfileSections, &Unicode) == GS_BAD) return GS_BAD;

   // C_ID
   if (ptr_id()->ToFile(ProfileSections, _T("0")) == GS_BAD) return GS_BAD;

   // C_INFO
   if (ptr_info())
   {
      C_DBCONNECTION *pOldConn, *pExportConn;
      C_STRING       OldTableRef, Catalog, Schema, Table, buffer;

      if (pConn) pExportConn = pConn;
      else
         // Ottengo la connessione OLE-DB di default
         if ((pExportConn = GEOsimAppl::DBCONNECTION_LIST.get_Connection()) == NULL)
            return GS_BAD;

      // TABLE_REF
      // Conversione riferimento tabella da dir relativo in assoluto
      if ((pOldConn = ptr_info()->getDBConnection(OLD)) == NULL) return GS_BAD;
      if (OldTableRef.paste(pOldConn->FullRefTable_drive2nethost(ptr_info()->OldTableRef.get_name())) == NULL)
         return GS_BAD;

      if (pOldConn->split_FullRefTable(OldTableRef, Catalog, Schema, Table) == GS_BAD)
         return GS_BAD;
      if (buffer.paste(pExportConn->get_FullRefTable(Catalog, Schema, Table)) == NULL)
         return GS_BAD;
      if (ProfileSections.set_entry(_T("0"), _T("INFO_TABLEREF"), buffer.get_name()) == GS_BAD)
         return GS_BAD;

      // C_ATTRIB_LIST
      if (ptr_attrib_list())
      {
         C_ATTRIB_LIST ExportAttribList;

         if (ptr_attrib_list()->copy(&ExportAttribList) == GS_BAD) return GS_BAD;
         // Converto nei tipi della classe
         if (ExportAttribList.Convert2ProviderType(pOldConn, pExportConn) != GS_GOOD)
            return GS_BAD;

         if (ExportAttribList.ToFile(ProfileSections, _T("0.A")) == GS_BAD) return GS_BAD;
      }
   }

   // C_FAS
   if (ptr_fas())
      if (ptr_fas()->ToFile(ProfileSections, _T("0")) == GS_BAD) return GS_BAD;

   // C_GRAPH_INFO
   if (ptr_GphInfo())
      if (ptr_GphInfo()->ToFile(ProfileSections, _T("0")) == GS_BAD) return GS_BAD;

   return gsc_write_profile(filename, ProfileSections, Unicode);
}


/*********************************************************/
/*.doc C_CLASS::RefreshTempLastId <internal> */
/*+
  Questa funzione aggiorna il membro TempLastId della classe e
  delle tabelle secondarie interne.
  Parametri:

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_CLASS::RefreshTempLastId(void)
{
   C_STRING       TempTableRef;
   C_DBCONNECTION *pConn;
   double         Value;

   if (ptr_info() == NULL) { GS_ERR_COD = eGSInvClassType; return GS_BAD; }

   // Se la classe non è estratta nella sessione corrente
   if (is_extracted() == GS_BAD) 
      { GS_ERR_COD = eGSNotCurrentSession; return GS_BAD; }
   // ricavo connessione OLE-DB per tabella TEMP
   if ((pConn = ptr_info()->getDBConnection(TEMP)) == NULL) return GS_BAD;
   // senza creare la tabella
   if (getTempTableRef(TempTableRef, GS_BAD) == GS_BAD) return GS_BAD;
   if (pConn->ExistTable(TempTableRef) == GS_GOOD)
      // ricavo il codice minore
      if (pConn->GetNumAggrValue(TempTableRef.get_name(),
                                 ptr_info()->key_attrib.get_name(),
                                 _T("MIN"), &Value) != GS_GOOD) return GS_BAD;
   ptr_info()->TempLastId = (long) Value;

   return RefreshSecTempLastId();
}


/*********************************************************/
/*  FINE FUNZIONI DELLA CLASSE C_CLASS                   */
/*  INIZIO FUNZIONI DELLA CATEGORIA C_SIMPLEX            */
/*********************************************************/


C_SIMPLEX::C_SIMPLEX() : C_CLASS()
{
   id.category        = CAT_SIMPLEX;
   ptr_secondary_list = new C_SECONDARY_LIST(this);
   pGphInfo           = NULL;
}
C_SIMPLEX::~C_SIMPLEX()
{
   if (pGphInfo) delete pGphInfo;
}

int C_SIMPLEX::allocGraphInfo(GraphDataSourceEnum Type)
{
   deallocGphInfo();
   pGphInfo = gsc_alloc_GraphInfo(Type);
   return (pGphInfo == NULL) ? GS_BAD : GS_GOOD;
}

void C_SIMPLEX::deallocGphInfo(void)
{ if (pGphInfo) { delete pGphInfo; pGphInfo = NULL; } }

int C_SIMPLEX::copy(C_CLASS *out)
{
   if (!out) { GS_ERR_COD=eGSNotAllocVar; return GS_BAD; }
   id.copy(out->ptr_id());
   info.copy(out->ptr_info());
   fas.copy(out->ptr_fas());

   if (ptr_GphInfo())
   {
      out->allocGraphInfo(ptr_GphInfo()->getDataSourceType());
      ptr_GphInfo()->copy(out->ptr_GphInfo());
   }

   connect_list.copy(out->ptr_connect_list());
   attrib_list.copy(out->ptr_attrib_list());

   return GS_GOOD;
}
//-----------------------------------------------------------------------//
int C_SIMPLEX::load_info(TCHAR *filename)
{
   TCHAR sez[SEZ_PROFILE_LEN]; 

   swprintf(sez, SEZ_PROFILE_LEN, _T("%d.0"), id.code);
   
   return info.load(filename, sez);
}
//-----------------------------------------------------------------------//
int C_SIMPLEX::load_connect_list(TCHAR *filename)
{
   TCHAR sez[SEZ_PROFILE_LEN]; 

   swprintf(sez, SEZ_PROFILE_LEN, _T("%d.0"), id.code);
   return connect_list.load(filename, sez);
}
//-----------------------------------------------------------------------//
int C_SIMPLEX::ToFile(C_STRING &filename)
{
   C_PROFILE_SECTION_BTREE ProfileSections;
   bool                    Unicode = false;

   if (gsc_path_exist(filename) == GS_GOOD)
      if (gsc_read_profile(filename, ProfileSections, &Unicode) == GS_BAD) return GS_BAD;

   if (ToFile(ProfileSections) == GS_BAD) return GS_BAD;

   return gsc_write_profile(filename, ProfileSections, Unicode);
}
int C_SIMPLEX::ToFile(C_PROFILE_SECTION_BTREE &ProfileSections)
{
   TCHAR sez[SEZ_PROFILE_LEN];

   swprintf(sez, SEZ_PROFILE_LEN, _T("%d.0"), id.code);
   if (id.ToFile(ProfileSections, sez) == GS_BAD)    return GS_BAD;
   if (info.ToFile(ProfileSections, sez) == GS_BAD)  return GS_BAD;
   if (fas.ToFile(ProfileSections, sez) == GS_BAD)   return GS_BAD;   
   if (ptr_GphInfo())
      if (ptr_GphInfo()->ToFile(ProfileSections, sez) == GS_BAD) return GS_BAD;
   if (connect_list.ToFile(ProfileSections, sez) == GS_BAD) return GS_BAD;
   wcscat(sez, ATTRIB_PROFILE);
   if (attrib_list.ToFile(ProfileSections, sez) == GS_BAD) return GS_BAD;

   return GS_GOOD;
}
//-----------------------------------------------------------------------//
int C_SIMPLEX::load(TCHAR *filename, int cl)
{
   C_PROFILE_SECTION_BTREE ProfileSections;

   if (gsc_read_profile(filename, ProfileSections) == GS_BAD) return GS_BAD;
   return load(ProfileSections, cl);
}
int C_SIMPLEX::load(C_PROFILE_SECTION_BTREE &ProfileSections, int cl)
{
   TCHAR               sez[SEZ_PROFILE_LEN];
   GraphDataSourceEnum SrcType;
   int                 Result;

   swprintf(sez, SEZ_PROFILE_LEN, _T("%d.0"), cl);

   if ((Result = id.load(ProfileSections, sez)) != GS_GOOD) return Result;
   if (info.load(ProfileSections, sez) != GS_GOOD)          return GS_BAD;
   if (fas.load(ProfileSections, sez) != GS_GOOD)           return GS_BAD;  
   if ((SrcType = gsc_getGraphDataSourceType(ProfileSections, sez)) == GSNoneGphDataSource)
      return GS_BAD;
   if (allocGraphInfo(SrcType) == GS_BAD)                    return GS_BAD;
   if (ptr_GphInfo()->load(ProfileSections, sez) != GS_GOOD) return GS_BAD;
   if (connect_list.load(ProfileSections, sez) != GS_GOOD)   return GS_BAD;
   wcscat(sez, ATTRIB_PROFILE);
   return attrib_list.load(ProfileSections, sez, ptr_info()->getDBConnection(OLD));
}


/*********************************************************/
/*.doc C_SIMPLEX::to_rb                       <external> */
/*+
  Questa funzione scrive la definizione di una classe C_SIMPLEX 
  in formato resbuf.
  (<C_ID><C_INFO><C_FAS><C_GPH_INFO><C_CONNECT_LIST><C_ATTRIB_LIST>) 
  Parametri:
  presbuf rb;     lista descrizione classe
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
resbuf *C_SIMPLEX::to_rb(void)             
{
   C_RB_LIST List;

   if ((List << acutBuildList(RTLB, 0)) == NULL) return NULL;
   // C_ID
   if ((List += id.to_rb()) == NULL) return NULL;
   if ((List += acutBuildList(RTLE, RTLB, 0)) == NULL) return NULL;
   // C_INFO
   if ((List += info.to_rb()) == NULL) return NULL;
   if ((List += acutBuildList(RTLE, RTLB, 0)) == NULL) return NULL;
   // C_FAS
   if ((List += fas.to_rb()) == NULL) return NULL;
   if ((List += acutBuildList(RTLE, RTLB, 0)) == NULL) return NULL;
   // C_GPH_INFO
   if (ptr_GphInfo())
   {
      if ((List += ptr_GphInfo()->to_rb()) == NULL) return NULL;
      if ((List += acutBuildList(RTLE, RTLB, 0)) == NULL) return NULL;
   }
   // C_CONNECT_LIST
   if ((List += connect_list.to_rb()) == NULL) return NULL;
   if ((List += acutBuildList(RTLE, RTLB, 0)) == NULL) return NULL;
   // C_ATTRIB_LIST
   if ((List += attrib_list.to_rb()) == NULL) return NULL;
   if ((List += acutBuildList(RTLE, 0)) == NULL) return NULL;
   
   List.ReleaseAllAtDistruction(GS_BAD);

   return List.get_head();
}


/*********************************************************/
/*.doc from_rb <internal> */
/*+
  Questa funzione carica i dati di una classe C_SIMPLEX da un resbuf.
  (<id><info><fas><gph_info><attrib_list><connect_list>)
  Parametri:
  presbuf rb;     lista descrizione classe
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_SIMPLEX::from_rb(resbuf *rb)
{
   presbuf             p;
   GraphDataSourceEnum SrcType;

   if (id.from_rb(gsc_nth(0,rb))==GS_BAD)   return GS_BAD;
   if (info.from_rb(gsc_nth(1,rb))==GS_BAD) return GS_BAD;
   if (fas.from_rb(gsc_nth(2,rb))==GS_BAD)  return GS_BAD;

   p = gsc_nth(3, rb);
   if ((SrcType = gsc_getGraphDataSourceType(p)) == GSNoneGphDataSource) return GS_BAD;
   if (allocGraphInfo(SrcType) == GS_BAD) return GS_BAD;
   if (ptr_GphInfo()->from_rb(p) == GS_BAD) return GS_BAD;

   if (attrib_list.from_rb(gsc_nth(4,rb))==GS_BAD) return GS_BAD;
   if (connect_list.from_rb(gsc_nth(5,rb))==GS_BAD) return GS_BAD;

   return GS_GOOD;
}


/*********************************************************/
/*.doc from_db <internal> */
/*+
  Questa funzione carica la definizione di una classe SIMPLEX dai database.
  Parametri:
  C_RB_LIST &ColValues;                lista colonna-valore della riga di GS_CLASS
  GSDataPermissionTypeEnum cod_level;  livello di abilitazione per la classe
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_SIMPLEX::from_db(C_RB_LIST &ColValues, GSDataPermissionTypeEnum cod_level)
{  
   // C_ID
   if (id.from_rb_db(ColValues, cod_level) == GS_BAD) return GS_BAD;
   // C_INFO
   if (info.from_rb_db(ColValues) == GS_BAD) return GS_BAD;
   // C_FAS
   if (fas.from_db(id.pPrj, id.code, id.sub_code) == GS_BAD) return GS_BAD;
   // C_GPH_INFO
   if ((pGphInfo = gsc_GphDataSrcFromDB(id.pPrj, id.code, id.sub_code)) == NULL)
      return GS_BAD;
   // CONNECT LIST
   if (restore_connectlist() == GS_BAD) return GS_BAD;
   // ATTRIBUTE LIST
   if (restore_attriblist() == GS_BAD)  return GS_BAD;

   return GS_GOOD;
}   
   
  
/*********************************************************/
/*.doc create <internal> */
/*+
  Questa funzione crea una classe C_SIMPLEX nei database.
    
  Restituisce codice classe in caso di successo altrimenti restituisce 0.
-*/  
/*********************************************************/
int C_SIMPLEX::create(void)
{
   C_RB_LIST      simplex;
   presbuf        p;
   int            new_code, error_code = eGSNoError, result = GS_BAD;
   C_DBCONNECTION *pConn;

   // verifico abilitazione
   if (gsc_check_op(opCreateClass) == GS_BAD) return 0;

   acutPrintf(_T("%s <%s>..."), gsc_msg(346), id.name); // "\nCreazione classe"

   if (ptr_GphInfo() == NULL) return 0;

   // Inizializzazioni
   id.code   = 0;
   id.abilit = GSUpdateableData;
   id.sel    = DESELECTED;
   info.pOldTabConn = NULL;

   // carico eventuali funzioni di calcolo in GSL.GSL del progetto della classe
   gsc_load_gsl(get_pPrj()->get_dir());

   // ricavo connessione OLE-DB
   if ((pConn = ptr_info()->getDBConnection(OLD)) == NULL) { gs_gsl_reload(); return 0; }
   // verifico id
   if (is_validid() == GS_BAD) { gs_gsl_reload(); return 0; }
   // verifico fas
   if (is_validfas(id.type, pConn, ptr_attrib_list()) == GS_BAD) { gs_gsl_reload(); return 0; }
   // verifico connessione a sorgente grafica
   if (ptr_GphInfo()->isValid(id.type) == GS_BAD) { gs_gsl_reload(); return 0; }
   // verifico info
   if (is_validinfo() == GS_BAD) { gs_gsl_reload(); return 0; }
   // verifico connect list
   if (is_validconnectlist() == GS_BAD) { gs_gsl_reload(); return 0; }
   // verifico attrib list
   if (attrib_list.is_valid(pConn) == GS_BAD) { gs_gsl_reload(); return 0; }
   // salto questo controllo se la tabella è esterna
   if (info.LinkedTable == false)
      if (attrib_list.is_valid(id.category, id.type, pConn, info.key_attrib, ptr_fas()) == GS_BAD)
         { gs_gsl_reload(); return 0; }

	// ricarico GSL.GSL giusto
	gs_gsl_reload();
   
   if ((simplex << acutBuildList(RTLB, 0)) == NULL) return 0;
   
   // C_ID
   if (id.to_rb_db(&p) == GS_BAD) return 0;
   simplex += p;
     
   // C_INFO converto i percorsi da relativi in assoluti per scrivere in DB
   info.OldLastId = info.TempLastId = 0;
   if ((p = info.to_rb(true, true)) == NULL) return 0;
   simplex += p;
   
   if ((simplex += acutBuildList(RTLE, 0)) == NULL) return 0;

   // creo directory della tabella, creo tabella e indice 
   if (create_tab() == GS_BAD) return 0;

   // inserisco nuova classe in GS_CLASS
   if ((new_code = ins_cls_to_gs_class(simplex)) == GS_BAD) 
      { del_tab_class(); return 0; }

   // Inizializzo la GphInfo
   bool GeomExist, LblGroupingExist, LblExist;
   ptr_GphInfo()->prj = id.pPrj->get_key();
   ptr_GphInfo()->cls = new_code;
   ptr_GphInfo()->sub = 0;
   // Se esiste già la risorsa grafica e
   if (ptr_GphInfo()->ResourceExist(&GeomExist, &LblGroupingExist, &LblExist) && 
       // se si tratta di dwg oppure 
       // se si tratta di db ed esiste anche una sola delle tabelle geometriche 
       // che non è stata dichiarata come "collegata"
       (ptr_GphInfo()->getDataSourceType() == GSDwgGphDataSource ||
        (ptr_GphInfo()->getDataSourceType() == GSDBGphDataSource &&
         (GeomExist && !((C_DBGPH_INFO *) ptr_GphInfo())->LinkedTable ||
          LblGroupingExist && !((C_DBGPH_INFO *) ptr_GphInfo())->LinkedLblGrpTable ||
          LblExist && !((C_DBGPH_INFO *) ptr_GphInfo())->LinkedLblTable))))
   {
      C_STRING statement, ClassesTableRef;

      if (get_pPrj()->getClassesTabInfo(&pConn, &ClassesTableRef) == GS_GOOD)
      {
         // cancello la riga in GS_CLASS
         statement = _T("DELETE FROM ");
         statement += ClassesTableRef;
         statement += _T(" WHERE GS_ID=");
         statement += new_code;
         pConn->ExeCmd(statement);
      }
      del_tab_class();

      GS_ERR_COD = eGSGraphResourceAlreadyExisting; 
      return 0; 
   }

   do
   {
      // Inserisco caratteristiche grafiche in DB
      if (fas.to_db(get_pPrj(), new_code) == GS_BAD) break;

      // Inserisco informazioni sulla sorgente grafica in DB
      if (ptr_GphInfo()->to_db() == GS_BAD) break;

      // creo sorgente grafica
      if (ptr_GphInfo()->CreateResource(id.type) == GS_BAD) break;
   
      // salto questo funzione se la tabella è esterna
      if (info.LinkedTable == false)
         // scarico valori di default in tabella
         if (default_to_db(&attrib_list) == GS_BAD) break;
   
      // scarico su tabella GS_ATTR le caratteristiche degli attributi
      if (carattattr_to_db(&attrib_list) == GS_BAD) break;

      // scarico la connect list
      if (to_db_connectlist(ptr_connect_list()) == GS_BAD) break;

      result = GS_GOOD;
   }
   while (0);

   if (result == GS_BAD)
   {
      error_code = GS_ERR_COD;
      del((TCHAR *) GEOsimAppl::GS_USER.pwd);
      GS_ERR_COD = error_code;
      return 0;
   }

   // creazione collegamento progetto -> classe
   if (get_pPrj()->ptr_classlist()->add_tail(this) == GS_BAD) return 0;
   // aggiorno il codice progressivo per la creazione di classi del progetto
   get_pPrj()->setNextClassId(id.code + 1);

   // memorizzo il codice del progetto in GEOSIM.INI
   gsc_setLastUsedPrj(get_PrjId());

   return new_code;
}   


/*********************************************************/
/*.doc del <internal> */
/*+
  Questa funzione cancella una classe C_SIMPLEX nei database.
  La protezione è garantita perchè prima dell'operazione viene bloccata la
  relativa riga in GS_CLASS. Poichè qualsiasi operazione efettuata su questa
  classe tenta di bloccare la classe in GS_CLASS, si ha la certezza che tutte
  le risorse della classe siano utilizzate da un solo utente alla volta.
  Parametri:
  const TCHAR *Password;    Password dell'utente corrente (per controllo)
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_SIMPLEX::del(const TCHAR *Password)
{
   C_DBCONNECTION *pConn;
   C_FAMILY_LIST  family_list;
   int            result;
   C_STRING       statement, ClassesTableRef;

   // verifico abilitazione
   if (gsc_check_op(opDelClass) == GS_BAD) return GS_BAD;
   if (id.abilit != GSUpdateableData)
      { GS_ERR_COD = eGSClassLocked; return GS_BAD; }
   // verifico che la password sia corretta
   if (gsc_strcmp(Password, (TCHAR *) GEOsimAppl::GS_USER.pwd) != 0)
      { GS_ERR_COD = eGSInvalidPwd; return GS_BAD; }

   // verifico se la classe che si sta cancellando è legata ad altre
   if (gsc_getfamily(get_pPrj(), &family_list) == GS_BAD) return GS_BAD;
   if (family_list.search_list(id.code) != NULL)
      { GS_ERR_COD = eGSMemberOfGroup; return GS_BAD; }

   // blocco la classe in modo esclusivo GS_CLASS usando come semaforo
   // il codice della sessione attiva, se esistente, altrimenti il codice utente 
   long OwnerCode = (GS_CURRENT_WRK_SESSION) ? GS_CURRENT_WRK_SESSION->get_id() : GEOsimAppl::GS_USER.code * -1;
   if (set_exclusive_use(OwnerCode, &result) == GS_BAD || result == GS_BAD)
      return GS_BAD;

   // verifico se la classe fa parte di una sessione di lavoro
   long WrkSessionId;
   if (gsc_is_inarea(get_PrjId(), id.code, &WrkSessionId) == GS_BAD || WrkSessionId > 0)
      { GS_ERR_COD = eGSSessionsFound; return GS_BAD; }

   acutPrintf(_T("%s %s..."), gsc_msg(356), id.name); // "\nCancellazione classe"

   // cancello tabelle secondarie
   del_all_tab_sec(Password);

   // cancello tabelle della classe
   del_tab_class();

   // cancello le informazioni grafiche della classe
   fas.del_db(get_pPrj(), id.code);
   
   // cancello le informazioni relative alla sorgente grafica 
   // della classe ed eventuali sottoclassi
   // rimuovendo anche le risorse grafiche (disegni, cartelle ...)
   if (ptr_GphInfo()) ptr_GphInfo()->del_db(true);

   // cancello abilitazioni alla classe per tutti gli utenti 
   gsc_delClassPermissions(get_PrjId(), id.code);

   // cancello lista connessioni in memoria per tutte le altre classi
   gsc_del_memconnect(get_pPrj(), id.code);
   // cancello lista connessioni nei DB
   del_db_conc(ALL);

   // cancello connessioni delle altre classi su classe in oggetto in memoria
   del_mem_conc();

   // cancello caratteristiche attributi
   del_db_carattattr();

   // Cancello la classe dal set di classi del progetto
   del_db_ClassSet();

   // ricavo connessione OLE-DB
   if ((pConn = ptr_info()->getDBConnection(OLD)) &&
       pConn->get_CatalogResourceType() == DirectoryRes)
   {
      C_STRING Catalog, Schema, Table, Path;

      if (pConn->split_FullRefTable(ptr_info()->OldTableRef, Catalog,
                                    Schema, Table) == GS_GOOD &&
          gsc_RefTable2Path(pConn->get_DBMSName(), Catalog, Schema, Table, Path) == GS_GOOD)
         // Cancello direttorio
         gsc_rmdir_from_path(Path.get_name());
   }

   if (get_pPrj()->getClassesTabInfo(&pConn, &ClassesTableRef) == GS_BAD)
      { set_share_use(); return GS_BAD; }
   // cancello la riga in GS_CLASS
   statement = _T("DELETE FROM ");
   statement += ClassesTableRef;
   statement += _T(" WHERE GS_ID=");
   statement += id.code;
   if (pConn->ExeCmd(statement) == GS_BAD) return GS_BAD;

   // Cancellazione files di supporto
   DelSupportFiles();

   // cancellazione collegamento progetto -> classe
   return get_pPrj()->ptr_classlist()->remove(this);
}


/*********************************************************/
/*.doc is_validfas <internal> */
/*+
  Questa funzione verifica la correttezza della C_FAS.
  Parametri:
  int type;                     Tipo della classe
  C_DBCONNECTION *pConn;        Connessione OLE-DB
  C_ATTRIB_LIST *p_attrib_list; Lista attributi
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
  N.B. : Deve essere già stato caricato un eventuale GSL.GSL dal progetto della classe
-*/  
/*********************************************************/
int C_SIMPLEX::is_validfas(int type, C_DBCONNECTION *pConn, C_ATTRIB_LIST *p_attrib_list)
{  
   switch (type)
   {
      case TYPE_SURFACE:   // SUPERFICIE
         // Bordo
         if (fas.color.getColorMethod() == C_COLOR::None) return GS_BAD;
         if (gsc_validlinetype(fas.line) == GS_BAD) return GS_BAD;
         if (gsc_validscale(fas.line_scale) == GS_BAD) return GS_BAD;
         if (gsc_validwidth(fas.width) == GS_BAD) return GS_BAD;
         if (gsc_validthickness(fas.thickness) == GS_BAD) return GS_BAD;
         // Riempimento
         if (fas.hatch_color.getColorMethod() == C_COLOR::None) return GS_BAD;
         if (gsc_validscale(fas.hatch_scale) == GS_BAD) return GS_BAD;
         if (gsc_validlayer(fas.hatch_layer) == GS_BAD) return GS_BAD;
         if (gsc_validhatch(fas.hatch) == GS_BAD) return GS_BAD;
         break;
      case TYPE_POLYLINE:  // POLILINEA
         if (fas.color.getColorMethod() == C_COLOR::None) return GS_BAD;
         if (gsc_validlinetype(fas.line) == GS_BAD) return GS_BAD;
         if (gsc_validscale(fas.line_scale) == GS_BAD) return GS_BAD;
         if (gsc_validwidth(fas.width) == GS_BAD) return GS_BAD;
         if (gsc_validthickness(fas.thickness) == GS_BAD) return GS_BAD;
         break;
      case TYPE_TEXT:      // TESTO
         if (fas.color.getColorMethod() == C_COLOR::None) return GS_BAD;
         if (gsc_validtextstyle(fas.style) == GS_BAD) return GS_BAD;
         if (gsc_validhtext(fas.h_text) == GS_BAD) return GS_BAD;
         if (gsc_validthickness(fas.thickness) == GS_BAD) return GS_BAD;
         break;
      case TYPE_NODE:      // NODO
         if (gsc_validblock(fas.block) == GS_BAD) return GS_BAD;
         if (gsc_validscale(fas.block_scale) == GS_BAD) return GS_BAD;
         break;
      default : { GS_ERR_COD = eGSInvClassType; return GS_BAD; }
   }      
   
   // verifico validità layer
   if (gsc_validlayer(fas.layer) == GS_BAD) return GS_BAD;
   // verifico validità file-blocco di riferimento
   if (gsc_validrefblk(&(fas.file_ref_block), fas.ref_block) == GS_BAD) return GS_BAD;
   // verifico validità file-funzione di calcolo per la grafica
   if (gsc_validgphcalc(&(fas.file_graph_calc), fas.fun_graph_calc, p_attrib_list) == GS_BAD)
      return GS_BAD;
   
   return GS_GOOD;
}  


/*********************************************************/
/*.doc C_SIMPLEX::reindexTab <internal> */
/*+
  Questa funzione reindicizza le tabelle della classe.
  Parametri:
  bool OnlyTemp;        Flag, se true indica che devono essere considerate solo
                        le tabelle temporanee (default = false)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
  N.B. Se questa funzione è chiamata in una transazione si possono avere problemi...
-*/  
/*********************************************************/
int C_SIMPLEX::reindexTab(bool OnlyTemp)
{
   int            result = GS_BAD;
   C_DBCONNECTION *pConn;
   TCHAR          Msg[MAX_LEN_MSG];

   do
   {      
      if (!OnlyTemp && !info.LinkedTable) // Se si tratta di una tabella collegata non posso reindicizzare
      {
         // ricavo connessione OLE-DB con tabelle OLD
         if ((pConn = info.getDBConnection(OLD)) == NULL) return GS_BAD;

         if (pConn->ExistTable(info.OldTableRef) == GS_GOOD)
         {
            C_STRING PrimaryKey;

            // Nome della chiave primaria
            if (info.get_PrimaryKeyName(PrimaryKey) == GS_BAD)
               break;
            // Cancello chiave primaria
            if (pConn->DelPrimaryKey(info.OldTableRef.get_name(), PrimaryKey.get_name(), 
                                     ONETEST, GS_BAD) == GS_BAD)
            { // La chiave primaria non c'era. Al suo posto c'era un indice normale.
               C_STRING Catalog, Schema, Name, IndexRef;

               // cancello l'indice per codice chiave
               if (pConn->split_FullRefTable(info.OldTableRef, Catalog, Schema, Name) == GS_BAD)
                  break;

               // Ottengo il nome completo dell'indice per la cancellazione
               if (IndexRef.paste(pConn->getNewFullRefIndex(Catalog.get_name(),
                                                            Schema.get_name(),
                                                            Name.get_name(),
                                                            info.key_attrib.get_name(),
                                                            ERASE)) == NULL)
                  break;
               // cancello indice
               pConn->DelIndex(info.OldTableRef, IndexRef);
            }

            // Creo chiave primaria
            if (pConn->CreatePrimaryKey(info.OldTableRef.get_name(), PrimaryKey.get_name(), 
                                        info.key_attrib.get_name()) == GS_BAD)
               // Se il provider non supporta la creazione di indice (vedi Excel) vado avanti comunque
               if (GS_ERR_COD != eGSExeNotSupported) break;

            // aggiorno ENT_LAST in GS_CLASS
            RefreshOldLastId();
            set_unlocked(0, GS_GOOD, true);
         }
      }

      // se esiste il progetto corrente ed è lo stesso di quello della classe da reindicizzare
      // ed esiste una sessione di lavoro corrente attiva
      if (GS_CURRENT_WRK_SESSION &&
          (GS_CURRENT_WRK_SESSION->get_status() == WRK_SESSION_ACTIVE || GS_CURRENT_WRK_SESSION->get_status() == WRK_SESSION_SAVE) &&
          GS_CURRENT_WRK_SESSION->get_PrjId() == get_PrjId())
      { // sono in una sessione di lavoro
         C_STRING TempTableRef;

         // ricavo connessione OLE-DB per tabella TEMP
         if ((pConn = info.getDBConnection(TEMP)) == NULL) break;

         if (getTempTableRef(TempTableRef, GS_BAD) == GS_BAD) break; // senza creare la tabella
         if (pConn->ExistTable(TempTableRef) == GS_GOOD)
            pConn->Reindex(TempTableRef.get_name());
      }

      // reindicizzo le tabelle secondarie (se fallisce devo comunque continuare)
      reindex_sec(OnlyTemp);

      result = GS_GOOD;
   }
   while (0);

   // Scrivo messaggio nel file log
   if (result == GS_GOOD)
      swprintf(Msg, MAX_LEN_MSG, _T("Database reindex on class %d terminated."), id.code);  
   else
      swprintf(Msg, MAX_LEN_MSG, _T("Database reindex on class %d failed."), id.code);  

   gsc_write_log(Msg);

   return result;
}


/****************************************************************************/
/*.doc C_SIMPLEX::reportHTML                                     <external> */
/*+
  Questa funzione stampa su un file HTML i dati della C_SIMPLEX.
  FILE *file;        Puntatore a file
  const TCHAR *Path; Path del file HTML in cui si sta scrivendo. Server unicamente
                     per poter scrivere le bitmap dei blocchi nello stesso direttorio
                     del file HTML (default = NULL).
  bool SynthMode;    Opzionale. Flag di modalità di report.
                     Se = true attiva il report sintetico (default = false)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/
/******************************************************************************/
int C_SIMPLEX::reportHTML(FILE *file, const TCHAR *Path, bool SynthMode)
{  
   if (id.reportHTML(file, SynthMode) == GS_BAD)   return GS_BAD;
   if (info.reportHTML(file, SynthMode) == GS_BAD) return GS_BAD;
   if (fas.reportHTML(this, file, Path, SynthMode) == GS_BAD)  return GS_BAD;
   if (pGphInfo)
      if (pGphInfo->reportHTML(file, SynthMode) == GS_BAD) return GS_BAD;
   if (attrib_list.reportHTML(file, id.pPrj->get_key(), id.code, id.sub_code, 0,
                              SynthMode) == GS_BAD) return GS_BAD;
   if (connect_list.reportHTML(file, id.pPrj, id.code, id.sub_code,
                               SynthMode) == GS_BAD) return GS_BAD;

   C_SINTH_SEC_TAB_LIST SinthSecList;
   C_SINTH_SEC_TAB      *pSinthSec;
   C_SECONDARY          *pSecondary;
   
   // leggo la lista delle tabelle secondarie
   if (get_pPrj()->getSinthClsSecondaryTabList(id.code, id.sub_code, SinthSecList) == GS_BAD) return GS_BAD;

   pSinthSec = (C_SINTH_SEC_TAB *) SinthSecList.get_head();
   while (pSinthSec)
   {
      if ((pSecondary = (C_SECONDARY *) find_sec(pSinthSec->get_key())) == NULL) return GS_BAD;
      if (pSecondary->reportHTML(file, SynthMode) == GS_BAD) return GS_BAD;

      pSinthSec = (C_SINTH_SEC_TAB *) SinthSecList.get_next();
   }

   return GS_GOOD;
}


/****************************************************************************/
/*.doc C_SIMPLEX::synchronize                                    <external> */
/*+
  Questa funzione sincronizza i database con la grafica.
  Parametri:
  const TCHAR *DeletedObjsDWG; Path del disegno in cui inserire gli oggetti che
                               sono stati cancellati da questa funzione
  TCHAR *NextCmd;               Stringa che identifica una eventuale chiamata 
                               ad un comando da lanciare a fine sessione 
                               (dopo il comando di "NEW"), default = NULL.
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/
/******************************************************************************/
int C_SIMPLEX::synchronize(const TCHAR *DeletedObjsDWG, TCHAR *NextCmd)
{
   C_WRK_SESSION  WrkSession(get_pPrj());
   C_LINK_SET     LinkSet;
   C_SELSET       SSEnt, SSClass, SSChecked, SSToErase;
   C_EED          eed;
   C_RB_LIST      env_variab, ColValues;
   C_STRING       session_dir, FldName, statement, ODTableName, OD_Id;
   C_INT          *pcls_2_extract;
   C_INT_LIST     cls_list_2_extract;
   presbuf        pKey;
   C_DBCONNECTION *pConn;
   _RecordsetPtr  pRs;
   int            result = GS_BAD, PrincExist, AggrFactorCorrected, ODCorrected;
   int            Prj = get_PrjId();
   long           Key, i, AggrFactor, qty = 0;
   ads_name       ent;
   TCHAR          Msg[MAX_LEN_MSG];
   C_STATUSLINE_MESSAGE StatusLineMsg(gsc_msg(1085), id.name); // "Sincronizzazione classe <%s>"

   // verifico abilitazione
   if (gsc_check_op(opSynchronizeClass) == GS_BAD) return GS_BAD;

   // Se si tratta di una tabella collegata non posso sincronizzare la classe
   if (info.LinkedTable) { GS_ERR_COD = eGSClassLocked; return GS_BAD; }
   // Se i dati geometrici sono in tabelle DB collegate (basta una sola)
   if (ptr_GphInfo()->getDataSourceType() == GSDBGphDataSource)
   {
      C_DBGPH_INFO *pGphInfo = (C_DBGPH_INFO *) ptr_GphInfo();
      
      if (pGphInfo->LinkedTable || pGphInfo->LinkedLblGrpTable || pGphInfo->LinkedLblTable)
         { GS_ERR_COD = eGSClassLocked; return GS_BAD; }
   }

   // setto i valori di UNDO, BLIPMODE, HIGHLIGHT per avere massima velocità di ACAD
   if ((env_variab << gsc_setVarForCommandSpeed()) == NULL) return GS_BAD;
   gsc_disableUndoRecording(true);

   swprintf(Msg, MAX_LEN_MSG, _T("Synchronization class %d started."), id.code);  
   gsc_write_log(Msg);

   do
   {
      session_dir = _T("GEOSIM_SYNCHRONIZE_CLS");
      session_dir += id.code;
      if (WrkSession.set_name(session_dir.get_name()) == GS_BAD) break;

      session_dir = get_pPrj()->get_dir();
      session_dir += _T("\\GSSYNCHRONIZE_CLS");
      session_dir += id.code;
      if (WrkSession.set_dir(session_dir.get_name()) == GS_BAD) break;
      WrkSession.set_level(GSUpdateableData);
   
      // Alloca un oggetto C_INT
      if ((pcls_2_extract = new C_INT(id.code)) == NULL)
         { GS_ERR_COD = eGSOutOfMem; break; }
      cls_list_2_extract.add_tail(pcls_2_extract);

      // seleziono classe da estrarre, ed eseguo estrazione
      // effettuo estrazione rendendo la classe in sola lettura alle altre sessioni
      if (gsc_extract_classes((C_PROJECT *) id.pPrj,  // progetto
                              WrkSession,             // sessione di lavoro
                              cls_list_2_extract,     // lista classi
                              TRUE,                   // estrazione in esclusiva
                              NULL,                   // condizione spaziale
                              NULL,                   // condizione di proprietà
                              FALSE,                  // forma NOT oppure no
                              EXTRACTION,             // modo di estrazione
                              &SSClass) == GS_BAD)    // gruppo di selezione estratto
         break;

      // se la classe è stata in modifica
      // (perchè bloccata da un'altra sessione di lavoro)
      if (id.abilit != GSUpdateableData) { GS_ERR_COD = eGSClassLocked; break; }

      if (gsc_callCmd(_T("_.ZOOM"), RTSTR, _T("_E"), 0) != RTNORM) break;

      // sincronizzazione database
      if ((pConn = info.getDBConnection(OLD)) == NULL) break;

      FldName = info.key_attrib;
      if (gsc_AdjSyntax(FldName, pConn->get_InitQuotedIdentifier(),
                        pConn->get_FinalQuotedIdentifier(),
                        pConn->get_StrCaseFullTableRef()) == GS_BAD)
         break;

      statement = _T("SELECT ");
      statement += FldName;
      statement += _T(" FROM ");
      statement += info.OldTableRef;
      statement += _T(" WHERE ");
      statement += FldName;
      statement += _T("<>0 OR ");
      statement += FldName;
      statement += _T(" IS NULL");

      // creo record-set
      // prima era adOpenKeyset poi adOpenDynamic ma postgresql 
      // in una transazione fa casino (al secondo recordset che viene aperto)
      if (pConn->OpenRecSet(statement, pRs, adOpenForwardOnly, adLockOptimistic) == GS_BAD) break;
      if (gsc_InitDBReadRow(pRs, ColValues) == GS_BAD) { gsc_DBCloseRs(pRs); break; }
      pKey = ColValues.CdrAssoc(info.key_attrib.get_name());

      // mi ricavo la tabella OD per eventuali correzioni sui dati OD
      gsc_getODTableName(Prj, id.code, id.sub_code, ODTableName);
      StatusLineMsg.Init(gsc_msg(310), MEDIUM_STEP); // ogni 100 "%ld entità GEOsim elaborate."

      while (gsc_isEOF(pRs) == GS_BAD)
      {
         // per ogni record ricavo gli oggetti grafici collegati
         gsc_DBReadRow(pRs, ColValues);
         if (gsc_rb2Lng(pKey, &Key) == GS_BAD)
         { 
            gsc_DBDelRow(pRs);
            gsc_Skip(pRs);
            
            continue;
         }

         if (LinkSet.GetSS(id.code, id.sub_code, Key, SSEnt) == GS_BAD)
         {
            // Segnalo l'errore su file .LOG e a video
            swprintf(Msg, MAX_LEN_MSG, _T("Lost link between graphic and database on entity: key %ld, prj %d, class %d."),
                     Key, get_PrjId(), id.code);
            gsc_write_log(Msg);
            acutPrintf(gsc_msg(52), Key); // "\nCollegamento tra grafica e database non più valido per l'entità: %ld.\n"

            gsc_DBDelRow(pRs);
            gsc_Skip(pRs);

            continue;
         }

         // Aggiungo al selection set degli oggetti controllati
         SSChecked.add_selset(SSEnt);

         // il fattore di aggregazione deve essere uguale alle istanze grafiche dell'entità
         i = 0;
         AggrFactor = SSEnt.length();
         PrincExist = FALSE;
         AggrFactorCorrected = FALSE;
         ODCorrected         = FALSE;

         while (SSEnt.entname(i++, ent) == GS_GOOD)
         {
            eed.load(ent);
            if (eed.num_el != AggrFactor)
            {  // Correggo il fattore di aggregazione
               eed.save_aggr((int) AggrFactor);
               AggrFactorCorrected = TRUE;
            }
            if (gsc_getIDfromODTable(ent, ODTableName, OD_Id) == GS_BAD)
            {  // Correggo il codice nella tabella OD
               gsc_setID2ODTable(ent, ODTableName, eed.gs_id);
               // Aggiungo in GEOsimAppl::SAVE_SS per salvataggio
               gsc_addEnt2savess(ent);
               ODCorrected = TRUE;
            }

            if (gsc_is_DABlock(ent) == GS_BAD) PrincExist = TRUE;
         }

         if (AggrFactorCorrected) 
         {
            // Segnalo l'errore su file .LOG e a video
            swprintf(Msg, MAX_LEN_MSG, _T("Aggregation factor corrected on entity: key %ld, prj %d, class %d."),
                     Key, Prj, id.code);
            gsc_write_log(Msg);
            acutPrintf(gsc_msg(136), Key); // "\nFattore di aggregazione corretto per l'entità: %ld.\n"
         }
         if (ODCorrected)
         {
            // Segnalo l'errore su file .LOG e a video
            swprintf(Msg, MAX_LEN_MSG, _T("Object Data corrected on entity: ODTableName %s."),
                     ODTableName.get_name());
            gsc_write_log(Msg);
            // "\nDati oggetto corretti per una entità: Tabella %s.\n"
            acutPrintf(gsc_msg(86), ODTableName.get_name());
         }

         // degli oggetti grafici deve esistere almeno un oggetto principale
         if (!PrincExist) 
         {
            // Segnalo l'errore su file .LOG e a video
            swprintf(Msg, MAX_LEN_MSG, _T("Wrong link between graphic and database on entity: key %ld, prj %d, class %d."),
                     Key, Prj, id.code);
            gsc_write_log(Msg);
            acutPrintf(gsc_msg(52), Key); // "\nCollegamento tra grafica e database non più valido per l'entità: %ld.\n"

            // Inserisco nel gruppo di oggetti da cancellare
            SSToErase.add_selset(SSEnt);
            gsc_DBDelRow(pRs);
         }

         gsc_Skip(pRs);

         StatusLineMsg.Set(++qty); // "%ld entità GEOsim elaborate."
      }
      gsc_DBCloseRs(pRs);
      result = GS_BAD;

      StatusLineMsg.End(gsc_msg(310), qty); // "%ld entità GEOsim elaborate."
      
      // Sottraggo da tutti gli oggetti in grafica quelli che hanno 
      // collegamento valido a DB (restano quelli errati)
      SSClass.subtract(SSChecked);
      SSToErase.add_selset(SSClass);
   
      if ((qty = SSToErase.length()) > 0)
      {
         ads_name ss;

         // Segnalo l'errore su file .LOG e a video
         swprintf(Msg, MAX_LEN_MSG, _T("Erased some entities having wrong link between graphic and database."));
         gsc_write_log(Msg);
         acutPrintf(gsc_msg(267)); // "\nAlcune entità con collegamento tra grafica e database non più valido saranno cancellate."

         if (DeletedObjsDWG)
         {  // Esporto oggetti in un file DWG cancellandoli dalla sessione
            ads_point pt;
            C_STRING  dummy(DeletedObjsDWG), ext;

            ads_point_clear(pt);

            // Controlla Correttezza Path
            if (gsc_nethost2drive(dummy) == GS_GOOD)            
            {
               C_LINK   Link;
               C_SELSET SStoExport;

               gsc_splitpath(dummy, NULL, NULL, NULL, &ext);
               if (ext.len() == 0) dummy += _T(".DWG"); // aggiungo l'estensione "DWG"                 

               // Duplicazione oggetti principali con cancellazione link a database e
               // EED (per permettere una successiva importazione)
               i = 0;
               while (SSToErase.entname(i++, ent) == GS_GOOD)
                  if (gsc_is_DABlock(ent) == GS_BAD)
                  {
                     gsc_DeepClone2ModSpace(ent);
                     acdbEntLast(ent);
                     SStoExport.add(ent);
                     Link.erase(ent);
                     eed.clear(ent);
                  }

               if (SStoExport.length() > 0)
               {
                  SStoExport.get_selection(ss);

                  if (gsc_path_exist(dummy) == GS_GOOD)
                  {
                     if (gsc_delfile(dummy) == GS_GOOD)
                        gsc_callCmd(_T("_.WBLOCK"), RTSTR, dummy.get_name(), RTSTR, GS_EMPTYSTR, RTPOINT, pt, RTPICKS, ss, RTSTR, GS_EMPTYSTR, RTSTR, _T("_N"), 0);
                  }
                  else
                     gsc_callCmd(_T("_.WBLOCK"), RTSTR, dummy.get_name(), RTSTR, GS_EMPTYSTR, RTPOINT, pt, RTPICKS, ss, RTSTR, GS_EMPTYSTR, RTSTR, _T("_N"), 0);

                  swprintf(Msg, MAX_LEN_MSG, _T("Please, look at the <%s> file."), dummy.get_name());
                  gsc_write_log(Msg);
               }
            }
         }

         // Aggiungo in GEOsimAppl::SAVE_SS per salvataggio
         gsc_addSS2savess(SSToErase);
         
         // Prima di cancellare gli oggetti ciclo su di essi per verificare
         // se qualcuno ha una EED NON della classe in oggetto
         // in questo caso devo correggerla altrimenti il salvataggio lo considererà
         i = 0;
         while (SSToErase.entname(i++, ent) == GS_GOOD)
		      if (eed.load(ent) != GS_GOOD || eed.cls != id.code || eed.sub != 0)
            {
               eed.cls = id.code;
               eed.sub = 0;
               eed.save(ent, GS_BAD); // non aggiungo in GEOsimAppl::SAVE_SS perchè già fatto
            }

         // Cancello gli oggetti
         SSToErase.Erase();
      }

      // salvataggio della parte grafica delle entità di GEOsim
      if (save_GeomData() == GS_BAD) break;

      // Sincronizzazione tabelle secondarie
      synchronize_sec();

      result = GS_GOOD;
   }
   while (0);

   swprintf(Msg, MAX_LEN_MSG, _T("Synchronization class %d terminated."), id.code);  
   gsc_write_log(Msg);

   // rispristino i valori precedenti di UNDO, BLIPMODE, HIGHLIGHT
   gsc_disableUndoRecording(false);
   gsc_setVarForCommandNormal(env_variab.get_head());

   // uscita dalla sessione di lavoro
   if (GS_CURRENT_WRK_SESSION)
   { 
      // Inizializzo queste variabili prima di chiamare gsc_ExitCurrSession che 
      // toglie dalla memoria questa classe
      TCHAR Msg[256];
      int   Cls = id.code; 

      swprintf(Msg, MAX_LEN_MSG, gsc_msg(289), id.name);

      // rilascio tutti i DWG della classe altrimenti non si potrebbe
      // ristorare il backup dei DWG che risulterebbero in uso
      GphDetach();

      // uscita dalla sessione di lavoro
      if (gsc_ExitCurrSession(GS_BAD, NextCmd) == GS_GOOD)
      {
         // "Messaggio GEOsim: La classe <%s> non è più in uso esclusivo."
         gsc_NotifyWaitForSave(Prj, Cls, Msg);
         gsc_NotifyWaitForExtraction(Prj, Cls, Msg);
      }
   }

   // memorizzo il codice del progetto in GEOSIM.INI
   gsc_setLastUsedPrj(Prj);

   return result;
}


/*********************************************************/
/*  FINE   FUNZIONI DELLA CATEGORIA C_SIMPLEX            */
/*  INIZIO FUNZIONI DELLA CATEGORIA C_GROUP              */
/*********************************************************/


C_GROUP::C_GROUP() : C_CLASS()
{
   id.category = CAT_GROUP;
   ptr_secondary_list = new C_SECONDARY_LIST(this);
}
C_GROUP::~C_GROUP() {}


int C_GROUP::copy(C_CLASS *out)
{
   if (!out) { GS_ERR_COD = eGSNotAllocVar; return GS_BAD; }
   id.copy(out->ptr_id());
   info.copy(out->ptr_info());
   attrib_list.copy(out->ptr_attrib_list());
   group_list.copy(out->ptr_group_list());

   return GS_GOOD;
}
//-----------------------------------------------------------------------//
int C_GROUP::load_info(TCHAR *filename)
{
   TCHAR sez[SEZ_PROFILE_LEN]; 

   swprintf(sez, SEZ_PROFILE_LEN, _T("%d.0"), id.code);
   
   return info.load(filename,sez);
}
//-----------------------------------------------------------------------//
int C_GROUP::load_group_list(TCHAR *filename)
{
   TCHAR sez[SEZ_PROFILE_LEN]; 

   swprintf(sez, SEZ_PROFILE_LEN, _T("%d.0"), id.code);
   return group_list.load(filename, sez);
}
//-----------------------------------------------------------------------//
int C_GROUP::ToFile(C_STRING &filename)
{
   C_PROFILE_SECTION_BTREE ProfileSections;
   bool                    Unicode = false;

   if (gsc_path_exist(filename) == GS_GOOD)
      if (gsc_read_profile(filename, ProfileSections, &Unicode) == GS_BAD) return GS_BAD;

   if (ToFile(ProfileSections) == GS_BAD) return GS_BAD;

   return gsc_write_profile(filename, ProfileSections, Unicode);
}
int C_GROUP::ToFile(C_PROFILE_SECTION_BTREE &ProfileSections)
{
   TCHAR sez[SEZ_PROFILE_LEN];

   swprintf(sez, SEZ_PROFILE_LEN, _T("%d.0"), id.code);
   if (id.ToFile(ProfileSections, sez) == GS_BAD )           return GS_BAD;
   if (info.ToFile(ProfileSections, sez) == GS_BAD )         return GS_BAD;
   if (group_list.ToFile(ProfileSections, sez) == GS_BAD ) return GS_BAD;
   wcscat(sez, ATTRIB_PROFILE);
   if (attrib_list.ToFile(ProfileSections, sez) == GS_BAD)   return GS_BAD;

   return GS_GOOD;
}
//-----------------------------------------------------------------------//
int C_GROUP::load(TCHAR *filename, int cl)
{
   C_PROFILE_SECTION_BTREE ProfileSections;

   if (gsc_read_profile(filename, ProfileSections) == GS_BAD) return GS_BAD;
   return load(ProfileSections, cl);
}
int C_GROUP::load(C_PROFILE_SECTION_BTREE &ProfileSections, int cl)
{
   TCHAR sez[SEZ_PROFILE_LEN];
   int   Result;

   swprintf(sez, SEZ_PROFILE_LEN, _T("%d.0"), cl);
   if ((Result = id.load(ProfileSections, sez)) != GS_GOOD) return Result;
   if (info.load(ProfileSections, sez) != GS_GOOD)          return GS_BAD;
   if (group_list.load(ProfileSections, sez) != GS_GOOD)    return GS_BAD;
   wcscat(sez, ATTRIB_PROFILE);

   return attrib_list.load(ProfileSections, sez, ptr_info()->getDBConnection(OLD));
}


/*********************************************************/
/*.doc C_GROUP::to_rb                       <external> */
/*+
  Questa funzione scrive la definizione di una classe C_GROUP 
  in formato resbuf.
  (<C_ID><C_INFO><C_GROUP_LIST><C_ATTRIB_LIST>) 
  Parametri:
  presbuf rb;     lista descrizione classe
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
resbuf *C_GROUP::to_rb(void)             
{
   C_RB_LIST List;

   if ((List << acutBuildList(RTLB, 0)) == NULL) return NULL;
   // C_ID
   if ((List += id.to_rb()) == NULL) return NULL;
   if ((List += acutBuildList(RTLE, RTLB, 0)) == NULL) return NULL;
   // C_INFO
   if ((List += info.to_rb()) == NULL) return NULL;
   if ((List += acutBuildList(RTLE, RTLB, 0)) == NULL) return NULL;
   // C_GROUP_LIST
   if ((List += group_list.to_rb()) == NULL) return NULL;
   if ((List += acutBuildList(RTLE, RTLB, 0)) == NULL) return NULL;
   // C_ATTRIB_LIST
   if ((List += attrib_list.to_rb()) == NULL) return NULL;
   if ((List += acutBuildList(RTLE, 0)) == NULL) return NULL;

   List.ReleaseAllAtDistruction(GS_BAD);

   return List.get_head();
}


/*********************************************************/
/*.doc from_rb <internal> */
/*+
  Questa funzione carica i dati di una classe C_GROUP da un resbuf.
  Parametri:
  presbuf rb;     lista descrizione classe
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_GROUP::from_rb(resbuf *rb)
{  
   presbuf pGroup;
   
   if (id.from_rb(gsc_nth(0,rb))==GS_BAD)   return GS_BAD;
   if (info.from_rb(gsc_nth(1,rb))==GS_BAD) return GS_BAD;
   if ((pGroup = gsc_nth(2,rb)) == NULL) return GS_BAD;
   if (group_list.from_rb(pGroup)==GS_BAD) return GS_BAD;
   if (attrib_list.from_rb(gsc_nth(3,rb))==GS_BAD) return GS_BAD;

   return GS_GOOD;
}


/*********************************************************/
/*.doc from_db <internal> */
/*+
  Questa funzione carica la definizione di una classe GROUP dai database.
  Parametri:
  C_RB_LIST &ColValues;                lista colonna-valore della riga di GS_CLASS
  GSDataPermissionTypeEnum cod_level;  livello di abilitazione per la classe
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_GROUP::from_db(C_RB_LIST &ColValues, GSDataPermissionTypeEnum cod_level)
{  
   // C_ID
   if (id.from_rb_db(ColValues, cod_level) == GS_BAD) return GS_BAD;
   // INFO
   if (info.from_rb_db(ColValues) == GS_BAD) return GS_BAD;
   // GROUP LIST
   if (restore_GroupList() == GS_BAD) return GS_BAD; 
   // ATTRIBUTE LIST
   if (restore_attriblist() == GS_BAD) return GS_BAD;
   
   return GS_GOOD;
}   


/*********************************************************/
/*.doc C_GROUP::create_tab_link <external> */
/*+
  Questa funzione crea la tabella dei link per i gruppi.

  Restituisce GS_GOOD in caso di successo altrimenti re;

  N.B.:Da usare dopo che e' gia' stata creata la tabella delle entita'.
-*/  
/*********************************************************/
int C_GROUP::create_tab_link()
{  
   C_STRING LinkTableRef;

   // verifico abilitazione
   if (gsc_check_op(opCreateClass) == GS_BAD) return GS_BAD;
   // ricavo nome della link table
   if (getOldLnkTableRef(LinkTableRef) == GS_BAD) return GS_BAD;

   if (gsc_crea_grp_tablink(info.getDBConnection(OLD), LinkTableRef) == GS_BAD) return GS_BAD;
   
   return reindexTab();
}    


/*********************************************************/
/*.doc C_GROUP::del_tab_link <internal> */
/*+
  Questa funzione cancella la tabella dei link della classe.
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/  
/*********************************************************/
int C_GROUP::del_tab_link()
{
   return gsc_del_grp_tab_link(info.getDBConnection(OLD), info.OldTableRef);
}
                           
  
/*********************************************************/
/*.doc create <internal> */
/*+
  Questa funzione crea una classe C_GROUP nei database.
    
  Restituisce codice classe in caso di successo altrimenti restituisce 0.
-*/  
/*********************************************************/
int C_GROUP::create(void)
{
   presbuf        p;
   C_RB_LIST      Group;
   int            new_code, error_code, result = GS_BAD;
   C_DBCONNECTION *pConn;

   // verifico abilitazione
   if (gsc_check_op(opCreateClass) == GS_BAD) return 0;

   // La tabella collegata non è ammessa per questo tipo di classe
   if (info.LinkedTable) { GS_ERR_COD = eGSOpNotAble; return 0; }

   acutPrintf(_T("%s <%s>..."), gsc_msg(346), id.name); // "\nCreazione classe"

   // Inizializzazioni
   id.code   = 0;
   id.type   = TYPE_GROUP;
   id.abilit = GSUpdateableData;
   id.sel    = DESELECTED;
   info.pOldTabConn = NULL;
   info.OldLnkTableRef.clear();

   // carico eventuali funzioni di calcolo in GSL.GSL del progetto della classe
   gsc_load_gsl(get_pPrj()->get_dir());

   // verifico id
   if (is_validid() == GS_BAD) { gs_gsl_reload(); return 0; }
   // verifico info
   if (is_validinfo() == GS_BAD) { gs_gsl_reload(); return 0; }
   // verifico Group list
   if (group_list.is_valid(get_pPrj()) == GS_BAD) { gs_gsl_reload(); return 0; }
   // ricavo connessione OLE-DB
   if ((pConn = info.getDBConnection(OLD)) == NULL) { gs_gsl_reload(); return 0; }
   // verifico attrib list
   if (attrib_list.is_valid(pConn) == GS_BAD) { gs_gsl_reload(); return 0; }
   if (attrib_list.is_valid(id.category, id.type, pConn, info.key_attrib) == GS_BAD)
      { gs_gsl_reload(); return 0; }

	// ricarico GSL.GSL giusto
	gs_gsl_reload();
   
   if ((Group << acutBuildList(RTLB, 0)) == NULL) return 0;

   // C_ID
   if (id.to_rb_db(&p) == GS_BAD) return 0;
   Group += p;

   // C_INFO converto i percorsi da relativi in assoluti per scrivere in DB
   info.OldLastId = info.TempLastId = 0;
   if ((p = info.to_rb(true, true)) == NULL) return 0;
   Group += p;

   if ((Group += acutBuildList(RTLE, 0)) == NULL) return 0;

   do
   {
      // inserisco nuova classe in GS_CLASS
      if ((new_code = ins_cls_to_gs_class(Group)) == GS_BAD) break;

      // creo directory della tabella, creo tabella e indice 
      if (create_tab() == GS_BAD) break;

      // creo tabella di link e indice 
      if (create_tab_link() == GS_BAD) break;

      // scarico valori di default in tabella
      if (default_to_db(&attrib_list) == GS_BAD) break;
   
      // scarico su tabella GS_ATTR le caratteristiche degli attributi
      if (carattattr_to_db(&attrib_list) == GS_BAD) break;

      // scarico la Group list
      if (to_db_relcompl() == GS_BAD) break;

      result = GS_GOOD;
   }
   while (0);

   if (result == GS_BAD)
   {
      error_code = GS_ERR_COD;
      del((TCHAR *) GEOsimAppl::GS_USER.pwd);
      GS_ERR_COD = error_code;
      return 0;
   }

   // creazione collegamento progetto -> classe
   if (get_pPrj()->ptr_classlist()->add_tail(this) == GS_BAD) return 0;
   // aggiorno il codice progressivo per la creazione di classi del progetto
   get_pPrj()->setNextClassId(id.code + 1);

   // memorizzo il codice del progetto in GEOSIM.INI
   gsc_setLastUsedPrj(get_PrjId());

   return new_code;
}
                           
  
/*********************************************************/
/*.doc del <internal> */
/*+
  Questa funzione cancella una classe C_GROUP nei database.
  Parametri:
  const TCHAR *Password;    Password dell'utente corrente (per controllo)
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_GROUP::del(const TCHAR *Password)
{
   C_DBCONNECTION    *pConn;
   C_BIRELATION_LIST gscompl_list;
   C_BIRELATION      *gscompl;
   int               result;
   C_STRING          statement, ClassesTableRef;

   // verifico abilitazione
   if (gsc_check_op(opDelClass) == GS_BAD) return GS_BAD;
   if (ptr_id()->abilit != GSUpdateableData)
      { GS_ERR_COD = eGSClassLocked; return GS_BAD; }
   // verifico che la password sia corretta
   if (gsc_strcmp(Password, (TCHAR *) GEOsimAppl::GS_USER.pwd) != 0)
      { GS_ERR_COD = eGSInvalidPwd; return GS_BAD; }

   // verifico se la classe che si sta cancellando è figlia di altre
   if (get_pPrj()->get_group_list(&gscompl_list) == GS_BAD ) return GS_BAD;

   // per ogni gruppo verifico che non ci sia questa classe come figlia
   gscompl = (C_BIRELATION *) gscompl_list.get_head();
   while (gscompl != NULL)
   {
      if ((gscompl->relation).search_key(id.code) != NULL)
         { GS_ERR_COD = eGSNotDel; return GS_BAD; }
      gscompl = (C_BIRELATION *) gscompl_list.get_next();
   }

   // blocco la classe in modo esclusivo GS_CLASS usando come semaforo
   // il codice della sessione attiva, se esistente, altrimenti il codice utente 
   long OwnerCode = (GS_CURRENT_WRK_SESSION) ? GS_CURRENT_WRK_SESSION->get_id() : GEOsimAppl::GS_USER.code * -1;
   if (set_exclusive_use(OwnerCode, &result) == GS_BAD || result == GS_BAD)
      return GS_BAD;

   // verifico se la classe fa parte di una sessione di lavoro
   long WrkSessionId;
   if (gsc_is_inarea(get_PrjId(), id.code, &WrkSessionId) == GS_BAD || WrkSessionId > 0)
      { GS_ERR_COD = eGSSessionsFound; return GS_BAD; }

   acutPrintf(_T("%s %s..."), gsc_msg(356), id.name); // "\nCancellazione classe"

   // cancello tabelle secondarie
   del_all_tab_sec(Password);
   
   // cancello tabelle della classe
   del_tab_class();
   // cancello tabella di link e indice 
   del_tab_link();
   
   // cancello abilitazioni alla classe per tutti gli utenti 
   gsc_delClassPermissions(get_PrjId(), id.code);
   
   // cancello caratteristiche attributi
   del_db_carattattr();

   // Cancello la classe dal set di classi del progetto
   del_db_ClassSet();

   // cancello relazioni con altre classi
   del_db_GroupRel();

   // ricavo connessione OLE-DB
   if ((pConn = ptr_info()->getDBConnection(OLD)) &&
       pConn->get_CatalogResourceType() == DirectoryRes)
   {
      C_STRING Catalog, Schema, Table, Path;

      if (pConn->split_FullRefTable(ptr_info()->OldTableRef, Catalog,
                                    Schema, Table) == GS_GOOD &&
          gsc_RefTable2Path(pConn->get_DBMSName(), Catalog, Schema, Table, Path) == GS_GOOD)
         // Cancello direttorio
         gsc_rmdir_from_path(Path.get_name());
   }

   if (get_pPrj()->getClassesTabInfo(&pConn, &ClassesTableRef) == GS_BAD)
      { set_share_use(); return GS_BAD; }
   // cancello la riga in GS_CLASS
   statement = _T("DELETE FROM ");
   statement += ClassesTableRef;
   statement += _T(" WHERE GS_ID=");
   statement += id.code;
   if (pConn->ExeCmd(statement) == GS_BAD) return GS_BAD;

   // Cancellazione files di supporto
   DelSupportFiles();

   // cancellazione collegamento progetto -> classe
   return get_pPrj()->ptr_classlist()->remove(this);
}   
   

/*********************************************************/
/*.doc restore_GroupList <internal> */
/*+
  Questa funzione carica la lista delle relazioni della classe dai database.
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
  N.B.: Prima di utilizzare questa funzione deve essere caricata la C_ID
-*/  
/*********************************************************/
int C_GROUP::restore_GroupList(void)
{  
   int            cod_class, quante;
   C_STRING       statement, TableRef;
   C_DBCONNECTION *pConn;
   _RecordsetPtr  pRs;
   presbuf        pClId, pQty;
   C_RB_LIST      ColValues;
   C_INT_INT      *pGroup;
   
   if (group_list.is_empty() == FALSE)
      if (group_list.remove_all() == GS_BAD) return GS_BAD;

   // setto il riferimento di GS_GROUP (<catalogo>.<schema>.<tabella>)
   if (get_pPrj()->getGrpsTabInfo(&pConn, &TableRef) == GS_BAD)
      return GS_BAD;

   statement = _T("SELECT LNK_CL_ID, QTY FROM ");
   statement += TableRef;
   statement += _T(" WHERE CLASS_ID=");
   statement += id.code;

   // leggo le righe della tabella senza bloccarla
   if (pConn->ExeCmd(statement, pRs) == GS_BAD) return GS_BAD;
   if (gsc_InitDBReadRow(pRs, ColValues) == GS_BAD)
      { gsc_DBCloseRs(pRs); return GS_BAD; }
   
   pClId = ColValues.CdrAssoc(_T("LNK_CL_ID"));
   pQty  = ColValues.CdrAssoc(_T("QTY"));

   // scorro l'elenco dei collegamenti
   while (gsc_isEOF(pRs) == GS_BAD)
   {
      if (gsc_DBReadRow(pRs, ColValues) == GS_BAD) { gsc_DBCloseRs(pRs); return GS_BAD; }
         
      // codice della classe collegata 
      if (gsc_rb2Int(pClId, &cod_class) == GS_BAD) { gsc_DBCloseRs(pRs); return GS_BAD; }
      // quante entità    
      if (gsc_rb2Int(pQty, &quante) == GS_BAD) { gsc_DBCloseRs(pRs); return GS_BAD; }
    
      if ((pGroup = new C_INT_INT) == NULL)
          { GS_ERR_COD = eGSOutOfMem; gsc_DBCloseRs(pRs); return GS_BAD; }
      pGroup->set_key(cod_class);
      pGroup->set_type(quante);
      group_list.add_tail((C_NODE *) pGroup); // inserimento in lista

      gsc_Skip(pRs);
   }
   
   return gsc_DBCloseRs(pRs);
}


/*********************************************************/
/*.doc del_db_GroupRel <internal> */
/*+
  Questa funzione cancella la lista delle relazioni della classe nei database.
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/  
/*********************************************************/
int C_GROUP::del_db_GroupRel(void)
{
   return gsc_del_db_grp_rel(get_pPrj(), id.code);
}   
   

/*********************************************************/
/*.doc to_db_relcompl <internal> */
/*+
  Questa funzione scarica la lista delle relazioni della classe nei database.
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/  
/*********************************************************/
int C_GROUP::to_db_relcompl(void)
{                                                   
   C_STRING       TableRef;
   C_RB_LIST      ColValues;
   presbuf        pRbLnkClId, pRbQty;
   C_INT_INT      *pGroup;
   C_DBCONNECTION *pConn;
   
   // setto il riferimento di GS_GROUP (<catalogo>.<schema>.<tabella>)
   if (get_pPrj()->getGrpsTabInfo(&pConn, &TableRef) == GS_BAD)
      return GS_BAD;
      
   if ((ColValues << acutBuildList(RTLB,
                                   RTLB, RTSTR, _T("CLASS_ID"), RTSHORT, id.code, RTLE,
                                   RTLB, RTSTR, _T("LNK_CL_ID"), RTSHORT, 0, RTLE,
                                   RTLB, RTSTR, _T("QTY"), RTSHORT, 0, RTLE,
                                   RTLE, 0)) == NULL)
      return GS_BAD;
   pRbLnkClId = ColValues.CdrAssoc(_T("LNK_CL_ID"));
   pRbQty     = ColValues.CdrAssoc(_T("QTY"));
           
   // scorro l'elenco dei collegamenti
   pGroup = (C_INT_INT *) group_list.get_head();
   while (pGroup)
   {
      if (gsc_RbSubst(pRbLnkClId, pGroup->get_key()) == GS_BAD) return GS_BAD;
      if (gsc_RbSubst(pRbQty, pGroup->get_type()) == GS_BAD) return GS_BAD;

      if (pConn->InsRow(TableRef.get_name(), ColValues) == GS_BAD) return GS_BAD;
      
      pGroup = (C_INT_INT *) group_list.get_next();
   }

   return GS_GOOD;
}                  


/*********************************************************/
/*.doc C_GROUP::reindexTab <internal> */
/*+
  Questa funzione reindicizza le tabelle della classe.
  Parametri:
  bool OnlyTemp;        Flag, se true indica che devono essere considerate solo
                        le tabelle temporanee (default = false)
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_GROUP::reindexTab(bool OnlyTemp)
{
   C_STRING       TableRef, LnkTableRef;
   int            result = GS_BAD;
   C_DBCONNECTION *pConn;
   C_STRING       Catalog, Schema, Name, IndexRef;
   TCHAR          Msg[MAX_LEN_MSG];
   
   do
   {
      if (!OnlyTemp && !info.LinkedTable) // Se si tratta di una tabella collegata non posso reindicizzare
      if (!OnlyTemp)
      {
         // ricavo connessione OLE-DB con tabelle OLD
         if ((pConn = info.getDBConnection(OLD)) == NULL) return GS_BAD;

         if (pConn->ExistTable(info.OldTableRef) == GS_GOOD)
         {
            C_STRING PrimaryKey;

            // Nome della chiave primaria
            if (info.get_PrimaryKeyName(PrimaryKey) == GS_BAD)
               break;
            // Cancello chiave primaria
            if (pConn->DelPrimaryKey(info.OldTableRef.get_name(), PrimaryKey.get_name(), 
                                     ONETEST, GS_BAD) == GS_BAD)
            { // La chiave primaria non c'era. Al suo posto c'era un indice normale.
               C_STRING Catalog, Schema, Name, IndexRef;

               // cancello l'indice per codice chiave
               if (pConn->split_FullRefTable(info.OldTableRef, Catalog, Schema, Name) == GS_BAD)
                  break;

               // Ottengo il nome completo dell'indice per la cancellazione
               if (IndexRef.paste(pConn->getNewFullRefIndex(Catalog.get_name(),
                                                            Schema.get_name(),
                                                            Name.get_name(),
                                                            info.key_attrib.get_name(),
                                                            ERASE)) == NULL)
                  break;
               // cancello indice
               pConn->DelIndex(info.OldTableRef, IndexRef);
            }

            // Creo chiave primaria
            if (pConn->CreatePrimaryKey(info.OldTableRef.get_name(), PrimaryKey.get_name(), 
                                        info.key_attrib.get_name()) == GS_BAD)
               // Se il provider non supporta la creazione di indice (vedi Excel) vado avanti comunque
               if (GS_ERR_COD != eGSExeNotSupported) break;

            // aggiorno ENT_LAST in GS_CLASS
            RefreshOldLastId();
            set_unlocked(0, GS_GOOD, true);
         }

         // ricavo tabella REL OLD
         if (getOldLnkTableRef(LnkTableRef) == GS_BAD) break;
         if (pConn->ExistTable(LnkTableRef) == GS_GOOD)
         {
            // Per la tabella REL OLD cancello e ricreo gli indici
            if (pConn->split_FullRefTable(LnkTableRef, Catalog, Schema, Name) == GS_BAD)
               break;

            // Ottengo il nome completo dell'indice per la cancellazione
            if (IndexRef.paste(pConn->getNewFullRefIndex(Catalog.get_name(),
                                                         Schema.get_name(),
                                                         Name.get_name(),
                                                         _T("CLASS_ID, ENT_ID"),
                                                         ERASE)) == NULL)
               break;
            // cancello indice
            pConn->DelIndex(LnkTableRef, IndexRef);
            
            // Ottengo il nome completo dell'indice per la creazione
            if (IndexRef.paste(pConn->getNewFullRefIndex(Catalog.get_name(),
                                                         Schema.get_name(),
                                                         Name.get_name(),
                                                         _T("CLASS_ID, ENT_ID"))) == NULL)
               break;
            // creo indice per CLASS_ID, ENT_ID
            if (pConn->CreateIndex(IndexRef.get_name(), LnkTableRef.get_name(),
                                   _T("CLASS_ID, ENT_ID"), INDEX_NOUNIQUE) == GS_BAD)
               break;

            Name += _T("G");
            // Ottengo il nome completo dell'indice per la cancellazione
            if (IndexRef.paste(pConn->getNewFullRefIndex(Catalog.get_name(),
                                                         Schema.get_name(),
                                                         Name.get_name(),
                                                         _T("KEY_ATTRIB"),
                                                         ERASE)) == NULL)
               break;
            // cancello indice
            pConn->DelIndex(LnkTableRef, IndexRef);

            // Ottengo il nome completo dell'indice per la creazione
            if (IndexRef.paste(pConn->getNewFullRefIndex(Catalog.get_name(),
                                                         Schema.get_name(),
                                                         Name.get_name(),
                                                         _T("KEY_ATTRIB"))) == NULL)
               break;
            // creo indice per KEY_ATTRIB
            if (pConn->CreateIndex(IndexRef.get_name(), LnkTableRef.get_name(),
                                   _T("KEY_ATTRIB"), INDEX_NOUNIQUE) == GS_BAD)
               break;
         }
      }

      // se esiste il progetto corrente ed è lo stesso di quello della classe da reindicizzare
      // ed esiste una sessione di lavoro corrente attiva
      if (GS_CURRENT_WRK_SESSION &&
          (GS_CURRENT_WRK_SESSION->get_status() == WRK_SESSION_ACTIVE || GS_CURRENT_WRK_SESSION->get_status() == WRK_SESSION_SAVE) &&
          GS_CURRENT_WRK_SESSION->get_PrjId() == get_PrjId())
      { // sono in una sessione di lavoro
         // ricavo connessione OLE-DB per tabella TEMP
         if ((pConn = info.getDBConnection(TEMP)) == NULL) break;

         if (getTempTableRef(TableRef, GS_BAD) == GS_BAD) break; // senza creare la tabella

         if (pConn->ExistTable(TableRef) == GS_GOOD)
         {
            // Per la tabella temp cancello e ricreo l'indice per codice chiave
            if (pConn->split_FullRefTable(TableRef, Catalog, Schema, Name) == GS_BAD)
               break;
         
            // Ottengo il nome completo dell'indice per la cancellazione
            if (IndexRef.paste(pConn->getNewFullRefIndex(Catalog.get_name(),
                                                         Schema.get_name(),
                                                         Name.get_name(),
                                                         info.key_attrib.get_name(),
                                                         ERASE)) == NULL)
               break;
            // cancello indice
            pConn->DelIndex(TableRef, IndexRef);

            // Ottengo il nome completo dell'indice per la creazione
            if (IndexRef.paste(pConn->getNewFullRefIndex(Catalog.get_name(),
                                                         Schema.get_name(),
                                                         Name.get_name(),
                                                         info.key_attrib.get_name())) == NULL)
               break;
            // creo indice per GS_ID
            if (pConn->CreateIndex(IndexRef.get_name(), TableRef.get_name(),
                                   info.key_attrib.get_name(), INDEX_UNIQUE) == GS_BAD)
               // Se il provider non supporta la creazione di indice (vedi Excel) vado avanti comunque
               if (GS_ERR_COD != eGSExeNotSupported) break;
         }

         // ricavo tabella REL TEMP
         if (getTempLnkTableRef(LnkTableRef) == GS_BAD) break;
         
         if (pConn->ExistTable(LnkTableRef) == GS_GOOD)
         {
            // per la tabella REL TEMP cancello e ricreo gli indici
            if (pConn->split_FullRefTable(LnkTableRef, Catalog, Schema, Name) == GS_BAD)
               break;

            // Ottengo il nome completo dell'indice per la cancellazione
            if (IndexRef.paste(pConn->getNewFullRefIndex(Catalog.get_name(),
                                                         Schema.get_name(),
                                                         Name.get_name(),
                                                         _T("CLASS_ID, ENT_ID"),
                                                         ERASE)) == NULL)
               break;
            // cancello indice
            pConn->DelIndex(LnkTableRef, IndexRef);

            // Ottengo il nome completo dell'indice per la creazione
            if (IndexRef.paste(pConn->getNewFullRefIndex(Catalog.get_name(),
                                                         Schema.get_name(),
                                                         Name.get_name(),
                                                         _T("CLASS_ID, ENT_ID"))) == NULL)
               break;
            // creo indice per CLASS_ID, ENT_ID
            if (pConn->CreateIndex(IndexRef.get_name(), LnkTableRef.get_name(),
                                   _T("CLASS_ID, ENT_ID"), INDEX_NOUNIQUE) == GS_BAD)
               break;

            Name += _T("G");
            // Ottengo il nome completo dell'indice per la cancellazione
            if (IndexRef.paste(pConn->getNewFullRefIndex(Catalog.get_name(),
                                                         Schema.get_name(),
                                                         Name.get_name(),
                                                         _T("KEY_ATTRIB"),
                                                         ERASE)) == NULL)
               break;
            // cancello indice
            pConn->DelIndex(LnkTableRef, IndexRef);

            // Ottengo il nome completo dell'indice per la creazione
            if (IndexRef.paste(pConn->getNewFullRefIndex(Catalog.get_name(),
                                                         Schema.get_name(),
                                                         Name.get_name(),
                                                         _T("KEY_ATTRIB"))) == NULL)
               break;
            // creo indice per KEY_ATTRIB
            if (pConn->CreateIndex(IndexRef.get_name(), LnkTableRef.get_name(),
                                   _T("KEY_ATTRIB"), INDEX_NOUNIQUE) == GS_BAD)
               break;
         }
      }
      // reindicizzo le tabelle secondarie (se fallisce devo comunque continuare)
      reindex_sec(OnlyTemp);

      result = GS_GOOD;
   }
   while (0);

   // Scrivo messaggio nel file log
   if (result == GS_GOOD)
      swprintf(Msg, MAX_LEN_MSG, _T("Database reindex on class %d terminated."), id.code);  
   else
      swprintf(Msg, MAX_LEN_MSG, _T("Database reindex on class %d failed."), id.code);  

   gsc_write_log(Msg);

   return result;
}


/****************************************************************************/
/*.doc C_GROUP::reportHTML                                         <external> */
/*+
  Questa funzione stampa su un file HTML i dati della C_GROUP.
  Parametri:
  FILE *file;        Puntatore a file
  const TCHAR *Path; Path del file HTML in cui si sta scrivendo. Server unicamente
                     per poter scrivere le bitmap dei blocchi nello stesso direttorio
                     del file HTML (default = NULL). Usato solo per compatibilità.
  bool SynthMode;    Opzionale. Flag di modalità di report.
                     Se = true attiva il report sintetico (default = false)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/
/******************************************************************************/
int C_GROUP::reportHTML(FILE *file, const TCHAR *Path, bool SynthMode)
{  
   if (id.reportHTML(file, SynthMode) == GS_BAD)   return GS_BAD;
   if (info.reportHTML(file, SynthMode) == GS_BAD) return GS_BAD;
   if (attrib_list.reportHTML(file, id.pPrj->get_key(), id.code, id.sub_code, 0,
                              SynthMode) == GS_BAD) return GS_BAD;
   if (group_list.reportHTML(file, id.pPrj, SynthMode)==GS_BAD) return GS_BAD;

   C_SINTH_SEC_TAB_LIST SinthSecList;
   C_SINTH_SEC_TAB      *pSinthSec;
   C_SECONDARY          *pSecondary;
   
   // leggo la lista delle tabelle secondarie
   if (get_pPrj()->getSinthClsSecondaryTabList(id.code, id.sub_code, SinthSecList) == GS_BAD) return GS_BAD;

   pSinthSec = (C_SINTH_SEC_TAB *) SinthSecList.get_head();
   while (pSinthSec)
   {
      if ((pSecondary = (C_SECONDARY *) find_sec(pSinthSec->get_key())) == NULL) return GS_BAD;
      if (pSecondary->reportHTML(file, SynthMode) == GS_BAD) return GS_BAD;

      pSinthSec = (C_SINTH_SEC_TAB *) SinthSecList.get_next();
   }

   return GS_GOOD;
}


/****************************************************************************/
/*.doc C_GROUP::synchronize                                     <external> */
/*+
  Questa funzione sincronizza i database.
  Parametri:
  const TCHAR *DeletedObjsDWG; Usato per compatibilità
  TCHAR *NextCmd;              Stringa che identifica una eventuale chiamata 
                               ad un comando da lanciare a fine sessione 
                               (dopo il comando di "NEW"), default = NULL.
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/
/******************************************************************************/
int C_GROUP::synchronize(const TCHAR *DeletedObjsDWG, TCHAR *NextCmd)
{
   C_WRK_SESSION       WrkSession(get_pPrj());
   C_INT_LIST          cls_list_2_extract;
   C_INT               *pcls_2_extract;
   C_PREPARED_CMD_LIST PreparedCmdList;
   C_PREPARED_CMD      *pPreparedCmd, pCmd, pDelLnkCmd;
   C_INT_INT           *pMemberClsCode;
   C_DBCONNECTION      *pConn;
   _RecordsetPtr       pRs, pMemberRs;
   C_RB_LIST           ColValues, LnkColValues;
   C_STRING            session_dir, FldName, statement;
   int                 MemberCls, i, ToErase, result = GS_BAD;
   int                 IsRecordsetCloseable, Prj = get_PrjId();
   long                Key, MemberKey, qty = 0;
   presbuf             p, pKey;
   TCHAR               Msg[MAX_LEN_MSG];
   C_CLASS             *pMemberCls;
   C_STATUSLINE_MESSAGE StatusLineMsg(gsc_msg(1085), id.name); // "Sincronizzazione classe <%s>"

   // verifico abilitazione
   if (gsc_check_op(opSynchronizeClass) == GS_BAD) return GS_BAD;

   // Se si tratta di una tabella collegata non posso sincronizzare la classe
   if (info.LinkedTable) { GS_ERR_COD = eGSClassLocked; return GS_BAD; }

   swprintf(Msg, MAX_LEN_MSG, _T("Synchronization class %d started."), id.code);  
   gsc_write_log(Msg);

   do
   {
      session_dir = _T("GEOSIM_SYNCHRONIZE_CLS");
      session_dir += id.code;
      if (WrkSession.set_name(session_dir.get_name()) == GS_BAD) break;

      session_dir = get_pPrj()->get_dir();
      session_dir += _T("\\GSSYNCHRONIZE_CLS");
      session_dir += id.code;
      if (WrkSession.set_dir(session_dir.get_name()) == GS_BAD) break;
      WrkSession.set_level(GSUpdateableData);
   
      // Alloca un oggetto C_INT per la classe gruppo
      if ((pcls_2_extract = new C_INT(id.code)) == NULL)
         { GS_ERR_COD = eGSOutOfMem; break; }
      cls_list_2_extract.add_tail(pcls_2_extract);

      result = GS_GOOD;
      pMemberClsCode = (C_INT_INT *) ptr_group_list()->get_head();
      while (pMemberClsCode)
      {
         // Alloca un oggetto C_INT per la classe membro
         if ((pcls_2_extract = new C_INT(pMemberClsCode->get_key())) == NULL)
            { GS_ERR_COD = eGSOutOfMem; break; }
         cls_list_2_extract.add_tail(pcls_2_extract);

         pMemberClsCode = (C_INT_INT *) pMemberClsCode->get_next();
      }
      if (result == GS_BAD) break;
      result = GS_BAD;

      // seleziono classe da estrarre, ed eseguo estrazione
      // effettuo estrazione rendendo la classe in sola lettura alle altre sessioni
      if (gsc_extract_classes((C_PROJECT *) id.pPrj, WrkSession, cls_list_2_extract, TRUE) == GS_BAD) break;

      // se la classe è stata in modifica
      // (perchè bloccata da un'altra sessione di lavoro)
      if (id.abilit != GSUpdateableData) { GS_ERR_COD = eGSClassLocked; break; }

      // preparo comando per ricercare le relazioni
      if (prepare_reldata_where_key(pCmd, OLD) == GS_BAD) break;

      // preparo comando per la cancellazione delle relazioni
      if (prepare_del_reldata_from_old_where_key(pDelLnkCmd) == GS_BAD) break;

      // preparo lista di comandi per la ricerca delle entità semplici membri del gruppo
      result = GS_GOOD;
      pMemberClsCode = (C_INT_INT *) ptr_group_list()->get_head();
      while (pMemberClsCode)
      {
         if ((pPreparedCmd = new C_PREPARED_CMD()) == NULL)
            { GS_ERR_COD = eGSOutOfMem; result = GS_BAD; break; }
         pMemberCls = (C_CLASS *) get_pPrj()->find_class(pMemberClsCode->get_key());
         if (pMemberCls->prepare_data(*pPreparedCmd, OLD) == GS_BAD)
            { result = GS_BAD; break; }
         pPreparedCmd->set_key(pMemberClsCode->get_key()), // codice classe membro
         PreparedCmdList.add_tail(pPreparedCmd);

         pMemberClsCode = (C_INT_INT *) pMemberClsCode->get_next();
      }
      if (result == GS_BAD) break;
      result = GS_BAD;

      // sincronizzazione database
      if ((pConn = info.getDBConnection(OLD)) == NULL) break;

      FldName = info.key_attrib;
      if (gsc_AdjSyntax(FldName, pConn->get_InitQuotedIdentifier(),
                        pConn->get_FinalQuotedIdentifier(),
                        pConn->get_StrCaseFullTableRef()) == GS_BAD)
         break;

      statement = _T("SELECT ");
      statement += FldName;
      statement += _T(" FROM ");
      statement += info.OldTableRef;
      statement += _T(" WHERE ");
      statement += FldName;
      statement += _T("<>0 OR ");
      statement += FldName;
      statement += _T(" IS NULL");

      // creo record-set
      // prima era adOpenKeyset poi adOpenDynamic ma PostgreSQL
      // in una transazione fa casino (al secondo recordset che viene aperto)
      if (pConn->OpenRecSet(statement, pRs, adOpenForwardOnly, adLockOptimistic) == GS_BAD)
         break;
      if (gsc_InitDBReadRow(pRs, ColValues) == GS_BAD)
         { gsc_DBCloseRs(pRs); break; }
      pKey = ColValues.CdrAssoc(info.key_attrib.get_name());

      StatusLineMsg.Init(gsc_msg(310), MEDIUM_STEP); // ogni 100 "%ld entità GEOsim elaborate."

      while (gsc_isEOF(pRs) == GS_BAD)
      {
         // leggo codice chiave entità gruppo
         gsc_DBReadRow(pRs, ColValues);
         if (gsc_rb2Lng(pKey, &Key) == GS_BAD)
         { 
            gsc_DBDelRow(pRs);
            gsc_Skip(pRs);
         
            continue;
         }

         // per ogni record ricavo le relazioni
         if (gsc_get_reldata(pCmd, Key, LnkColValues) == GS_BAD)
         { 
            // Segnalo l'errore su file .LOG e a video
            swprintf(Msg, MAX_LEN_MSG, _T("Lost link on entity: key %ld, prj %d, class %d."),
                     Key, get_PrjId(), id.code);
            gsc_write_log(Msg);
            acutPrintf(gsc_msg(71), Key); // "\nCollegamento non più valido per l'entità: %ld.\n"

            gsc_DBDelRow(pRs);
            gsc_Skip(pRs);

            // Cancello relazioni
            gsc_SetDBParam(pDelLnkCmd.pCmd, 0, Key);
            gsc_ExeCmd(pDelLnkCmd.pCmd);
         
            continue;
         }


         ToErase = FALSE;
         // ciclo sulle relazioni
         i = 0;
         while ((p = LnkColValues.nth(i++)) != NULL)
         {
            if (gsc_rb2Int((p = p->rbnext->rbnext), &MemberCls) == GS_BAD) MemberCls = 0; // CLASS_ID (2° ELEMENTO)
	         if (gsc_rb2Lng((p = p->rbnext), &MemberKey) == GS_BAD) MemberKey = 0;         // ENT_ID   (3° ELEMENTO)

            // cerco istruzione precompilata
            if ((pPreparedCmd = (C_PREPARED_CMD *) PreparedCmdList.search_key(MemberCls)) == NULL)
               { ToErase = TRUE; break; }
      
            // verifico che la scheda della semplice membro esista ancora
            if (gsc_get_data(*pPreparedCmd, MemberKey, pMemberRs, &IsRecordsetCloseable) == GS_BAD)
            {
               C_INT_INT *p = (C_INT_INT *) ptr_group_list()->search_key(MemberCls);
               // se il gruppo ammette un numero variabile di oggetti di questa classe
               if (p->get_type() <= 0)
               {
                  // cancello solo questa relazione
                  statement = _T("DELETE FROM ");
                  statement += info.OldLnkTableRef;
                  statement += _T(" WHERE KEY_ATTRIB=");
                  statement += Key;
                  statement += _T(" AND CLASS_ID=");
                  statement += MemberCls;
                  statement += _T(" AND ENT_ID=");
                  statement += MemberKey;
                  pConn->ExeCmd(statement);
                  // Segnalo l'errore su file .LOG e a video
                  swprintf(Msg, MAX_LEN_MSG, _T("Lost link on entity: key %ld, prj %d, class %d."),
                           Key, Prj, id.code);
                  gsc_write_log(Msg);
                  acutPrintf(gsc_msg(71), Key); // "\nCollegamento non più valido per l'entità: %ld.\n"
               }
               else // cancello il gruppo che non è più valido
               {
                  ToErase = TRUE;
                  break;
               }
            }
            if (IsRecordsetCloseable == GS_GOOD) gsc_DBCloseRs(pMemberRs);
         }
      
         if (ToErase)
         {
            // Segnalo l'errore su file .LOG e a video
            swprintf(Msg, MAX_LEN_MSG, _T("Lost link on entity: key %ld, prj %d, class %d."),
                     Key, Prj, id.code);
            gsc_write_log(Msg);
            acutPrintf(gsc_msg(71), Key); // "\nCollegamento non più valido per l'entità: %ld.\n"

            gsc_DBDelRow(pRs);

            // Cancello relazioni
            gsc_SetDBParam(pDelLnkCmd.pCmd, 0, Key);
            gsc_ExeCmd(pDelLnkCmd.pCmd);
         }

         gsc_Skip(pRs);

         StatusLineMsg.Set(++qty); // "%ld entità GEOsim elaborate."
      }
      gsc_DBCloseRs(pRs);

      // Sincronizzazione tabelle secondarie
      synchronize_sec();

      result = GS_GOOD;
   }
   while (0);
   StatusLineMsg.End(gsc_msg(310), qty); // "%ld entità GEOsim elaborate."

   swprintf(Msg, MAX_LEN_MSG, _T("Synchronization class %d terminated."), id.code);  
   gsc_write_log(Msg);

   // uscita dalla sessione di lavoro
   if (GS_CURRENT_WRK_SESSION)
   {
      // Inizializzo queste variabili prima di chiamare gsc_ExitCurrSession che 
      // toglie dalla memoria questa classe
      TCHAR Msg[256];
      int   Cls = id.code; 

      // "Messaggio GEOsim: La classe <%s> non è più in uso esclusivo."
      swprintf(Msg, 256, gsc_msg(289), id.name);

      if (gsc_ExitCurrSession(GS_BAD, NextCmd) == GS_GOOD)
      {
         gsc_NotifyWaitForSave(Prj, Cls, Msg);
         gsc_NotifyWaitForExtraction(Prj, Cls, Msg);
      }
   }

   // memorizzo il codice del progetto in GEOSIM.INI
   gsc_setLastUsedPrj(Prj);

   return result;
}


/*********************************************************/
/*  FINE   FUNZIONI DELLA CATEGORIA C_GROUP            */
/*  INIZIO FUNZIONI DELLA CATEGORIA C_CGRID              */
/*********************************************************/


C_CGRID::C_CGRID() : C_CLASS()
{
   id.category = CAT_GRID;
   ptr_secondary_list = new C_SECONDARY_LIST(this);
}
C_CGRID::~C_CGRID() {}


int C_CGRID::copy(C_CLASS *out)
{
   if (!out) { GS_ERR_COD = eGSNotAllocVar; return GS_BAD; }
   id.copy(out->ptr_id());
   info.copy(out->ptr_info());
   attrib_list.copy(out->ptr_attrib_list());
   grid.copy(out->ptr_grid());

   return GS_GOOD;
}
//-----------------------------------------------------------------------//
int C_CGRID::load_info(TCHAR *filename)
{
   TCHAR sez[SEZ_PROFILE_LEN]; 

   swprintf(sez, SEZ_PROFILE_LEN, _T("%d.0"), id.code);
   
   return info.load(filename, sez);
}
//-----------------------------------------------------------------------//
int C_CGRID::load_grid(TCHAR *filename)
{
   TCHAR sez[SEZ_PROFILE_LEN]; 

   swprintf(sez, SEZ_PROFILE_LEN, _T("%d.0"), id.code);

   return grid.load(filename,sez);
}             
//-----------------------------------------------------------------------//
int C_CGRID::ToFile(C_STRING &filename)
{
   C_PROFILE_SECTION_BTREE ProfileSections;
   bool                    Unicode = false;

   if (gsc_path_exist(filename) == GS_GOOD)
      if (gsc_read_profile(filename, ProfileSections, &Unicode) == GS_BAD) return GS_BAD;

   if (ToFile(ProfileSections) == GS_BAD) return GS_BAD;

   return gsc_write_profile(filename, ProfileSections, Unicode);
}
int C_CGRID::ToFile(C_PROFILE_SECTION_BTREE &ProfileSections)
{
   TCHAR sez[SEZ_PROFILE_LEN];

   swprintf(sez, SEZ_PROFILE_LEN, _T("%d.0"), id.code);
   if (id.ToFile(ProfileSections, sez) == GS_BAD)     return GS_BAD;
   if (info.ToFile(ProfileSections, sez) == GS_BAD)   return GS_BAD;
   if (grid.ToFile(ProfileSections, sez) == GS_BAD)   return GS_BAD;
   wcscat(sez, ATTRIB_PROFILE);
   if (attrib_list.ToFile(ProfileSections, sez) == GS_BAD ) return GS_BAD;
   
   return GS_GOOD;
}
//-----------------------------------------------------------------------//
int C_CGRID::load(TCHAR *filename, int cl)
{
   C_PROFILE_SECTION_BTREE ProfileSections;

   if (gsc_read_profile(filename, ProfileSections) == GS_BAD) return GS_BAD;
   return load(ProfileSections, cl);
}
int C_CGRID::load(C_PROFILE_SECTION_BTREE &ProfileSections, int cl)
{
   TCHAR sez[SEZ_PROFILE_LEN];
   int   Result;

   swprintf(sez, SEZ_PROFILE_LEN, _T("%d.0"), cl);
   if ((Result = id.load(ProfileSections, sez)) != GS_GOOD) return Result;
   if (info.load(ProfileSections, sez) != GS_GOOD)          return GS_BAD;
   if (grid.load(ProfileSections, sez) != GS_GOOD)          return GS_BAD;
   wcscat(sez, ATTRIB_PROFILE);

   return attrib_list.load(ProfileSections, sez, info.getDBConnection(OLD));
}


/*********************************************************/
/*.doc C_CGRID::to_rb                       <external> */
/*+
  Questa funzione scrive la definizione di una classe C_CGRID 
  in formato resbuf.
  (<C_ID><C_INFO><C_GRID><C_ATTRIB_LIST>) 
  Parametri:
  presbuf rb;     lista descrizione classe
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
resbuf *C_CGRID::to_rb(void)             
{
   C_RB_LIST List;

   if ((List << acutBuildList(RTLB, 0)) == NULL) return NULL;
   // C_ID
   if ((List += id.to_rb()) == NULL) return NULL;
   if ((List += acutBuildList(RTLE, RTLB, 0)) == NULL) return NULL;
   // C_INFO
   if ((List += info.to_rb()) == NULL) return NULL;
   if ((List += acutBuildList(RTLE, RTLB, 0)) == NULL) return NULL;
   // C_GRID
   if ((List += grid.to_rb()) == NULL) return NULL;
   if ((List += acutBuildList(RTLE, RTLB, 0)) == NULL) return NULL;
   // C_ATTRIB_LIST
   if ((List += attrib_list.to_rb()) == NULL) return NULL;
   if ((List += acutBuildList(RTLE, 0)) == NULL) return NULL;
   
   List.ReleaseAllAtDistruction(GS_BAD);

   return List.get_head();
}


/*********************************************************/
/*.doc from_rb <internal> */
/*+
  Questa funzione carica i dati di una classe C_CGRID da un resbuf.
  Parametri:
  presbuf rb;     lista descrizione classe
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_CGRID::from_rb(resbuf *rb)
{  
   presbuf pgrid;
   
   if (id.from_rb(gsc_nth(0,rb))==GS_BAD)   return GS_BAD;
   if (info.from_rb(gsc_nth(1,rb))==GS_BAD) return GS_BAD;
   if ((pgrid = gsc_nth(2,rb)) == NULL) return GS_BAD;
   if (grid.from_rb(pgrid)==GS_BAD) return GS_BAD;
   if (attrib_list.from_rb(gsc_nth(4,rb))==GS_BAD) return GS_BAD;

   return GS_GOOD;
}


/*********************************************************/
/*.doc from_db <internal> */
/*+
  Questa funzione carica la definizione di una classe C_GRID dai database.
  Parametri:
  C_RB_LIST &ColValues;                lista colonna-valore della riga di GS_CLASS
  GSDataPermissionTypeEnum cod_level;  livello di abilitazione per la classe
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_CGRID::from_db(C_RB_LIST &ColValues, GSDataPermissionTypeEnum cod_level)
{  
   // C_ID
   if (id.from_rb_db(ColValues, cod_level) == GS_BAD) return GS_BAD;

   // C_INFO
   if (info.from_rb_db(ColValues) == GS_BAD) return GS_BAD;

   // C_GRID
   if (grid.from_rb_db(ColValues) == GS_BAD) return GS_BAD;
   
   // ATTRIBUTE LIST
   if (restore_attriblist() == GS_BAD) return GS_BAD;

   return GS_GOOD;
}   
   
  
/*********************************************************/
/*.doc create <internal> */
/*+
  Questa funzione crea una classe C_CGRID nei database.
    
  Restituisce il codice della classe in caso di successo altrimenti restituisce 0.
-*/  
/*********************************************************/
int C_CGRID::create(void)
{
   C_RB_LIST      _grid;
   presbuf        p;
   int            new_code, error_code, result = GS_BAD;
   C_DBCONNECTION *pConn;

   // verifico abilitazione
   if (gsc_check_op(opCreateClass) == GS_BAD) return 0;

   // La tabella collegata non è ammessa per questo tipo di classe
   if (info.LinkedTable) { GS_ERR_COD = eGSOpNotAble; return 0; }

   acutPrintf(_T("%s <%s>..."), gsc_msg(346), id.name); // "\nCreazione classe"

   // Inizializzazioni
   id.code   = 0;
   id.type   = TYPE_GRID;
   id.abilit = GSUpdateableData;
   id.sel    = DESELECTED;
   info.pOldTabConn = NULL;

   // carico eventuali funzioni di calcolo in GSL.GSL del progetto della classe
   gsc_load_gsl(get_pPrj()->get_dir());

   // verifico id
   if (is_validid() == GS_BAD) { gs_gsl_reload(); return 0; }
   // verifico info
   if (is_validinfo() == GS_BAD) { gs_gsl_reload(); return 0; }
   // verifico grid
   if (grid.is_valid() == GS_BAD) { gs_gsl_reload(); return 0; }
   // ricavo connessione OLE-DB
   if ((pConn = ptr_info()->getDBConnection(OLD)) == NULL) { gs_gsl_reload(); return 0; }
   // verifico attrib list
   if (attrib_list.is_valid(pConn) == GS_BAD) return 0;
   if (attrib_list.is_valid(id.category, id.type, pConn, info.key_attrib,
                            ptr_fas()) == GS_BAD)
      { gs_gsl_reload(); return 0; }

	// ricarico GSL.GSL giusto
	gs_gsl_reload();
   
   if ((_grid << acutBuildList(RTLB, 0)) == NULL) return 0;
   
   // C_ID
   if (id.to_rb_db(&p) == GS_BAD) return 0;
   _grid += p;
   
   // C_INFO converto i percorsi da relativi in assoluti per scrivere in DB
   info.OldLastId = info.TempLastId = 0;
   if ((p = info.to_rb(true, true)) == NULL) return 0;
   _grid += p;
     
   // C_GRID
   if (grid.to_rb_db(&p) == GS_BAD) return 0;
   _grid += p;

   if ((_grid += acutBuildList(RTLE, 0)) == NULL) return 0;

   do
   {   
      // inserisco nuova classe in GS_CLASS
      if ((new_code = ins_cls_to_gs_class(_grid)) == GS_BAD) break;

      // creo directory della tabella, creo tabella e indice 
      if (create_tab() == GS_BAD) break;
        
      // scarico valori di default in tabella
      if (default_to_db(&attrib_list) == GS_BAD) break;

      // inserisco tutte le colonne della griglia con i valori di default
      if (init_db_grid() == GS_BAD) break;

      // scarico su tabella GS_ATTR le caratteristiche degli attributi
      if (carattattr_to_db(&attrib_list) == GS_BAD) break;

      result = GS_GOOD;
   }
   while (0);

   if (result == GS_BAD)
   {
      error_code = GS_ERR_COD;
      del((TCHAR *) GEOsimAppl::GS_USER.pwd);
      GS_ERR_COD = error_code;
      return 0;
   }

   // creazione collegamento progetto -> classe
   if (get_pPrj()->ptr_classlist()->add_tail(this) == GS_BAD) return 0;
   // aggiorno il codice progressivo per la creazione di classi del progetto
   get_pPrj()->setNextClassId(id.code + 1);

   // memorizzo il codice del progetto in GEOSIM.INI
   gsc_setLastUsedPrj(get_PrjId());

   return new_code;
}
                           
  
/*********************************************************/
/*.doc del <internal> */
/*+
  Questa funzione cancella una classe C_CGRID nei database.
  Parametri:
  const TCHAR *Password;       Password dell'utente corrente (per controllo)
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_CGRID::del(const TCHAR *Password)
{
   C_DBCONNECTION *pConn;
   C_FAMILY_LIST  family_list;
   int            result;
   C_STRING       statement, ClassesTableRef;

   // verifico abilitazione
   if (gsc_check_op(opDelClass) == GS_BAD) return GS_BAD;
   if (ptr_id()->abilit != GSUpdateableData)
      { GS_ERR_COD = eGSClassLocked; return GS_BAD; }
   // verifico che la password sia corretta
   if (gsc_strcmp(Password, (TCHAR *) GEOsimAppl::GS_USER.pwd) != 0)
      { GS_ERR_COD = eGSInvalidPwd; return GS_BAD; }

   // verifico se la classe che si sta cancellando è legata ad altre
   if (gsc_getfamily(get_pPrj(), &family_list) == GS_BAD) return GS_BAD;
   if (family_list.search_list(id.code) != NULL)
      { GS_ERR_COD = eGSMemberOfGroup; return GS_BAD; }

   // blocco la classe in modo esclusivo GS_CLASS usando come semaforo
   // il codice della sessione attiva, se esistente, altrimenti il codice utente 
   long OwnerCode = (GS_CURRENT_WRK_SESSION) ? GS_CURRENT_WRK_SESSION->get_id() : GEOsimAppl::GS_USER.code * -1;
   if (set_exclusive_use(OwnerCode, &result) == GS_BAD || result == GS_BAD)
      return GS_BAD;

   // verifico se la classe fa parte di una sessione di lavoro
   long WrkSessionId;
   if (gsc_is_inarea(get_PrjId(), id.code, &WrkSessionId) == GS_BAD || WrkSessionId > 0)
      { GS_ERR_COD = eGSSessionsFound; return GS_BAD; }

   acutPrintf(_T("%s %s..."), gsc_msg(356), id.name); // "\nCancellazione classe"

   // cancello tabelle secondarie
   del_all_tab_sec(Password);
   
   // cancello tabelle della classe
   del_tab_class();
    
   // cancello abilitazioni alla classe per tutti gli utenti 
   gsc_delClassPermissions(get_PrjId(), id.code);
   
   // cancello caratteristiche attributi
   del_db_carattattr();

   // Cancello la classe dal set di classi del progetto
   del_db_ClassSet();

   // ricavo connessione OLE-DB
   if ((pConn = ptr_info()->getDBConnection(OLD)) &&
       pConn->get_CatalogResourceType() == DirectoryRes)
   {
      C_STRING Catalog, Schema, Table, Path;

      if (pConn->split_FullRefTable(ptr_info()->OldTableRef, Catalog,
                                    Schema, Table) == GS_GOOD &&
          gsc_RefTable2Path(pConn->get_DBMSName(), Catalog, Schema, Table, Path) == GS_GOOD)
         // Cancello direttorio
         gsc_rmdir_from_path(Path.get_name());
   }

   if (get_pPrj()->getClassesTabInfo(&pConn, &ClassesTableRef) == GS_BAD)
      { set_share_use(); return GS_BAD; }
   // cancello la riga in GS_CLASS
   statement = _T("DELETE FROM ");
   statement += ClassesTableRef;
   statement += _T(" WHERE GS_ID=");
   statement += id.code;
   if (pConn->ExeCmd(statement) == GS_BAD) return GS_BAD;

   // Cancellazione files di supporto
   DelSupportFiles();

   // cancellazione collegamento progetto -> classe
   return get_pPrj()->ptr_classlist()->remove(this);
}   


/*********************************************************/
/*.doc C_CGRID::init_db_grid                  <internal> */
/*+
  Questa funzione inserisce tutte le colonne della classe nx * ny
  con i valori di default.
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/  
/*********************************************************/
int C_CGRID::init_db_grid(void)
{
   TCHAR          *statement = NULL;
   C_RB_LIST      def_val;
   presbuf        p;
   long           totale, indice = 0;
   C_ATTRIB_LIST  *p_attrib_list = ptr_attrib_list();
   int            ToCalc;
   C_INFO         *p_info;
   C_DBCONNECTION *pConn;
   _RecordsetPtr  pRs;

   if (!(p_info = ptr_info())) { GS_ERR_COD = eGSInvClassType; return GS_BAD; }

   // ricavo connessione OLE-DB
   if ((pConn = p_info->getDBConnection(OLD)) == NULL) return GS_BAD;

   // ricavo i valori di default della tabella
   if (attrib_list.get_StaticDefValues(def_val) == GS_BAD) return GS_BAD;

   // modifico GS_ID scrittura scheda default
   p = def_val.CdrAssoc(info.key_attrib.get_name());
   if (!p)
   {
      if (def_val.GetCount() > 0)
      {
         p = def_val.get_tail();
         p->restype = RTLB;
         if ((def_val += acutBuildList(RTSTR, info.key_attrib,
                                       RTLONG, 0,
                                       RTLE, RTLE, 0)) == NULL)
            return GS_BAD;
         p = gsc_nth(1, p);
      }
      else
         if ((def_val << acutBuildList(RTLB, 
                                       RTLB, RTSTR, info.key_attrib, RTLONG, 0, RTLE,
                                       RTLE, 0)) == NULL)
            return GS_BAD;
   }

   if (pConn->InitInsRow(p_info->OldTableRef.get_name(), pRs) == GS_BAD) return GS_BAD;
   
   totale = grid.nx * grid.ny;
   p->restype = RTLONG;
   // calcolato (valore o default)
   ToCalc = (p_attrib_list->is_calculated() == GS_GOOD ||
             p_attrib_list->is_DefCalculated() == GS_GOOD) ? TRUE : FALSE;

   GS_CALC_CLASS = NULL; // non calcolo i valori da grafica (vedi funzioni di calcolo)
   acutPrintf(GS_LFSTR);

   C_STATUSBAR_PROGRESSMETER StatusBarProgressMeter(gsc_msg(339)); // "Inserimento entità"
   StatusBarProgressMeter.Init(totale);

   while (++indice <= totale)
   {
      StatusBarProgressMeter.Set(indice);

      // modifico GS_ID scrittura scheda default
      p->resval.rlong = indice;
      // ricalcolo (con controllo valore dati per gli attributi calcolati),
      // controllo di tutti i valori e validazione dei dati
      if (ToCalc && 
          p_attrib_list->calc_all(def_val, INSERT) == GS_BAD ||
          p_attrib_list->CheckValues(def_val) == GS_BAD ||
          p_attrib_list->validate_all(def_val) == GS_BAD)
         { gsc_DBCloseRs(pRs); StatusBarProgressMeter.End(); return GS_BAD; }
      if (gsc_DBInsRow(pRs, def_val) == GS_BAD)
         { gsc_DBCloseRs(pRs); StatusBarProgressMeter.End(); return GS_BAD; }
   }
   gsc_DBCloseRs(pRs);
   
   StatusBarProgressMeter.End(gsc_msg(1090)); // "Terminato."
    
   return GS_GOOD;
}                         


/*********************************************************/
/*.doc C_CGRID::reindexTab <internal> */
/*+
  Questa funzione reindicizza le tabelle della classe.
  Parametri:
  bool OnlyTemp;        Flag, se true indica che devono essere considerate solo
                        le tabelle temporanee (default = false)
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_CGRID::reindexTab(bool OnlyTemp)
{
   int            result = GS_BAD;
   C_DBCONNECTION *pConn;
   TCHAR          Msg[MAX_LEN_MSG];

   do
   {
      if (!OnlyTemp && !info.LinkedTable) // Se si tratta di una tabella collegata non posso reindicizzare
      {
         // ricavo connessione OLE-DB con tabelle OLD
         if ((pConn = info.getDBConnection(OLD)) == NULL) return GS_BAD;

         if (pConn->ExistTable(info.OldTableRef) == GS_GOOD)
         {
            C_STRING PrimaryKey;

            // Nome della chiave primaria
            if (info.get_PrimaryKeyName(PrimaryKey) == GS_BAD)
               break;

            // Cancello chiave primaria
            if (pConn->DelPrimaryKey(info.OldTableRef.get_name(), PrimaryKey.get_name(), 
                                     ONETEST, GS_BAD) == GS_BAD)
            { // La chiave primaria non c'era. Al suo posto c'era un indice normale.
               C_STRING Catalog, Schema, Name, IndexRef;

               // cancello l'indice per codice chiave
               if (pConn->split_FullRefTable(info.OldTableRef, Catalog, Schema, Name) == GS_BAD)
                  break;

               // Ottengo il nome completo dell'indice per la cancellazione
               if (IndexRef.paste(pConn->getNewFullRefIndex(Catalog.get_name(),
                                                            Schema.get_name(),
                                                            Name.get_name(),
                                                            info.key_attrib.get_name(),
                                                            ERASE)) == NULL)
                  break;
               // cancello indice
               pConn->DelIndex(info.OldTableRef, IndexRef);
            }

            // Creo chiave primaria
            if (pConn->CreatePrimaryKey(info.OldTableRef.get_name(), PrimaryKey.get_name(), 
                                        info.key_attrib.get_name()) == GS_BAD)
               // Se il provider non supporta la creazione di indice (vedi Excel) vado avanti comunque
               if (GS_ERR_COD != eGSExeNotSupported) break;
         }
      }

      // se esiste il progetto corrente ed è lo stesso di quello della classe da reindicizzare
      // ed esiste una sessione di lavoro corrente attiva
      if (GS_CURRENT_WRK_SESSION &&
          (GS_CURRENT_WRK_SESSION->get_status() == WRK_SESSION_ACTIVE || GS_CURRENT_WRK_SESSION->get_status() == WRK_SESSION_SAVE) &&
          GS_CURRENT_WRK_SESSION->get_PrjId() == get_PrjId())
      {  // sono in una sessione di lavoro
         C_STRING TempTableRef;

         // ricavo connessione OLE-DB per tabella TEMP
         if ((pConn = info.getDBConnection(TEMP)) == NULL) break;

         if (getTempTableRef(TempTableRef, GS_BAD) == GS_BAD) break; // senza creare la tabella
         if (pConn->ExistTable(TempTableRef) == GS_GOOD)
            if (pConn->Reindex(TempTableRef.get_name()) == GS_BAD) break;
      }

      // reindicizzo le tabelle secondarie (se fallisce devo comunque continuare)
      reindex_sec(OnlyTemp);

      result = GS_GOOD;
   }
   while (0);

   // Scrivo messaggio nel file log
   if (result == GS_GOOD)
      swprintf(Msg, MAX_LEN_MSG, _T("Database reindex on class %d terminated."), id.code);
   else
      swprintf(Msg, MAX_LEN_MSG, _T("Database reindex on class %d failed."), id.code);

   gsc_write_log(Msg);

   return result;
}


/****************************************************************************/
/*.doc C_CGRID::reportHTML                                       <external> */
/*+
  Questa funzione stampa su un file HTML i dati della C_CGRID.
  FILE *file;        puntatore a file
  const TCHAR *Path; Path del file HTML in cui si sta scrivendo. Server unicamente
                     per poter scrivere le bitmap dei blocchi nello stesso direttorio
                     del file HTML (default = NULL).
  bool SynthMode;    Opzionale. Flag di modalità di report.
                     Se = true attiva il report sintetico (default = false)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/
/******************************************************************************/
int C_CGRID::reportHTML(FILE *file, const TCHAR *Path, bool SynthMode)
{  
   if (id.reportHTML(file, SynthMode) == GS_BAD)   return GS_BAD;
   if (info.reportHTML(file, SynthMode) == GS_BAD) return GS_BAD;
   if (attrib_list.reportHTML(file, id.pPrj->get_key(), id.code, id.sub_code, 0,
                              SynthMode) == GS_BAD) return GS_BAD;
   if (grid.reportHTML(file, SynthMode)==GS_BAD) return GS_BAD;

   C_SINTH_SEC_TAB_LIST SinthSecList;
   C_SINTH_SEC_TAB      *pSinthSec;
   C_SECONDARY          *pSecondary;
   
   // leggo la lista delle tabelle secondarie
   if (get_pPrj()->getSinthClsSecondaryTabList(id.code, id.sub_code, SinthSecList) == GS_BAD) return GS_BAD;

   pSinthSec = (C_SINTH_SEC_TAB *) SinthSecList.get_head();
   while (pSinthSec)
   {
      if ((pSecondary = (C_SECONDARY *) find_sec(pSinthSec->get_key())) == NULL) return GS_BAD;
      if (pSecondary->reportHTML(file, SynthMode) == GS_BAD) return GS_BAD;

      pSinthSec = (C_SINTH_SEC_TAB *) SinthSecList.get_next();
   }

   return GS_GOOD;
}


/*********************************************************/
/*  FINE   FUNZIONI DELLA CATEGORIA C_CGRID              */
/*  INIZIO FUNZIONI DELLA CATEGORIA C_EXTERN             */
/*********************************************************/


C_EXTERN::C_EXTERN() : C_CLASS()
{
   id.category = CAT_EXTERN;
}
C_EXTERN::~C_EXTERN()
{
   sub_list.remove_all();
}


/*********************************************************/
/*.doc get_file_stru <internal> */
/*+
  Questa funzione dato il tipo di simulazione ricava il nome del file
  contenente la struttura della stessa simulazione.
  Parametri:
  C_STRING &filename; out
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_EXTERN::get_file_stru(C_STRING &filename)
{
   C_STRING path, type, file_name;
   
   path = GEOsimAppl::GEODIR;
   path += _T('\\');
   path += GEOEXT;
   path += _T('\\');
   path += GEOEXTERN;
   
   type = id.type;
   
   if (gsc_get_profile(path, type.get_name(), _T("FILE"), filename) == GS_BAD)
      return GS_BAD;
   if (gsc_nethost2drive(filename) == GS_BAD) return GS_BAD;
        
   return GS_GOOD;
}
   

//-----------------------------------------------------------------------//
presbuf C_EXTERN::read_connect(C_PROFILE_SECTION_BTREE &ProfileSections, const TCHAR *sub_gs_id)
{
   TCHAR    *pbuf;
   int      campi, classe, type, i;
   presbuf  lista, p; 
   C_B2STR  *pProfileEntry;
   C_STRING list;

   if (!(pProfileEntry = ProfileSections.get_entry(sub_gs_id, _T("CONNECT")))) return NULL;
   list = pProfileEntry->get_name2();
   pbuf = list.get_name();
   campi = gsc_strsep(list.get_name(), _T('\0'));
   if (campi == 0)
   {
      if ((lista = acutBuildList(RTNIL, 0)) == NULL)
         { GS_ERR_COD = eGSOutOfMem; return NULL; }
      return lista;
   }      
   else if (campi % 2 == 0)  // numero insufficiente di informazioni
      { GS_ERR_COD = eGSInvalidArg; return NULL; }
   
   if ((p = lista = acutBuildList(RTLB, 0)) == NULL)
      { GS_ERR_COD = eGSOutOfMem; return NULL; }
   for (i = 1 ; i <= campi; i = i + 2)  // ciclo di lettura sotto-classi
   {                      
      if (wcslen(pbuf) == 0)
         { acutRelRb(lista); GS_ERR_COD = eGSInvalidArg; return NULL; }
      classe = _wtoi(pbuf);
      while (*pbuf != _T('\0')) pbuf++; pbuf++;
      if (wcslen(pbuf) == 0)
         { acutRelRb(lista); GS_ERR_COD = eGSInvalidArg; return NULL; }
      type = _wtoi(pbuf);
      while (*pbuf != _T('\0')) pbuf++; pbuf++;

      if ((p->rbnext = acutBuildList(RTLB,
                                     RTSHORT, classe,   // code class
                                     RTSHORT, type,     // connection type
                                     RTLE, 0)) == NULL)
         { acutRelRb(lista); GS_ERR_COD = eGSInvalidArg; return NULL; }

      while (p->rbnext != NULL) p = p->rbnext;
   }
   if ((p->rbnext = acutBuildList(RTLE, 0)) == NULL)
      { GS_ERR_COD = eGSOutOfMem; return NULL; }

   return lista;
}


/*********************************************************/
/*.doc C_EXTERN::read_stru                    <internal> */
/*+
   Questa funzione carica la struttura della classe 
   simulazione leggendola da file.
   Parametri:
   C_PROFILE_SECTION_BTREE &ProfileSections; File di profilo letto in memoria
 
   Restituisce una lista di resbuf in caso di successo 
   altrimenti restituisce NULL.
-*/  
/*********************************************************/
presbuf C_EXTERN::read_stru(C_PROFILE_SECTION_BTREE &ProfileSections)
{
   TCHAR     sub_gs_id[LEN_KEY_ATTR + 1], sez[MAX_LEN_ENTRY];
   int       n_sub_class, i;
   C_RB_LIST list, rbPropList;
   presbuf   p;
   C_B2STR   *pProfileEntry;

   if (!(pProfileEntry = ProfileSections.get_entry(_T("HEAD"), _T("COUNT")))) return NULL;
   n_sub_class = _wtoi(pProfileEntry->get_name2()); // leggo numero sotto-classi

   rbPropList << info.UDLProperties.to_rb();

   if ((list << acutBuildList(RTLB, 0)) == NULL) return NULL;

   // C_ID (potrebbe non esserci nel caso di creazione singola classe in interattivo)
   if ((p = read_id(ProfileSections)) == NULL)
      if ((p = read_id(ProfileSections, _T("1"))) == NULL) return NULL;
   list += p;

   // C_INFO
   if ((list += acutBuildList(RTLB, 0)) == NULL) return NULL;
   if ((list += info.to_rb()) == NULL) return NULL;
   if ((list += acutBuildList(RTLE, RTLB, 0)) == NULL) return NULL;

   for (i = 1 ; i <= n_sub_class; i++)  // ciclo di lettura sotto-classi
   {   
      swprintf(sub_gs_id, LEN_KEY_ATTR + 1, _T("%d"), i);
      
      if ((list += acutBuildList(RTLB, 0)) == NULL) return NULL;
      // C_ID
      if ((p = read_id(ProfileSections, sub_gs_id)) == NULL) return NULL;
      list += p;

      // C_INFO
      if ((list += acutBuildList(RTLB, 0)) == NULL) return NULL;
      if ((p = read_info(ProfileSections, sub_gs_id)) &&
          (p = gsc_CdrAssoc(_T("KEY_ATTRIB"), p, FALSE)))
         {
            C_INFO m_info;
            info.copy(&m_info);
            m_info.key_attrib = p->resval.rstring;
            if ((list += m_info.to_rb()) == NULL) return NULL;
         }
      else
         if ((list += info.to_rb()) == NULL) return NULL;
      if ((list += acutBuildList(RTLE, 0)) == NULL) return NULL;
      
      // C_FAS
      if ((p = read_fas(ProfileSections, sub_gs_id)) == NULL) return NULL;
      list += p;
   
      // C_ATTRIB_LIST
      swprintf(sez, MAX_LEN_ENTRY, _T("%s.A"), sub_gs_id);
      if ((p = read_attrib(ProfileSections, sez)) == NULL) return NULL;
      list += p;

      // C_CONNECT_LIST
      if ((p = read_connect(ProfileSections, sub_gs_id)) == NULL) return NULL;
      list += p;
      if ((list += acutBuildList(RTLE, 0)) == NULL) return NULL;
   }
   if ((list += acutBuildList(RTLE, RTLE, 0)) == NULL) return NULL;
   list.ReleaseAllAtDistruction(GS_BAD);

   return list.get_head();
}


/*********************************************************/
/*.doc C_EXTERN::write_stru                   <internal> */
/*+
   Questa funzione scrive la struttura della classe in un file
   per generare file per la creazione automatica di classi.
   Parametri:
   C_STRING       &filename;  puntatore a file
   C_DBCONNECTION *pConn;     Connessione OLE-DB da usare per scrivere la struttura
                              della tabella (default = NULL), se non indicata verrà
                              utilizzata la connessione di default di GEOsim.

   Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_EXTERN::write_stru(C_STRING &filename, C_DBCONNECTION *pConn)
{
   TCHAR          sub_gs_id[LEN_KEY_ATTR + 1];
   C_SUB          *pSub;
   C_DBCONNECTION *pOldConn, *pExportConn;
   C_STRING       buffer;
   C_ATTRIB_LIST  ExportAttribList;
   C_PROFILE_SECTION_BTREE ProfileSections;
   bool                    Unicode = false;
   if (gsc_path_exist(filename) == GS_GOOD)
      if (gsc_read_profile(filename, ProfileSections, &Unicode) == GS_BAD) return GS_BAD;

   // scrivo numero sotto-classi
   buffer = ptr_sub_list()->get_count();
   if (ProfileSections.set_entry(_T("HEAD"), _T("COUNT"), buffer.get_name()) == GS_BAD) return GS_BAD;
   
   // C_ID
   if (ptr_id()->ToFile(ProfileSections, _T("0")) == GS_BAD) return GS_BAD;

   pSub = (C_SUB *) ptr_sub_list()->get_head();
   while (pSub)
   {  // ciclo di scrittura sotto-classi
      swprintf(sub_gs_id, LEN_KEY_ATTR + 1, _T("%d"), pSub->ptr_id()->sub_code);

      // C_ID
      if (pSub->ptr_id()->ToFile(ProfileSections, sub_gs_id) == GS_BAD) return GS_BAD;

      // C_FAS
      if (pSub->ptr_fas()->ToFile(ProfileSections, sub_gs_id) == GS_BAD) return GS_BAD;

      // C_GPH_INFO
      if (ptr_GphInfo())
         if (ptr_GphInfo()->ToFile(ProfileSections, sub_gs_id) == GS_BAD) return GS_BAD;

      // C_INFO
      if (pConn) pExportConn = pConn;
      else
         // Ottengo la connessione OLE-DB di default
         if ((pExportConn = GEOsimAppl::DBCONNECTION_LIST.get_Connection()) == NULL)
            return GS_BAD;

      if ((pOldConn = pSub->ptr_info()->getDBConnection(OLD)) == NULL) return GS_BAD;

      // C_CONNECT_LIST
      pSub->ptr_connect_list()->ToFile(ProfileSections, sub_gs_id);

      // C_ATTRIB_LIST
      if (pSub->ptr_attrib_list()->copy(&ExportAttribList) == GS_BAD) return GS_BAD;
      // Converto nei tipi della classe
      if (ExportAttribList.Convert2ProviderType(pOldConn, pExportConn) != GS_GOOD)
         return GS_BAD;

      swprintf(sub_gs_id, LEN_KEY_ATTR + 1, _T("%d.A"), pSub->ptr_id()->sub_code);
      if (ExportAttribList.ToFile(ProfileSections, sub_gs_id) == GS_BAD) return GS_BAD;
   
      pSub = (C_SUB *) ptr_sub_list()->get_next();
   }

   return gsc_write_profile(filename, ProfileSections, Unicode);
}


//-----------------------------------------------------------------------//
int C_EXTERN::copy(C_CLASS *out)
{
   C_SUB *sub, *new_sub;

   if (out==NULL) { GS_ERR_COD=eGSNotAllocVar; return GS_BAD; }
   id.copy(out->ptr_id());
   info.copy(out->ptr_info());

   out->ptr_sub_list()->remove_all();
   sub = (C_SUB*)sub_list.get_head();
   
   while (sub)
   {
      new_sub = new C_SUB;
      if (sub->copy(new_sub)==GS_BAD) return GS_BAD;
      out->ptr_sub_list()->add_tail(new_sub);
      sub=(C_SUB*)sub_list.get_next();
   }
   
   return GS_GOOD;
}
//-----------------------------------------------------------------------//
int C_EXTERN::load_info(TCHAR *filename)
{
   TCHAR sez[SEZ_PROFILE_LEN]; 

   swprintf(sez, SEZ_PROFILE_LEN, _T("%d.0"), id.code);
   
   return info.load(filename,sez);
}
//-----------------------------------------------------------------------//
int C_EXTERN::ToFile(C_STRING &filename)
{
   C_PROFILE_SECTION_BTREE ProfileSections;
   bool                    Unicode = false;

   if (gsc_path_exist(filename) == GS_GOOD)
      if (gsc_read_profile(filename, ProfileSections, &Unicode) == GS_BAD) return GS_BAD;

   if (ToFile(ProfileSections) == GS_BAD) return GS_BAD;

   return gsc_write_profile(filename, ProfileSections, Unicode);
}
int C_EXTERN::ToFile(C_PROFILE_SECTION_BTREE &ProfileSections)
{
   TCHAR sez[SEZ_PROFILE_LEN];
   C_SUB *punt;

   swprintf(sez, SEZ_PROFILE_LEN, _T("%d.0"), id.code);
   if (id.ToFile(ProfileSections, sez) == GS_BAD)     return GS_BAD;
   if (info.ToFile(ProfileSections, sez) == GS_BAD)   return GS_BAD;   

   punt = (C_SUB *) sub_list.get_head();
   while (punt != NULL)
   {
      if (punt->ToFile(ProfileSections) == GS_BAD) return GS_BAD;
      punt = (C_SUB *) sub_list.get_next();
   }   
   
   return GS_GOOD;
}
//-----------------------------------------------------------------------//                  
int C_EXTERN::load(TCHAR *filename, int cl)
{
   C_PROFILE_SECTION_BTREE ProfileSections;

   if (gsc_read_profile(filename, ProfileSections) == GS_BAD) return GS_BAD;
   return load(ProfileSections, cl);
}
int C_EXTERN::load(C_PROFILE_SECTION_BTREE &ProfileSections, int cl)
{
   TCHAR sez[SEZ_PROFILE_LEN];
   C_SUB *punt;
   int   sub, Result;

   sub_list.remove_all();
   swprintf(sez, SEZ_PROFILE_LEN, _T("%d.0"), cl);
   if ((Result = id.load(ProfileSections, sez)) != GS_GOOD) return Result;

   if ((punt = new C_SUB) == NULL) { GS_ERR_COD = eGSOutOfMem; return GS_BAD; }
   sub = 1;
   while ((Result = punt->load(ProfileSections, cl, sub)) == GS_GOOD)
   {
      sub_list.add_tail(punt);
      if ((punt = new C_SUB) == NULL) { GS_ERR_COD = eGSOutOfMem; return GS_BAD; }
      sub++;
   }
   delete punt;
   if (Result == GS_CAN) { GS_ERR_COD = 0; return GS_GOOD; }      
   sub_list.remove_all();
   
   return GS_BAD;
}


//-----------------------------------------------------------------------//
resbuf *C_EXTERN::to_rb(void)             
{
   resbuf *list,*rb;
   C_SUB *punt;

   if ((list = rb = acutBuildList(RTLB, 0)) == NULL)
      { GS_ERR_COD = eGSOutOfMem; return NULL; }

   rb->rbnext = id.to_rb();                          // C_ID
   while (rb->rbnext != NULL) rb = rb->rbnext;

   if ((rb->rbnext = acutBuildList(RTLE, RTLB, 0)) == NULL)
      { acutRelRb(list); GS_ERR_COD = eGSOutOfMem; return NULL; }
   rb = rb->rbnext->rbnext;
   
   rb->rbnext = info.to_rb();                        // C_INFO //
   while (rb->rbnext != NULL) rb = rb->rbnext;
   if ((rb->rbnext = acutBuildList(RTLE, 0)) == NULL)
      { acutRelRb(list); GS_ERR_COD = eGSOutOfMem; return NULL; }
   rb = rb->rbnext;

   punt = (C_SUB*) sub_list.get_head();
   if ((rb->rbnext = acutBuildList(RTLB, 0)) == NULL)
      { acutRelRb(list); GS_ERR_COD = eGSOutOfMem; return NULL; }
   rb = rb->rbnext;
   while (punt != NULL)
   {                                
      if ((rb->rbnext = acutBuildList(RTLB, 0)) == NULL)
         { acutRelRb(list); GS_ERR_COD = eGSOutOfMem; return NULL; }
      rb = rb->rbnext;
      rb->rbnext = punt->to_rb();
      while (rb->rbnext != NULL) rb = rb->rbnext;
      if ((rb->rbnext = acutBuildList(RTLE, 0)) == NULL)
         { acutRelRb(list); GS_ERR_COD = eGSOutOfMem; return NULL; }
      rb = rb->rbnext;
      punt=(C_SUB*)sub_list.get_next();
   }                             
   if ((rb->rbnext = acutBuildList(RTLE,0)) == NULL)
      { acutRelRb(list); GS_ERR_COD = eGSOutOfMem; return NULL; }

   return list;
}


/*********************************************************/
/*.doc from_rb <internal> */
/*+
  Questa funzione carica i dati di una classe C_EXTERN da un resbuf.
  Parametri:
  presbuf rb;     lista descrizione classe
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_EXTERN::from_rb(resbuf *rb)
{
   resbuf *punt;   
   int    len,i;
   C_SUB  *nod;
   
   if (id.from_rb(gsc_nth(0,rb))==GS_BAD) return GS_BAD;
   if (info.from_rb(gsc_nth(1,rb))==GS_BAD) return GS_BAD;
   punt = gsc_nth(2, rb);
   len  = gsc_length(punt);
   sub_list.remove_all();

   for (i = 0; i < len; i++)
   {
      nod = new C_SUB;
      sub_list.add_tail(nod);
      if (nod->from_rb(gsc_nth(i,punt)) == GS_BAD)
         { sub_list.remove_all(); return GS_BAD; }
   }
    
   return GS_GOOD;
}


/*********************************************************/
/*.doc from_db <internal> */
/*+
  Questa funzione carica la definizione di una classe EXTERN dai database.
  Parametri:
  C_RB_LIST &ColValues;                lista colonna-valore della riga di GS_CLASS
  GSDataPermissionTypeEnum cod_level;  livello di abilitazione per la classe
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_EXTERN::from_db(C_RB_LIST &ColValues, GSDataPermissionTypeEnum cod_level)
{  
   // C_ID
   if (id.from_rb_db(ColValues, cod_level) == GS_BAD) return GS_BAD;
   // SUB LIST
   if (restore_sublist() == GS_BAD) return GS_BAD;

   return GS_GOOD;
}   
   
  
/*********************************************************/
/*.doc create <internal> */
/*+
  Questa funzione crea una classe C_EXTERN nei database.
    
  Restituisce codice classe in caso di successo altrimenti restituisce 0.
-*/  
/*********************************************************/
int C_EXTERN::create(void)
{
   C_SUB          *pSub;
   C_RB_LIST      _extern;
   presbuf        p;
   C_STRING       SubTableRef, Prefix, Catalog, Schema;
   int            new_code, error_code, sub;
   C_DBCONNECTION *pConn;
   TCHAR          *cod36 = NULL;

   // verifico abilitazione
   if (gsc_check_op(opCreateClass) == GS_BAD) return 0;

   acutPrintf(_T("%s <%s>..."), gsc_msg(346), id.name); // "\nCreazione classe"

   // Inizializzazioni
   id.code   = 0;
   id.abilit = GSUpdateableData;
   id.sel    = DESELECTED;
   info.pOldTabConn = NULL;
   pSub = (C_SUB *) sub_list.get_head();
   while (pSub)
   {
      pSub->ptr_id()->code          = 0;
      pSub->ptr_id()->abilit        = GSUpdateableData;
      pSub->ptr_id()->sel           = DESELECTED;
      pSub->ptr_info()->pOldTabConn = NULL;
      pSub->ptr_info()->OldTableRef.clear();
      pSub->ptr_info()->OldLnkTableRef.clear();
     
      pSub = (C_SUB *) pSub->get_next();
   }

   // verifico id
   if (is_validid() == GS_BAD) return 0;

   if ((_extern << acutBuildList(RTLB, 0)) == NULL) return 0;
   
   // C_ID
   if (id.to_rb_db(&p) == GS_BAD) return 0;
   _extern += p;
   
   // C_INFO converto i percorsi da relativi in assoluti per scrivere in DB
   info.OldLastId = info.TempLastId = 0;
   if ((p = info.to_rb(true, true)) == NULL) return 0;
   _extern += p;
   
   if ((_extern += acutBuildList(RTLE, 0)) == NULL) return 0;

   // annullo l'informazione TABLE_REF
   if ((p = _extern.CdrAssoc(_T("TABLE_REF"), FALSE)))
      if (gsc_RbSubstNIL(p) == GS_BAD) return 0;

   // Leggo catalogo e schema
   if ((pConn = info.getDBConnection(OLD)) == NULL) return 0;
   if (info.OldTableRef.len() > 0)
      if (pConn->split_FullRefTable(info.OldTableRef, Catalog, Schema, Prefix) == GS_BAD)
         return 0;

   // nome della tabella come il nome dei DWG con un prefisso ("CLS") perchè
   // alcuni provider OLE-DB non accettano nomi di tabelle che iniziano per numero
   // Il nome sarà "S" + cod prj (2) + cod cls (3) + cod sub (2)
   if (gsc_long2base36(&cod36, get_PrjId(), 2) == GS_BAD) return 0;
   Prefix = _T("S");
   Prefix += cod36;
   free(cod36); cod36 = NULL;
   
   // inserisco nuova classe in GS_CLASS
   if ((new_code = ins_cls_to_gs_class(_extern)) == GS_BAD) return 0;

   if (gsc_long2base36(&cod36, new_code, 3) == GS_BAD)
   {
      error_code = GS_ERR_COD;
      del((TCHAR *) GEOsimAppl::GS_USER.pwd);
      GS_ERR_COD = error_code;
      return 0;
   }

   Prefix += cod36; 
   free(cod36);

   sub = 1;
   pSub = (C_SUB *) sub_list.get_head();
   while (pSub != NULL)
   {
      (pSub->ptr_id())->pPrj = id.pPrj;
      (pSub->ptr_id())->code = new_code;

      pSub->ptr_info()->ConnStrUDLFile = info.ConnStrUDLFile;
      info.UDLProperties.copy(pSub->ptr_info()->UDLProperties);
      pConn->split_FullRefTable(info.OldTableRef, Catalog, Schema, SubTableRef);

      SubTableRef += _T('_');
      SubTableRef += Prefix;
      SubTableRef += sub;

      if (pSub->ptr_info()->OldTableRef.paste(pConn->get_FullRefTable(Catalog,
                                                                      Schema,
                                                                      SubTableRef)) == NULL)
      {
         error_code = GS_ERR_COD;
         del((TCHAR *) GEOsimAppl::GS_USER.pwd);
         GS_ERR_COD = error_code;
         return 0;
      }

      // Se i dati geometrici sono in tabelle DB
      if (pSub->ptr_GphInfo()->getDataSourceType() == GSDBGphDataSource)
      {
         C_DBCONNECTION *pGeomConn;
         C_DBGPH_INFO   *pGphInfo = (C_DBGPH_INFO *) pSub->ptr_GphInfo();
         C_STRING       Table;

         if ((pGeomConn = pGphInfo->getDBConnection()) == NULL ||
             pGeomConn->split_FullRefTable(pGphInfo->TableRef, Catalog, Schema, SubTableRef) == GS_BAD)
         {
            error_code = GS_ERR_COD;
            del((TCHAR *) GEOsimAppl::GS_USER.pwd);
            GS_ERR_COD = error_code;
            return 0;
         }

         SubTableRef += _T('_');
         SubTableRef += Prefix;
         SubTableRef += sub;
         SubTableRef += _T("_geom");
         if (pGphInfo->TableRef.paste(pGeomConn->get_FullRefTable(Catalog, Schema, SubTableRef)) == NULL)
         {
            error_code = GS_ERR_COD;
            del((TCHAR *) GEOsimAppl::GS_USER.pwd);
            GS_ERR_COD = error_code;
            return 0;
         }
         // Riferimento completo alla tabella di raggruppamento delle etichette
         pGphInfo->LblGroupingTableRef.clear();
         // Riferimento completo alla tabella delle etichette
         pGphInfo->LblTableRef.clear();
      }

      if (pSub->create() == GS_BAD)
      {
         error_code = GS_ERR_COD;
         del((TCHAR *) GEOsimAppl::GS_USER.pwd);
         GS_ERR_COD = error_code;
         return 0;
      }

      // verifico connect list della sub usando la sub_list
      if (is_validconnectlist((pSub->ptr_id())->sub_code, &sub_list) == GS_BAD)
      {
         error_code = GS_ERR_COD;
         del((TCHAR *) GEOsimAppl::GS_USER.pwd);
         GS_ERR_COD = error_code;
         return 0;
      }

      pSub = (C_SUB *) pSub->get_next();
      sub++;
   }

   // Creazione topologia
   C_TOPOLOGY topo;
   topo.set_type(TYPE_POLYLINE);  // tipologia di tipo rete
   topo.set_cls(this);            // per classe madre
   topo.set_temp(GS_BAD);          // Topologia OLD
   if (topo.create() == GS_BAD)
   {
      error_code = GS_ERR_COD;
      del((TCHAR *) GEOsimAppl::GS_USER.pwd);
      GS_ERR_COD = error_code;
      return 0;
   }

   // creazione collegamento progetto -> classe
   if (get_pPrj()->ptr_classlist()->add_tail(this) == GS_BAD) return 0;
   // aggiorno il codice progressivo per la creazione di classi del progetto
   get_pPrj()->setNextClassId(id.code + 1);

   // memorizzo il codice del progetto in GEOSIM.INI
   gsc_setLastUsedPrj(get_PrjId());

   return new_code;
}
                           
  
/*********************************************************/
/*.doc C_EXTERN::del <internal> */
/*+
  Questa funzione cancella una classe C_EXTERN nei database.
  Parametri:
  const TCHAR *Password;    Password dell'utente corrente (per controllo)
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_EXTERN::del(const TCHAR *Password)
{
   C_DBCONNECTION *pConn;
   C_FAMILY_LIST  family_list;
   C_SUB          *pSub;
   int            result;
   C_STRING       statement, ClassesTableRef;

   // verifico abilitazione
   if (gsc_check_op(opDelClass) == GS_BAD) return GS_BAD;
   if (ptr_id()->abilit != GSUpdateableData)
      { GS_ERR_COD = eGSClassLocked; return GS_BAD; }
   // verifico che la password sia corretta
   if (gsc_strcmp(Password, (TCHAR *) GEOsimAppl::GS_USER.pwd) != 0)
      { GS_ERR_COD = eGSInvalidPwd; return GS_BAD; }

   // verifico se la classe che si sta cancellando è legata ad altre
   if (gsc_getfamily(get_pPrj(), &family_list) == GS_BAD) return GS_BAD;
   if (family_list.search_list(id.code) != NULL)
      { GS_ERR_COD = eGSMemberOfGroup; return GS_BAD; }

   // blocco la classe in modo esclusivo GS_CLASS usando come semaforo
   // il codice della sessione attiva, se esistente, altrimenti il codice utente 
   long OwnerCode = (GS_CURRENT_WRK_SESSION) ? GS_CURRENT_WRK_SESSION->get_id() : GEOsimAppl::GS_USER.code * -1;
   if (set_exclusive_use(OwnerCode, &result) == GS_BAD || result == GS_BAD)
      return GS_BAD;

   // verifico se la classe fa parte di una sessione di lavoro
   long WrkSessionId;
   if (gsc_is_inarea(get_PrjId(), id.code, &WrkSessionId) == GS_BAD || WrkSessionId > 0)
      { GS_ERR_COD = eGSSessionsFound; return GS_BAD; }

   acutPrintf(_T("%s %s..."), gsc_msg(356), id.name); // "\nCancellazione classe"

   pSub = (C_SUB *) sub_list.get_head();
   while (pSub != NULL)
   {
      pSub->del(Password);
      pSub = (C_SUB *) sub_list.get_next();
   }

   // cancello lista connessioni   
   del_db_conc(ALL);
   
   // cancello abilitazioni alla classe per tutti gli utenti 
   gsc_delClassPermissions(get_PrjId(), id.code);

   // Cancello la classe dal set di classi del progetto
   del_db_ClassSet();

   // Cancellazione topologia
   C_TOPOLOGY topo;
   topo.set_type(TYPE_POLYLINE);  // tipologia di tipo rete
   topo.set_cls(this);            // per classe madre
   topo.set_temp(GS_BAD);         // Topologia OLD
   topo.remove();

   if (get_pPrj()->getClassesTabInfo(&pConn, &ClassesTableRef) == GS_BAD)
      { set_share_use(); return GS_BAD; }
   // cancello la riga in GS_CLASS
   statement = _T("DELETE FROM ");
   statement += ClassesTableRef;
   statement += _T(" WHERE GS_ID=");
   statement += id.code;
   if (pConn->ExeCmd(statement) == GS_BAD) return GS_BAD;

   // Cancellazione files di supporto
   DelSupportFiles();

   // cancellazione collegamento progetto -> classe
   return get_pPrj()->ptr_classlist()->remove(this);
}   
   

/*********************************************************/
/*.doc restore_sublist <internal> */
/*+
  Questa funzione carica la lista delle sottoclassi della classe dai database.
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
  N.B.: Prima di utilizzare questa funzione deve essere caricata la C_ID
-*/  
/*********************************************************/
int C_EXTERN::restore_sublist(void)
{  
   int            category, indice;
   C_SUB          *psubclass;
   C_STRING       statement, TableRef;
   C_DBCONNECTION *pConn;
   _RecordsetPtr  pRs;
   C_RB_LIST      ColValues, List, DescrSub;

   if (sub_list.is_empty() == FALSE)
      if (sub_list.remove_all() == GS_BAD) return GS_BAD;

   // setto il riferimento di GS_CLASS (<catalogo>.<schema>.<tabella>)
   if (get_pPrj()->getClassesTabInfo(&pConn, &TableRef) == GS_BAD) return GS_BAD;

   statement = _T("SELECT * FROM ");
   statement += TableRef;
   statement += _T(" WHERE GS_ID=");
   statement += id.code;
   statement += _T(" AND SUB_GS_ID<>0 ORDER BY SUB_GS_ID");

   if ((List << acutBuildList(RTLB, 0)) == NULL) return GS_BAD;

   // leggo le righe della tabella in ordine di SUB_GS_ID senza bloccarla
   if (pConn->ExeCmd(statement, pRs) == GS_BAD) return GS_BAD;

   // scorro l'elenco delle sotto classi
   while (gsc_isEOF(pRs) == GS_BAD)
   {
      if (gsc_DBReadRow(pRs, ColValues) == GS_BAD) { gsc_DBCloseRs(pRs); return GS_BAD; }
      if ((List += gsc_rblistcopy(ColValues.get_head())) == NULL)
         { gsc_DBCloseRs(pRs); return GS_BAD; }

      gsc_Skip(pRs);
   } 
   if (gsc_DBCloseRs(pRs) == GS_BAD) return GS_BAD;

   if ((List += acutBuildList(RTLE, 0)) == NULL) return GS_BAD;
          
   indice = 0;
   // scorro l'elenco delle sotto classi
   while ((DescrSub << gsc_nthcopy(indice++, List.get_head())) !=  NULL)
   {
      if (gsc_rb2Int(DescrSub.CdrAssoc(_T("CATEGORY")), &category) == GS_BAD) return GS_BAD;

      // Alloca una nuova classe
      if ((psubclass = (C_SUB *) gsc_alloc_new_class(CAT_SUBCLASS)) == NULL) return GS_BAD;

      // Collegamento classe -> progetto
      psubclass->id.pPrj = id.pPrj;

      if (psubclass->from_db(DescrSub, id.abilit) == GS_BAD)
      {
         delete psubclass;
         return GS_BAD;
      }
      
      sub_list.add_tail((C_NODE *) psubclass);  // inserimento in lista
   }
   
   if (sub_list.get_count() == 0)
      { GS_ERR_COD = eGSInvalidSubClassList; return GS_BAD; }
   
   return GS_GOOD;
}


/*********************************************************/
/*.doc C_EXTERN::get_DirectInsertableSubs <external> */
/*+
  Questa funzione restituisce la lista di puntatori alle sottoclassi 
  inseribili direttamente.
  Parametri:
  C_CLS_PUNT_LIST &out;

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_EXTERN::get_DirectInsertableSubs(C_CLS_PUNT_LIST &out)
{
   C_CLASS        *punt;
   C_CONNECT_LIST *pConnectList;
   C_INT_INT      *pConnect;
   C_CLS_PUNT     *new_nod;
   int            Connected;

   out.remove_all();

   // ciclo per ogni sottoclasse
   punt = (C_CLASS *) sub_list.get_head();
   while (punt)
   {
      // se la sottoclasse ha dei controlli di connessione (escluso OVERLAP)
      if ((pConnectList = punt->ptr_connect_list()) != NULL)
      {
         Connected = FALSE;
         // ciclo per ogni controllo di connessione
         pConnect = (C_INT_INT *) pConnectList->get_head();
         while (pConnect)
         {
            if (pConnect->get_type() != NO_OVERLAP)
               { Connected = TRUE; break; }
            pConnect = (C_INT_INT *) pConnect->get_next();
         }
            
         if (Connected)
         {
            if ((new_nod = new C_CLS_PUNT(punt)) == NULL)
               { GS_ERR_COD = eGSOutOfMem; out.remove_all(); return GS_BAD; }
            out.add_tail(new_nod);
         }
      } 
      
      punt = (C_CLASS *) punt->get_next();
   }

   return GS_GOOD;
}


/*************************************************************/
/*.doc C_EXTERN::get_DynSegmentationSupportedSubs <external> */
/*+
  Questa funzione restituisce la lista di puntatori alle sottoclassi 
  che supportano la segmentazione dinamica.
  Parametri:
  C_CLS_PUNT_LIST &out;

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*************************************************************/
int C_EXTERN::get_DynSegmentationSupportedSubs(C_CLS_PUNT_LIST &out)
{
   C_CLASS    *punt;
   C_CLS_PUNT *new_nod;

   out.remove_all();

   // ciclo per ogni sottoclasse
   punt = (C_CLASS *) sub_list.get_head();
   while (punt)
   {
      // se la sottoclasse supporta la segmentazione dinamica
      if ( punt->is_DynSegmentationSupported())
      {
         if ((new_nod = new C_CLS_PUNT(punt)) == NULL)
            { GS_ERR_COD = eGSOutOfMem; out.remove_all(); return GS_BAD; }
         out.add_tail(new_nod);
      } 
      
      punt = (C_CLASS *) punt->get_next();
   }

   return GS_GOOD;
}


/*********************************************************/
/*.doc C_EXTERN::is_IndipendentSub            <external> */
/*+
  Questa funzione restituisce GS_GOOD se la sottoclasse indicata 
  non ha relazioni topologiche con le altre sottoclassi.
  Parametri:
  int sub;     codice sottoclassse

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_EXTERN::is_IndipendentSub(int sub)
{
   C_SUB          *punt;
   C_CONNECT_LIST *pConnectList;
   C_INT_INT      *pConnect;

   // se la sottoclasse ha dei controlli di connessione
   if ((punt = (C_SUB *) sub_list.search_key(sub)) == NULL) return GS_BAD;
   if ((pConnectList = punt->ptr_connect_list()) != NULL)
   {
      // ciclo per ogni controllo di connessione
      pConnect = (C_INT_INT *) pConnectList->get_head();
      while (pConnect)
      {
         if (pConnect->get_type() != NO_CONCT_CONTROL) return GS_BAD;
         pConnect = (C_INT_INT *) pConnect->get_next();
      }
   }

   // ciclo per ogni sottoclasse che non sia sub
   punt = (C_SUB *) sub_list.get_head();
   while (punt)
   {  
      if (punt->ptr_id()->sub_code != sub)
      {
         // se la sottoclasse ha dei controlli di connessione
         if ((pConnectList = punt->ptr_connect_list()) != NULL)
         {
            // ciclo per ogni controllo di connessione
            pConnect = (C_INT_INT *) pConnectList->get_head();
            while (pConnect)
            {
               if (pConnect->get_key() == sub) return GS_BAD;
               pConnect = (C_INT_INT *) pConnect->get_next();
            }
         }
      } 
      punt = (C_SUB *) punt->get_next();
   }

   return GS_GOOD;
}

                           
/*********************************************************/
/*.doc C_EXTERN::is_validconnectlist <internal> */
/*+
  Questa funzione verifica la correttezza della C_CONNECT_LIST per una
  sottoclasse.
  Parametri:
  int subclass_code;                codice sottoclasse da esaminare
  C_LIST *ptr_sub_list;             lista delle sottoclassi
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
  N.B.: Se il codice della classe = 0 significa che si tratta della stessa
  sottoclasse (creazione di una classe e connessione con se stessa).
-*/  
/*********************************************************/
int C_EXTERN::is_validconnectlist(int subclass_code, C_LIST *ptr_sub_list)
{  
   C_INT_INT *pconct;
   C_SUB *pCls, *pSub;
   int code, indice = 1, cat, tip, conct_code;
   C_CONNECT_LIST *p_connect_list;
   
   if ((pSub = (C_SUB *) ptr_sub_list->search_key(subclass_code)) == NULL)
      return GS_BAD;
   if ((p_connect_list = (pSub->ptr_connect_list())) == NULL)
      { GS_ERR_COD = eGSInvClassType; return GS_BAD; }
   
   // verifico che una classe sia selezionata una volta sola
   if (p_connect_list->once_selclass() == GS_BAD) return GS_BAD; 

   pconct = (C_INT_INT *) p_connect_list->get_head();
   while (pconct != NULL)
   {  
      code = pconct->get_key();
      if (code != 0)
      { // Ritorna il puntatore alla sottoclasse cercata
         if ((pCls = (C_SUB *) ptr_sub_list->search_key(code)) == NULL)
            { GS_ERR_COD = eGSInvalidConct; return GS_BAD; }
         cat = pCls->get_category();
         tip = pCls->get_type();
      }
      else   // stessa classe
      {
         cat = get_category();
         tip = get_type();
      }
      // verifico che il tipo di collegamento sia corretto
      conct_code = pconct->get_type();
      if (gsc_is_validconnect(conct_code, cat, tip) == GS_BAD) return GS_BAD;
      
      pconct = (C_INT_INT *) p_connect_list->get_next();
   }
   
   return GS_GOOD;
}  


/*****************************************************************************/
/*.doc C_EXTERN::add_connected_2_sub                              <internal> */
/*+
  Questa funzione aggiunge ad una C_INT_LIST una lista di codici di sottoclassi
  che sono connesse alla  sottoclasse data <sub> (sottoclassi puntate da <sub>
  e sottoclassi che puntano a <sub>) senza duplicare i valori nella lista
  risultante.
  int        sub;
  C_INT_LIST &Result;
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*****************************************************************************/
int C_EXTERN::add_connected_2_sub(int sub, C_INT_LIST &Result)
{  
   C_SUB          *pPrevious, *pSub;
   C_CONNECT_LIST *pConnList;
   C_INT_INT      *pConn;
   C_INT          *pCodeSub;

   pPrevious = (C_SUB *) ptr_sub_list()->get_cursor();
   pSub = (C_SUB *) ptr_sub_list()->get_head();
   while (pSub)
   {  
      // se ha le connessioni
      if ((pConnList = pSub->ptr_connect_list()) != NULL)
      {
         if (pSub->ptr_id()->sub_code == sub)
         {  
            pConn = (C_INT_INT *) pConnList->get_head();
            while (pConn)
            {  // se si tratta di un controllo di connessione che non sia "sovrapposizione"
               if (pConn->get_type() != NO_OVERLAP && pConn->get_type() != NO_CONCT_CONTROL) 
               {  // inserisco la sottoclasse (se non già inserita)
                  if (!Result.search_key(pConn->get_key()))
                  {
                     if ((pCodeSub = new C_INT(pConn->get_key())) == NULL)
                        { GS_ERR_COD = eGSOutOfMem; return GS_BAD; }
                     Result.add_tail(pCodeSub);
                  }
               }
               pConn = (C_INT_INT *) pConn->get_next();
            }
         }
         else
         {
            // verifico quali altre sottoclassi devono connettersi
            pConn = (C_INT_INT *) pConnList->get_head();
            while (pConn)
            {  // se si tratta di un controllo di connessione che non sia "sovrapposizione"
               // riguardante la classe polilinea in esame
               if (pConn->get_type() != NO_OVERLAP && pConn->get_type() != NO_CONCT_CONTROL &&
                   pConn->get_key() == sub)
               {  // inserisco la classe (se non già inserita)
                  if (!Result.search_key(pSub->ptr_id()->sub_code))
                  {
                     if ((pCodeSub = new C_INT(pSub->ptr_id()->sub_code)) == NULL)
                        { GS_ERR_COD = eGSOutOfMem; return GS_BAD; }
                     Result.add_tail(pCodeSub);
                  }
               }
               pConn = (C_INT_INT *) pConn->get_next();
            }
         }
      }
      pSub = (C_SUB *) pSub->get_next();
   }
 
   return GS_GOOD;
}


/*****************************************************************************/
/*.doc C_EXTERN::add_connected_2_sub                              <internal> */
/*+
  Questa funzione ricavo la sottoclasse nodale da inserire a inizio e fine lato.
  Parametri:
  int LinkSub;    Codice sottoclasse link (lineare)

  Restituisce  in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*****************************************************************************/
C_SUB *C_EXTERN::getJollyNodalSub(int LinkSub)
{  
   C_SUB *pLinkSub = (C_SUB *) ptr_sub_list()->search_key(LinkSub);
   
   if (!pLinkSub) return NULL;

   C_INT_INT *pConnect = (C_INT_INT *) pLinkSub->ptr_connect_list()->get_head();

   while (pConnect)
      if (pConnect->get_type() & CONCT_POINT)
         return (C_SUB *) ptr_sub_list()->search_key(pConnect->get_key());
      else
         pConnect = (C_INT_INT *) pConnect->get_next();
 
   return NULL;
}


/*********************************************************/
/*.doc C_EXTERN::RefreshOldLastId <internal> */
/*+
  Questa funzione aggiorna il membro OldLastId di tutte le sottoclassi.
  Parametri:
  bool SetTempLastIdEqualToOldLastId; Opzionale; Flag per impostare il
                                      codice massimo delle tabelle
                                      TEMP uguale a quello OLD (default = true)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
  N.B. Non chiamare questa funzione se la classe a cui appartiene la C_INFO
       è usata nella sessione di lavoro corrente a meno che si stia salvando.
-*/  
/*********************************************************/
int C_EXTERN::RefreshOldLastId(bool SetTempLastIdEqualToOldLastId)
{
   C_SUB *pSub, *p;
   long  MaxValue;
   int   type;

   pSub = (C_SUB *) sub_list.get_head();
   while (pSub)
   {
      if (pSub->RefreshOldLastId(SetTempLastIdEqualToOldLastId) == GS_BAD)
         return GS_BAD;
      pSub = (C_SUB *) pSub->get_next();
   }

   pSub = (C_SUB *) sub_list.get_head();
   while (pSub)
   {
      type     = pSub->get_type();
      MaxValue = pSub->ptr_info()->OldLastId;

      // Cerco il codice più alto tra le sottoclassi dello stesso tipo
      p = (C_SUB *) sub_list.get_head();
      while (p)
      {
         if (type == p->get_type())
            MaxValue = gsc_max(MaxValue, p->ptr_info()->OldLastId);

         p = (C_SUB *) p->get_next();
      }     

      pSub->ptr_info()->OldLastId = MaxValue;
      if (SetTempLastIdEqualToOldLastId) 
         pSub->ptr_info()->TempLastId = MaxValue;

      pSub = (C_SUB *) pSub->get_next();
   }

   return GS_GOOD;
}


/*********************************************************/
/*.doc C_EXTERN::RefreshTempLastId <internal> */
/*+
  Questa funzione aggiorna il membro TempLastId di tutte le sottoclassi e
  delle tabelle secondarie interne.
  Parametri:

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_EXTERN::RefreshTempLastId(void)
{
   C_SUB *pSub, *p;
   long  MaxValue;
   int   type;

   pSub = (C_SUB *) sub_list.get_head();
   while (pSub)
   {
      if (pSub->RefreshTempLastId() == GS_BAD) return GS_BAD;
      pSub = (C_SUB *) pSub->get_next();
   }

   pSub = (C_SUB *) sub_list.get_head();
   while (pSub)
   {
      type     = pSub->get_type();
      MaxValue = pSub->ptr_info()->TempLastId;

      // Cerco il codice più alto tra le sottoclassi dello stesso tipo
      p = (C_SUB *) sub_list.get_head();
      while (p)
      {
         if (type == p->get_type())
            MaxValue = gsc_max(MaxValue, p->ptr_info()->TempLastId);

         p = (C_SUB *) p->get_next();
      }     

      pSub->ptr_info()->TempLastId = MaxValue;

      pSub = (C_SUB *) pSub->get_next();
   }

   return GS_GOOD;
}


/*********************************************************/
/*.doc C_EXTERN::reindexTab <internal> */
/*+
  Questa funzione reindicizza le tabelle della classe.
  Parametri:
  bool OnlyTemp;        Flag, se true indica che devono essere considerate solo
                        le tabelle temporanee (default = false)
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_EXTERN::reindexTab(bool OnlyTemp)
{
   C_SUB *pSub;

   pSub = (C_SUB *) sub_list.get_head();
   while (pSub)
   {
      if (pSub->reindexTab(OnlyTemp) == GS_BAD) return GS_BAD;
     
      pSub = (C_SUB *) sub_list.get_next();
   }

   // aggiorno ENT_LAST in GS_CLASS
   RefreshOldLastId();
   set_unlocked(0, GS_GOOD, true);

   // Reindicizzo anche la topologia
   C_TOPOLOGY topo;
   topo.set_type(TYPE_POLYLINE);  // tipologia di tipo rete
   topo.set_cls(this);            // per classe madre

   if (!OnlyTemp)
   {
      topo.set_temp(GS_BAD);         // Topologia OLD
      topo.reindex();
   }

   if (is_extracted() == GS_GOOD)
   {
      topo.set_temp(GS_GOOD);     // Topologia TEMP
      topo.reindex();
   }

   return GS_GOOD;
}


/****************************************************************************/
/*.doc C_EXTERN::reportHTML                                      <external> */
/*+
  Questa funzione stampa su un file HTML i dati della C_EXTERN.
  Parametri:
  FILE *file;        puntatore a file
  const TCHAR *Path; Path del file HTML in cui si sta scrivendo. Server unicamente
                     per poter scrivere le bitmap dei blocchi nello stesso direttorio
                     del file HTML (default = NULL).
  bool SynthMode;    Opzionale. Flag di modalità di report.
                     Se = true attiva il report sintetico (default = false)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/
/******************************************************************************/
int C_EXTERN::reportHTML(FILE *file, const TCHAR *Path, bool SynthMode)
{
   C_SUB *pSub = (C_SUB *) sub_list.get_head();

   if (id.reportHTML(file, SynthMode) == GS_BAD) return GS_BAD;

   while (pSub)
   {
      if (pSub->reportHTML(file, Path, SynthMode) == GS_BAD) return GS_BAD;
      pSub = (C_SUB *) pSub->get_next();
   }
   
   return GS_GOOD;
}


/***************************************************************************/
/*.doc C_EXTERN::synchronize                                     <external> */
/*+
  Questa funzione sincronizza i database con la grafica.
  Parametri:
  const TCHAR *DeletedObjsDWG; Path del disegno in cui inserire gli oggetti che
                               sono stati cancellati da questa funzione
  TCHAR *NextCmd;              Stringa che identifica una eventuale chiamata 
                               ad un comando da lanciare a fine sessione 
                               (dopo il comando di "NEW"), default = NULL.
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/
/***************************************************************************/
int C_EXTERN::synchronize(const TCHAR *DeletedObjsDWG, TCHAR *NextCmd)
{
   C_WRK_SESSION  WrkSession(get_pPrj());
   C_LINK_SET     LinkSet;
   C_SELSET       SSEnt, SSClass, SSChecked, SSToErase;
   C_EED          eed;
   C_RB_LIST      env_variab, ColValues;
   C_STRING       session_dir, FldName, statement, ODTableName, OD_Id;
   C_INT          *pcls_2_extract;
   C_INT_LIST     cls_list_2_extract;
   presbuf        pKey;
   C_DBCONNECTION *pConn;
   _RecordsetPtr  pRs;
   int            result = GS_BAD, nPrincExist, AggrFactorCorrected, ODCorrected;
   long           Key, i, AggrFactor, qty, Prj = get_PrjId(), nSub = 0;
   ads_name       ent;
   C_SUB          *pSub;
   TCHAR          Msg[MAX_LEN_MSG];
   C_TOPOLOGY     topo;
   C_STATUSBAR_PROGRESSMETER StatusBarProgressMeter(gsc_msg(1085), id.name); // "Sincronizzazione classe <%s>"

   // verifico abilitazione
   if (gsc_check_op(opSynchronizeClass) == GS_BAD) return GS_BAD;

   pSub = (C_SUB *) ptr_sub_list()->get_head();
   while (pSub)
   {
      if (pSub->ptr_info()->LinkedTable) { GS_ERR_COD = eGSClassLocked; return GS_BAD; }
      // Se i dati geometrici sono in tabelle DB collegate (basta una sola)
      if (pSub->ptr_GphInfo()->getDataSourceType() == GSDBGphDataSource)
      {
         C_DBGPH_INFO *pGphInfo = (C_DBGPH_INFO *) pSub->ptr_GphInfo();
         
         if (pGphInfo->LinkedTable || pGphInfo->LinkedLblGrpTable || pGphInfo->LinkedLblTable)
            { GS_ERR_COD = eGSClassLocked; return GS_BAD; }
      }

      pSub = (C_SUB *) pSub->get_next();
   }

   // setto i valori di UNDO, BLIPMODE, HIGHLIGHT per avere massima velocità di ACAD
   if ((env_variab << gsc_setVarForCommandSpeed()) == NULL) return GS_BAD;
   gsc_disableUndoRecording(true);

   swprintf(Msg, MAX_LEN_MSG, _T("Synchronization class %d started."), id.code);  
   gsc_write_log(Msg);

   do
   {
      session_dir = _T("GEOSIM_SYNCHRONIZE_CLS");
      session_dir += id.code;
      if (WrkSession.set_name(session_dir.get_name()) == GS_BAD) break;

      session_dir = get_pPrj()->get_dir();
      session_dir += _T("\\GSSYNCHRONIZE_CLS");
      session_dir += id.code;
      if (WrkSession.set_dir(session_dir.get_name()) == GS_BAD) break;
      WrkSession.set_level(GSUpdateableData);
   
      // Alloca un oggetto C_INT
      if ((pcls_2_extract = new C_INT(id.code)) == NULL)
         { GS_ERR_COD = eGSOutOfMem; break; }
      cls_list_2_extract.add_tail(pcls_2_extract);

      // seleziono classe da estrarre, ed eseguo estrazione
      // effettuo estrazione rendendo la classe in sola lettura alle altre sessioni
      if (gsc_extract_classes((C_PROJECT *) id.pPrj,  // progetto
                              WrkSession,             // sessione di lavoro
                              cls_list_2_extract,     // lista classi
                              TRUE,                   // estrazione in esclusiva
                              NULL,                   // condizione spaziale
                              NULL,                   // condizione di proprietà
                              FALSE,                  // forma NOT oppure no
                              EXTRACTION,             // modo di estrazione
                              &SSClass) == GS_BAD)    // gruppo di selezione estratto
         break;

      // se la classe è stata in modifica
      // (perchè bloccata da un'altra sessione di lavoro)
      if (id.abilit != GSUpdateableData) { GS_ERR_COD = eGSClassLocked; break; }

      if (gsc_callCmd(_T("_.ZOOM"), RTSTR, _T("_E"), 0) != RTNORM) break;

      topo.set_type(TYPE_POLYLINE); // tipologia di tipo rete
      topo.set_cls(this);        // codice classe madre

      StatusBarProgressMeter.Init(ptr_sub_list()->get_count());

      result = GS_GOOD;
      pSub = (C_SUB *) ptr_sub_list()->get_head();
      while (pSub)
      {
         StatusBarProgressMeter.Set(++nSub);

         qty = 0;

         // sincronizzazione database
         if ((pConn = pSub->ptr_info()->getDBConnection(OLD)) == NULL) 
            { result = GS_BAD; break; }

         FldName = pSub->ptr_info()->key_attrib;
         if (gsc_AdjSyntax(FldName, pConn->get_InitQuotedIdentifier(),
                           pConn->get_FinalQuotedIdentifier(),
                           pConn->get_StrCaseFullTableRef()) == GS_BAD)
            { result = GS_BAD; break; }

         statement = _T("SELECT ");
         statement += FldName;
         statement += _T(" FROM ");
         statement += pSub->ptr_info()->OldTableRef;
         statement += _T(" WHERE ");
         statement += FldName;
         statement += _T("<>0 OR ");
         statement += FldName;
         statement += _T(" IS NULL");

         // creo record-set
         // prima era adOpenKeyset poi adOpenDynamic ma PostgreSQL
         // in una transazione fa casino (al secondo recordset che viene aperto)
         if (pConn->OpenRecSet(statement, pRs, adOpenForwardOnly, adLockOptimistic) == GS_BAD)
            { result = GS_BAD; break; }
         if (gsc_InitDBReadRow(pRs, ColValues) == GS_BAD)
            { result = GS_BAD; gsc_DBCloseRs(pRs); break; }
         pKey = ColValues.CdrAssoc(pSub->ptr_info()->key_attrib.get_name());

         // mi ricavo la tabella OD per eventuali correzioni sui dati OD
         gsc_getODTableName(Prj, pSub->ptr_id()->code, pSub->ptr_id()->sub_code,
                            ODTableName);

         C_STRING   CompleteName;
         pSub->get_CompleteName(CompleteName);
         C_STATUSLINE_MESSAGE StatusLineMsg(gsc_msg(1085), CompleteName.get_name()); // "Sincronizzazione classe <%s>"
         StatusLineMsg.Init(gsc_msg(310), MEDIUM_STEP); // ogni 100 "%ld entità GEOsim elaborate."

         while (gsc_isEOF(pRs) == GS_BAD)
         {
            // per ogni record ricavo gli oggetti grafici collegati
            gsc_DBReadRow(pRs, ColValues);
            if (gsc_rb2Lng(pKey, &Key) == GS_BAD)
            { 
               gsc_DBDelRow(pRs);
               gsc_Skip(pRs);
            
               continue;
            }

            if (LinkSet.GetSS(pSub->ptr_id()->code, pSub->ptr_id()->sub_code, Key, SSEnt) == GS_BAD)
            {
               // Segnalo l'errore su file .LOG e a video
               swprintf(Msg, MAX_LEN_MSG, _T("Lost link between graphic and database on entity: key %ld, prj %d, class %d, sub %d."),
                        Key, ((C_PROJECT *) pSub->ptr_id()->pPrj)->get_key(), pSub->ptr_id()->code, pSub->ptr_id()->sub_code);
               gsc_write_log(Msg);
               acutPrintf(gsc_msg(52), Key); // "\nCollegamento tra grafica e database non più valido per l'entità: %ld.\n"

               gsc_DBDelRow(pRs);
               gsc_Skip(pRs);
               // Cancellazione nella topologia
               topo.editdelelem(Key, pSub->get_type());

               continue;
            }

            // Aggiungo al selection set della classe
            SSChecked.add_selset(SSEnt);

            // Se ci sono più oggetti grafici principali bisogna lasciarne solo uno
            // perchè non è ammessa l'aggregazione di più oggetti grafici principali
            i = 0;
            nPrincExist = 0;
            while (SSEnt.entname(i++, ent) == GS_GOOD)
               if (gsc_is_DABlock(ent) == GS_BAD)
               {
                  nPrincExist++;

                  // se era già stato trovato un oggetto grafico principale
                  if (nPrincExist > 1)
                  {  // lo cancello
                     // Segnalo l'errore su file .LOG e a video
                     swprintf(Msg, MAX_LEN_MSG, _T("Wrong aggregation on entity: key %ld, prj %d, class %d, sub %d."),
                              Key, ((C_PROJECT *) pSub->ptr_id()->pPrj)->get_key(), pSub->ptr_id()->code, pSub->ptr_id()->sub_code);
                     gsc_write_log(Msg);
                     acutPrintf(gsc_msg(52), Key); // "\nCollegamento tra grafica e database non più valido per l'entità: %ld.\n"

                     // Inserisco nel gruppo di oggetti da cancellare
                     SSToErase.add(ent);
                  }
               }

            // il fattore di aggregazione deve essere uguale alle istanze grafiche dell'entità
            i = 0;
            AggrFactor = SSEnt.length();
            // se era presenti più oggetti grafici principali ne rimarrà solo 1
            if (nPrincExist > 1) AggrFactor = AggrFactor - (nPrincExist - 1);

            AggrFactorCorrected  = FALSE;
            ODCorrected         = FALSE;

            while (SSEnt.entname(i++, ent) == GS_GOOD)
            {
               eed.load(ent);
               if (eed.num_el != AggrFactor)
               {  // Correggo il fattore di aggregazione
                  eed.save_aggr((int) AggrFactor);
                  AggrFactorCorrected = TRUE;
               }
               if (gsc_getIDfromODTable(ent, ODTableName, OD_Id) == GS_BAD)
               {  // Correggo il codice nella tabella OD
                  gsc_setID2ODTable(ent, ODTableName, eed.gs_id);
                  // Aggiungo in GEOsimAppl::SAVE_SS per salvataggio
                  gsc_addEnt2savess(ent);
                  ODCorrected = TRUE;
               }
            }

            if (AggrFactorCorrected) 
            {
               // Segnalo l'errore su file .LOG e a video
               swprintf(Msg, MAX_LEN_MSG, _T("Aggregation factor corrected on entity: key %ld, prj %d, class %d, sub %d."),
                        Key, Prj, pSub->ptr_id()->code, pSub->ptr_id()->sub_code);
               gsc_write_log(Msg);
               acutPrintf(gsc_msg(136), Key); // "\nFattore di aggregazione corretto per l'entità: %ld.\n"
            }
            if (ODCorrected)
            {
               // Segnalo l'errore su file .LOG e a video
               swprintf(Msg, MAX_LEN_MSG, _T("Object Data corrected on entity: ODTableName %s."),
                        ODTableName.get_name());
               gsc_write_log(Msg);
               // "\nDati oggetto corretti per una entità: Tabella %s.\n"
               acutPrintf(gsc_msg(86), ODTableName.get_name());
            }

            // degli oggetti grafici deve esistere almeno un oggetto principale
            if (nPrincExist == 0) 
            {
               // Segnalo l'errore su file .LOG e a video
               swprintf(Msg, MAX_LEN_MSG, _T("Wrong link between graphic and database on entity: key %ld, prj %d, class %d, sub %d."),
                        Key, Prj, pSub->ptr_id()->code, pSub->ptr_id()->sub_code);
               gsc_write_log(Msg);
               acutPrintf(gsc_msg(52), Key); // "\nCollegamento tra grafica e database non più valido per l'entità: %ld.\n"

               // Inserisco nel gruppo di oggetti da cancellare
               SSToErase.add_selset(SSEnt);
               gsc_DBDelRow(pRs);
               // Cancellazione nella topologia
               topo.editdelelem(Key, pSub->get_type());
            }

            gsc_Skip(pRs);

            StatusLineMsg.Set(++qty); // "%ld entità GEOsim elaborate."
         }
         gsc_DBCloseRs(pRs);

         StatusLineMsg.Set(gsc_msg(310), qty); // "%ld entità GEOsim elaborate."

         pSub = (C_SUB *) pSub->get_next();
      }
      StatusBarProgressMeter.End(gsc_msg(1090)); // "Terminato."
      
      result = GS_BAD;
      
      // Sottraggo da tutti gli oggetti in grafica 
      // quelli che non hanno collegamento valido a DB
      SSClass.subtract(SSChecked);
      SSToErase.add_selset(SSClass);
   
      if ((qty = SSToErase.length()) > 0)
      {
         ads_name ss;

         // Segnalo l'errore su file .LOG e a video
         swprintf(Msg, MAX_LEN_MSG, _T("Erased some entities having wrong link between graphic and database."));
         gsc_write_log(Msg);
         acutPrintf(gsc_msg(267)); // "\nAlcune entità con collegamento tra grafica e database non più valido saranno cancellate."

         if (DeletedObjsDWG)
         {  // Esporto oggetti in un file DWG cancellandoli dalla sessione
            ads_point pt;
            C_STRING  dummy(DeletedObjsDWG), ext;

            ads_point_clear(pt);

            // Controlla Correttezza Path
            if (gsc_nethost2drive(dummy) == GS_GOOD)            
            {
               C_LINK   Link;
               C_SELSET SStoExport;

               gsc_splitpath(dummy, NULL, NULL, NULL, &ext);
               if (ext.len() == 0) dummy += _T(".DWG"); // aggiungo l'estensione "DWG"                 

               // Duplicazione oggetti principali con cancellazione link a database e
               // EED (per permettere una successiva importazione)
               i = 0;
               while (SSToErase.entname(i++, ent) == GS_GOOD)
                  if (gsc_is_DABlock(ent) == GS_BAD)
                  {
                     gsc_DeepClone2ModSpace(ent);
                     acdbEntLast(ent);
                     SStoExport.add(ent);
                     Link.erase(ent);
                     eed.clear(ent);
                  }

               if (SStoExport.length() > 0)
               {
                  SStoExport.get_selection(ss);

                  if (gsc_path_exist(dummy) == GS_GOOD)
                  {
                     if (gsc_delfile(dummy) == GS_GOOD)
                        gsc_callCmd(_T("_.WBLOCK"), RTSTR, dummy.get_name(), RTSTR, GS_EMPTYSTR, RTPOINT, pt, RTPICKS, ss, RTSTR, GS_EMPTYSTR, RTSTR, _T("_N"), 0);
                  }
                  else
                     gsc_callCmd(_T("_.WBLOCK"), RTSTR, dummy.get_name(), RTSTR, GS_EMPTYSTR, RTPOINT, pt, RTPICKS, ss, RTSTR, GS_EMPTYSTR, RTSTR, _T("_N"), 0);

                  swprintf(Msg, MAX_LEN_MSG, _T("Please, look at the <%s> file."), dummy.get_name());
                  gsc_write_log(Msg);
               }
            }
         }

         // Aggiungo in GEOsimAppl::SAVE_SS per salvataggio
         gsc_addSS2savess(SSToErase);
         
         // Prima di cancellare gli oggetti ciclo su di essi per verificare
         // se qualcuno ha una EED NON della classe in oggetto
         // in questo caso devo correggerla altrimenti il salvataggio lo considererà
         i = 0;
         while (SSToErase.entname(i++, ent) == GS_GOOD)
		      if (eed.load(ent) != GS_GOOD || eed.cls != id.code)
            {
               eed.cls = id.code;
               eed.save(ent, GS_BAD); // non aggiungo in GEOsimAppl::SAVE_SS perchè già fatto
            }

         // Cancello gli oggetti
         SSToErase.Erase();

         // ricreo la topologia
         // CounterToVideo, codice sottoclasse puntuale per nuovi nodi, modo non interattivo
         if (topo.create(GS_GOOD, 0, false) == GS_BAD) break;
      }

      // Salvataggio delle entità di GEOsim con aggiornamento degli e-last
      // (nel caso in cui C_TOPOLOGY::create abbia creato nuovi nodi)
      if (save() == GS_BAD) break;

      // Sincronizzazione topologia OLD
      topo.set_temp(GS_BAD);
      topo.synchronize(GS_GOOD);

      // Sincronizzazione tabelle secondarie
      synchronize_sec();

      result = GS_GOOD;
   }
   while (0);

   swprintf(Msg, MAX_LEN_MSG, _T("Synchronization class %d terminated."), id.code);  
   gsc_write_log(Msg);

   // rispristino i valori precedenti di UNDO, BLIPMODE, HIGHLIGHT
   gsc_disableUndoRecording(false);
   gsc_setVarForCommandNormal(env_variab.get_head());

   // uscita dalla sessione di lavoro
   if (GS_CURRENT_WRK_SESSION)
   { 
      // Inizializzo queste variabili prima di chiamare gsc_ExitCurrSession che 
      // toglie dalla memoria questa classe
      TCHAR Msg[256];
      int   Cls = id.code;

      swprintf(Msg, 256, gsc_msg(289), id.name);

      // rilascio tutti i DWG della classe altrimenti non si potrebbe
      // ristorare il backup dei DWG che risulterebbero in uso
      GphDetach();
		// uscita dalla sessione di lavoro
      if (gsc_ExitCurrSession(GS_BAD, NextCmd) == GS_GOOD)
      {
         // "Messaggio GEOsim: La classe <%s> non è più in uso esclusivo."
         gsc_NotifyWaitForSave(Prj, Cls, Msg);
         gsc_NotifyWaitForExtraction(Prj, Cls, Msg);
      }
   }

   // memorizzo il codice del progetto in GEOSIM.INI
   gsc_setLastUsedPrj(Prj);

   return result;
}


/******************************************************************************/
/*.doc C_EXTERN::GphDetach                                        <external>  */
/*+
  Funzione per il rilascio della sorgente dati geometrica della classe.
  Parametri:

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/******************************************************************************/
int C_EXTERN::GphDetach(void)
{
   C_SUB *pSub = (C_SUB *) ptr_sub_list()->get_head();

   while (pSub)
   {
      if (pSub->GphDetach() == GS_BAD) return GS_BAD;

      pSub = (C_SUB *) pSub->get_next();
   }

   return GS_GOOD;
}

/*********************************************************/
/*  FINE   FUNZIONI DELLA CATEGORIA C_EXTERN             */
/*  INIZIO FUNZIONI DELLA CATEGORIA C_SUB                */
/*********************************************************/


C_SUB::C_SUB() : C_CLASS()
{
   ptr_secondary_list = new C_SECONDARY_LIST(this);
   pGphInfo           = NULL;
}
C_SUB::~C_SUB() 
{
   if (pGphInfo) delete pGphInfo;
}

int C_SUB::allocGraphInfo(GraphDataSourceEnum Type)
{
   deallocGphInfo();
   pGphInfo = gsc_alloc_GraphInfo(Type);
   return (pGphInfo == NULL) ? GS_BAD : GS_GOOD;
}

void C_SUB::deallocGphInfo(void)
{ if (pGphInfo) { delete pGphInfo; pGphInfo = NULL; } }

int C_SUB::is_validconnectlist(void)
   { GS_ERR_COD=eGSInvClassType; return GS_BAD; }
int C_SUB::mod_conct(C_CONNECT_LIST *p_conct)
   { GS_ERR_COD = eGSInvClassType; return GS_BAD; }


int C_SUB::copy(C_CLASS *out)
{
   if (!out) { GS_ERR_COD=eGSNotAllocVar; return GS_BAD; }
   id.copy(out->ptr_id());
   fas.copy(out->ptr_fas());

   if (ptr_GphInfo())
   {
      out->allocGraphInfo(ptr_GphInfo()->getDataSourceType());
      ptr_GphInfo()->copy(out->ptr_GphInfo());
   }

   info.copy(out->ptr_info());
   connect_list.copy(out->ptr_connect_list());
   attrib_list.copy(out->ptr_attrib_list());
   return GS_GOOD;
}
//-----------------------------------------------------------------------//
int C_SUB::load_info(TCHAR *filename)
{
   TCHAR sez[SEZ_PROFILE_LEN]; 

   swprintf(sez, SEZ_PROFILE_LEN, _T("%d.%d"), id.code, id.sub_code);
   
   return info.load(filename,sez);
}
//-----------------------------------------------------------------------//
int C_SUB::load_connect_list(TCHAR *filename)
{
   TCHAR sez[SEZ_PROFILE_LEN]; 

   swprintf(sez, SEZ_PROFILE_LEN, _T("%d.%d"), id.code, id.sub_code);

   return connect_list.load(filename,sez);
}
//-----------------------------------------------------------------------//
int C_SUB::ToFile(C_STRING &filename)
{
   C_PROFILE_SECTION_BTREE ProfileSections;
   bool                    Unicode = false;

   if (gsc_path_exist(filename) == GS_GOOD)
      if (gsc_read_profile(filename, ProfileSections, &Unicode) == GS_BAD) return GS_BAD;

   if (ToFile(ProfileSections) == GS_BAD) return GS_BAD;

   return gsc_write_profile(filename, ProfileSections, Unicode);
}
int C_SUB::ToFile(C_PROFILE_SECTION_BTREE &ProfileSections)
{
   TCHAR sez[SEZ_PROFILE_LEN];

   swprintf(sez, SEZ_PROFILE_LEN, _T("%d.%d"), id.code, id.sub_code);
   if (id.ToFile(ProfileSections, sez) == GS_BAD)           return GS_BAD;
   if (info.ToFile(ProfileSections, sez) == GS_BAD)         return GS_BAD;
   if (fas.ToFile(ProfileSections, sez) == GS_BAD)          return GS_BAD;   
   // C_GRAPH_INFO
   if (ptr_GphInfo())
      if (ptr_GphInfo()->ToFile(ProfileSections, sez) == GS_BAD) return GS_BAD;
   if (connect_list.ToFile(ProfileSections, sez) == GS_BAD) return GS_BAD;
   wcscat(sez, ATTRIB_PROFILE);
   if (attrib_list.ToFile(ProfileSections, sez) == GS_BAD) return GS_BAD;
   
   return GS_GOOD;
}
//-----------------------------------------------------------------------//
int C_SUB::load(TCHAR *filename, int cl, int sub)
{
   C_PROFILE_SECTION_BTREE ProfileSections;

   if (gsc_read_profile(filename, ProfileSections) == GS_BAD) return GS_BAD;
   return load(ProfileSections, cl, sub);
}
int C_SUB::load(C_PROFILE_SECTION_BTREE &ProfileSections, int cl, int sub)
{
   TCHAR               sez[SEZ_PROFILE_LEN];
   GraphDataSourceEnum SrcType;
   int                 Result;

   swprintf(sez, SEZ_PROFILE_LEN, _T("%d.%d"), cl, sub);
   if ((Result = id.load(ProfileSections, sez)) != GS_GOOD) return Result;
   if (info.load(ProfileSections, sez) != GS_GOOD)          return GS_BAD;
   if (fas.load(ProfileSections, sez) != GS_GOOD)           return GS_BAD;   

   if ((SrcType = gsc_getGraphDataSourceType(ProfileSections, sez)) == GSNoneGphDataSource)
      return GS_BAD;
   if (allocGraphInfo(SrcType) == GS_BAD)                    return GS_BAD;
   if (ptr_GphInfo()->load(ProfileSections, sez) != GS_GOOD) return GS_BAD;

   if (connect_list.load(ProfileSections, sez) != GS_GOOD) return GS_BAD;
   wcscat(sez, ATTRIB_PROFILE);
   return attrib_list.load(ProfileSections, sez, info.getDBConnection(OLD));
}


/*********************************************************/
/*.doc C_SUB::to_rb                       <external> */
/*+
  Questa funzione scrive la definizione di una classe C_SUB 
  in formato resbuf.
  (<C_ID><C_INFO><C_FAS><C_GPH_INFO><C_CONNECT_LIST><C_ATTRIB_LIST>) 
  Parametri:
  presbuf rb;     lista descrizione classe
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
resbuf *C_SUB::to_rb(void)             
{
   C_RB_LIST List;
   
   if ((List << acutBuildList(RTLB, 0)) == NULL) return NULL;
   // C_ID
   if ((List += id.to_rb()) == NULL) return NULL;
   if ((List += acutBuildList(RTLE, RTLB, 0)) == NULL) return NULL;
   // C_INFO
   if ((List += info.to_rb()) == NULL) return NULL;
   if ((List += acutBuildList(RTLE, RTLB, 0)) == NULL) return NULL;
   // C_FAS
   if ((List += fas.to_rb()) == NULL) return NULL;
   if ((List += acutBuildList(RTLE, RTLB, 0)) == NULL) return NULL;
   // C_GPH_INFO
   if (ptr_GphInfo())
   {
      if ((List += ptr_GphInfo()->to_rb()) == NULL) return NULL;
      if ((List += acutBuildList(RTLE, RTLB, 0)) == NULL) return NULL;
   }
   // C_CONNECT_LIST
   if ((List += connect_list.to_rb()) == NULL) return NULL;
   if ((List += acutBuildList(RTLE, RTLB, 0)) == NULL) return NULL;
   // C_ATTRIB_LIST
   if ((List += attrib_list.to_rb()) == NULL) return NULL;
   if ((List += acutBuildList(RTLE, 0)) == NULL) return NULL;
   
   List.ReleaseAllAtDistruction(GS_BAD);

   return List.get_head();
}


/*********************************************************/
/*.doc from_rb <internal> */
/*+
  Questa funzione carica i dati di una classe C_SUB da un resbuf.
  (<id><info><fas><gph_info><attrib_list><connect_list>)
  Parametri:
  presbuf rb;     lista descrizione classe
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_SUB::from_rb(resbuf *rb)
{
   presbuf             p;
   GraphDataSourceEnum SrcType;

   if (id.from_rb(gsc_nth(0,rb))==GS_BAD)  return GS_BAD;
   if (info.from_rb(gsc_nth(1,rb))==GS_BAD) return GS_BAD;
   if (fas.from_rb(gsc_nth(2,rb))==GS_BAD) return GS_BAD;

   p = gsc_nth(3, rb);
   if ((SrcType = gsc_getGraphDataSourceType(p)) == GSNoneGphDataSource) return GS_BAD;
   if (allocGraphInfo(SrcType) == GS_BAD) return GS_BAD;
   if (ptr_GphInfo()->from_rb(p) == GS_BAD) return GS_BAD;

   if (attrib_list.from_rb(gsc_nth(4,rb))==GS_BAD) return GS_BAD;
   if (connect_list.from_rb(gsc_nth(5,rb))==GS_BAD) return GS_BAD;

   return GS_GOOD;
}


/*********************************************************/
/*.doc C_SUB::from_db                         <internal> */
/*+
  Questa funzione carica la definizione di una classe C_SUB dai database.
  Parametri:
  C_RB_LIST &ColValues;                lista colonna-valore della riga di GS_CLASS
  GSDataPermissionTypeEnum cod_level;  livello di abilitazione per la classe
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_SUB::from_db(C_RB_LIST &ColValues, GSDataPermissionTypeEnum cod_level)
{  
   // C_ID
   if (id.from_rb_db(ColValues, cod_level) == GS_BAD) return GS_BAD;

   // C_INFO
   if (info.from_rb_db(ColValues) == GS_BAD) return GS_BAD;

   // C_FAS
   if (fas.from_db(id.pPrj, id.code, id.sub_code) == GS_BAD) return GS_BAD;
   // C_GPH_INFO
   if ((pGphInfo = gsc_GphDataSrcFromDB(id.pPrj, id.code, id.sub_code)) == NULL)
      return GS_BAD;
  
   // CONNECT LIST
   if (restore_connectlist() == GS_BAD) return GS_BAD;

   // ATTRIBUTE LIST
   if (restore_attriblist() == GS_BAD) return GS_BAD;

   return GS_GOOD;
}   
   
  
/*********************************************************/
/*.doc create <internal> */
/*+
  Questa funzione crea una classe C_SUB nei database.
    
  Restituisce codice sottoclasse in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_SUB::create(void)
{
   C_RB_LIST      sub;
   presbuf        p;
   int            new_code, error_code, result = GS_BAD;
   C_DBCONNECTION *pConn;
                             
   // verifico abilitazione
   if (gsc_check_op(opCreateClass) == GS_BAD) return 0;

   if (ptr_GphInfo() == NULL) return 0;

   // La tabella collegata non è ammessa per questo tipo di classe
   if (info.LinkedTable ||
       (ptr_GphInfo()->getDataSourceType() == GSDBGphDataSource &&
        (((C_DBGPH_INFO *) ptr_GphInfo())->LinkedTable ||
         ((C_DBGPH_INFO *) ptr_GphInfo())->LinkedLblGrpTable ||
         ((C_DBGPH_INFO *) ptr_GphInfo())->LinkedLblTable)))
      { GS_ERR_COD = eGSOpNotAble; return 0; }

   acutPrintf(_T("%s %s..."), gsc_msg(347), id.name); // "\nCreazione sotto-classe"

   // Inizializzazioni
   id.abilit = GSUpdateableData;
   id.sel    = DESELECTED;

   // carico eventuali funzioni di calcolo in GSL.GSL del progetto della classe
   gsc_load_gsl(get_pPrj()->get_dir());

   // ricavo connessione OLE-DB
   if ((pConn = info.getDBConnection(OLD)) == NULL) { gs_gsl_reload(); return 0; }
   // verifico id
   if (is_validid() == GS_BAD) { gs_gsl_reload(); return 0; }
   // verifico fas
   if (is_validfas(id.type, pConn, ptr_attrib_list()) == GS_BAD) { gs_gsl_reload(); return 0; }
   // verifico connessione a sorgente grafica
   if (ptr_GphInfo()->isValid(id.type) == GS_BAD) { gs_gsl_reload(); return 0; }
   // verifico info
   if (is_validinfo() == GS_BAD) { gs_gsl_reload(); return 0; }
   // connect list verificata dopo la chiamata a questa funzione
   // verifico attrib list
   if (attrib_list.is_valid(pConn) == GS_BAD) { gs_gsl_reload(); return 0; }
   if (attrib_list.is_valid(id.category, id.type, pConn, info.key_attrib,
                            ptr_fas()) == GS_BAD)
      { gs_gsl_reload(); return 0; }

	// ricarico GSL.GSL giusto
	gs_gsl_reload();
   
   if ((sub << acutBuildList(RTLB, 0)) == NULL) return 0;
   
   // C_ID
   if (id.to_rb_db(&p) == GS_BAD) return 0;
   sub += p;
   
   // C_INFO converto i percorsi da relativi in assoluti per scrivere in DB
   info.OldLastId = info.TempLastId = 0;
   if ((p = info.to_rb(true, true)) == NULL) return 0;
   sub += p;
   
   if ((sub += acutBuildList(RTLE, 0)) == NULL) return 0;
   
   do
   {
      // inserisco nuova sottoclasse in GS_CLASS
      if ((new_code = ins_cls_to_gs_class(sub)) == GS_BAD) break;     

      // Inserisco caratteristiche grafiche in DB
      if (fas.to_db(get_pPrj(), id.code, new_code) == GS_BAD) break;

      // Inserisco informazioni sulla sorgente grafica in DB
      ptr_GphInfo()->prj = id.pPrj->get_key();
      ptr_GphInfo()->cls = id.code;
      ptr_GphInfo()->sub = new_code;
      if (ptr_GphInfo()->to_db() == GS_BAD) break;

      // creo directory della tabella, creo tabella e indice 
      if (create_tab() == GS_BAD) break;

      // creo sorgente grafica
      if (ptr_GphInfo()->CreateResource(id.type) == GS_BAD) break;
   
      // scarico valori di default in tabella
      if (default_to_db(&attrib_list) == GS_BAD) break;
   
      // scarico su tabella GS_ATTR le caratteristiche degli attributi
      if (carattattr_to_db(&attrib_list) == GS_BAD) break;

      // scarico la connect list
      if (to_db_connectlist(ptr_connect_list()) == GS_BAD) break;

      result = GS_GOOD;
   }
   while (0);

   if (result == GS_BAD)
   {
      error_code = GS_ERR_COD;
      del((TCHAR *) GEOsimAppl::GS_USER.pwd);
      GS_ERR_COD = error_code;
      return 0;
   }

   return new_code;
}
                           
  
/*********************************************************/
/*.doc del <internal> */
/*+
  Questa funzione cancella una classe C_SUB nei database.
  Parametri:
  const TCHAR *Password;    Password dell'utente corrente (per controllo)
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_SUB::del(const TCHAR *Password)
{
   C_DBCONNECTION *pConn;
   C_FAMILY_LIST  family_list;

   // verifico abilitazione
   if (gsc_check_op(opDelClass) == GS_BAD) return GS_BAD;
   if (ptr_id()->abilit != GSUpdateableData)
      { GS_ERR_COD = eGSClassLocked; return GS_BAD; }
   // verifico che la password sia corretta
   if (gsc_strcmp(Password, (TCHAR *) GEOsimAppl::GS_USER.pwd) != 0)
      { GS_ERR_COD = eGSInvalidPwd; return GS_BAD; }

   // verifico se la classe che si sta cancellando è legata ad altre
   if (gsc_getfamily(get_pPrj(), &family_list) == GS_BAD) return GS_BAD;
   if (family_list.search_list(id.code) != NULL)
      { GS_ERR_COD = eGSMemberOfGroup; return GS_BAD; }

   acutPrintf(_T("%s %s..."), gsc_msg(357), id.name); // "\nCancellazione sotto-classe"

   // cancello tabelle secondarie
   del_all_tab_sec(Password);

   // cancello tabelle della classe
   del_tab_class();

   // cancello le informazioni grafiche della classe
   fas.del_db(get_pPrj(), id.code, id.sub_code);

   // cancello le informazioni relative alla sorgente grafica 
   // della classe ed eventuali sottoclassi
   // rimuovendo anche le risorse grafiche (disegni, cartelle ...)
   if (ptr_GphInfo()) ptr_GphInfo()->del_db(true);

   // cancello caratteristiche attributi
   del_db_carattattr();

   // ricavo connessione OLE-DB
   if ((pConn = ptr_info()->getDBConnection(OLD)) &&
       pConn->get_CatalogResourceType() == DirectoryRes)
   {
      C_STRING Catalog, Schema, Table, Path;

      if (pConn->split_FullRefTable(ptr_info()->OldTableRef, Catalog,
                                    Schema, Table) == GS_GOOD &&
          gsc_RefTable2Path(pConn->get_DBMSName(), Catalog, Schema, Table, Path) == GS_GOOD)
         // Cancello direttorio
         gsc_rmdir_from_path(Path.get_name());
   }   

   return GS_GOOD;
}   

                           
/*********************************************************/
/*.doc C_SUB::is_validfas <internal> */
/*+
  Questa funzione verifica la correttezza della C_FAS.
  Parametri:
  int type;                      Tipo della classe
  C_DBCONNECTION *pConn;         Connessione OLE-DB
  C_ATTRIB_LIST *p_attrib_list;  Lista attributi
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
  N.B. : Deve essere già stato caricato un eventuale GSL.GSL dal progetto della classe
-*/  
/*********************************************************/
int C_SUB::is_validfas(int type, C_DBCONNECTION *pConn, C_ATTRIB_LIST *p_attrib_list)
{                
   switch (type)
   {
      case TYPE_SURFACE:   // SUPERFICIE
         // Bordo
         if (fas.color.getColorMethod() == C_COLOR::None) return GS_BAD;
         if (gsc_validlinetype(fas.line) == GS_BAD) return GS_BAD;
         if (gsc_validscale(fas.line_scale) == GS_BAD) return GS_BAD;
         if (gsc_validwidth(fas.width) == GS_BAD) return GS_BAD;
         if (gsc_validthickness(fas.thickness) == GS_BAD) return GS_BAD;
         // Riempimento
         if (fas.hatch_color.getColorMethod() == C_COLOR::None) return GS_BAD;
         if (gsc_validscale(fas.hatch_scale) == GS_BAD) return GS_BAD;
         if (gsc_validlayer(fas.hatch_layer) == GS_BAD) return GS_BAD;
         if (gsc_validhatch(fas.hatch) == GS_BAD) return GS_BAD;
         break;
      case TYPE_POLYLINE:  // POLILINEA
         if (fas.color.getColorMethod() == C_COLOR::None) return GS_BAD;
         if (gsc_validlinetype(fas.line) == GS_BAD) return GS_BAD;
         if (gsc_validscale(fas.line_scale) == GS_BAD) return GS_BAD;
         if (gsc_validwidth(fas.width) == GS_BAD) return GS_BAD;
         if (gsc_validthickness(fas.thickness) == GS_BAD) return GS_BAD;
         break;
      case TYPE_TEXT:      // TESTO
         if (fas.color.getColorMethod() == C_COLOR::None) return GS_BAD;
         if (gsc_validtextstyle(fas.style) == GS_BAD) return GS_BAD;
         if (gsc_validhtext(fas.h_text) == GS_BAD) return GS_BAD;
         if (gsc_validthickness(fas.thickness) == GS_BAD) return GS_BAD;
         break;
      case TYPE_NODE:      // NODO
         if (gsc_validblock(fas.block) == GS_BAD) return GS_BAD;
         if (gsc_validscale(fas.block_scale) == GS_BAD) return GS_BAD;
         break;
      default : { GS_ERR_COD=eGSInvClassType; return GS_BAD; }
   }      
   
   // verifico validità layer
   if (gsc_validlayer(fas.layer) == GS_BAD) return GS_BAD;
   // verifico validità file-blocco di riferimento
   if (gsc_validrefblk(&(fas.file_ref_block), fas.ref_block) == GS_BAD) return GS_BAD;
   // verifico validità file-funzione di calcolo per la grafica
   if (gsc_validgphcalc(&(fas.file_graph_calc), fas.fun_graph_calc, p_attrib_list) == GS_BAD)
      return GS_BAD;
   
   return GS_GOOD;
}  


/*********************************************************/
/*.doc C_SUB::RefreshTempLastId <internal> */
/*+
  Questa funzione aggiorna il membro TempLastId della classe e
  delle tabelle secondarie interne.
  Parametri:

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_SUB::RefreshTempLastId(void)
{
   C_STRING       TempTableRef;
   C_DBCONNECTION *pConn;
   double          Value;

   // Se la classe non è estratta nella sessione corrente
   if (is_extracted() == GS_BAD) 
      { GS_ERR_COD = eGSNotCurrentSession; return GS_BAD; }
   // ricavo connessione OLE-DB per tabella TEMP
   if ((pConn = info.getDBConnection(TEMP)) == NULL) return GS_BAD;
   // senza creare la tabella
   if (getTempTableRef(TempTableRef, GS_BAD) == GS_BAD) return GS_BAD;
   if (pConn->ExistTable(TempTableRef) == GS_GOOD)
   // ricavo il codice maggiore
   if (pConn->GetNumAggrValue(TempTableRef.get_name(),
                              info.key_attrib.get_name(),
                              _T("MAX"), &Value) != GS_GOOD) return GS_BAD;
   info.TempLastId = (long) Value;

   return RefreshSecTempLastId();
}


/*********************************************************/
/*.doc C_SUB::reindexTab <internal> */
/*+
  Questa funzione reindicizza le tabelle della classe.
  Parametri:
  bool OnlyTemp;        Flag, se true indica che devono essere considerate solo
                        le tabelle temporanee (default = false)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
  N.B. deve essere chiamata esclusivamente passando per la C_EXTERN::reindexTab
-*/  
/*********************************************************/
int C_SUB::reindexTab(bool OnlyTemp)
{
   int            result = GS_BAD;
   C_DBCONNECTION *pConn;
   TCHAR          Msg[MAX_LEN_MSG];
   
   do
   {
      if (!OnlyTemp && !info.LinkedTable) // Se si tratta di una tabella collegata non posso reindicizzare
      {
         // ricavo connessione OLE-DB con tabelle OLD
         if ((pConn = info.getDBConnection(OLD)) == NULL) return GS_BAD;

         if (pConn->ExistTable(info.OldTableRef) == GS_GOOD)
         {
            C_STRING PrimaryKey;

            // Nome della chiave primaria
            if (info.get_PrimaryKeyName(PrimaryKey) == GS_BAD)
               break;

            // Cancello chiave primaria
            if (pConn->DelPrimaryKey(info.OldTableRef.get_name(), PrimaryKey.get_name(), 
                                     ONETEST, GS_BAD) == GS_BAD)
            { // La chiave primaria non c'era. Al suo posto c'era un indice normale.
               C_STRING Catalog, Schema, Name, IndexRef;

               // cancello l'indice per codice chiave
               if (pConn->split_FullRefTable(info.OldTableRef, Catalog, Schema, Name) == GS_BAD)
                  break;

               // Ottengo il nome completo dell'indice per la cancellazione
               if (IndexRef.paste(pConn->getNewFullRefIndex(Catalog.get_name(),
                                                            Schema.get_name(),
                                                            Name.get_name(),
                                                            info.key_attrib.get_name(),
                                                            ERASE)) == NULL)
                  break;
               // cancello indice
               pConn->DelIndex(info.OldTableRef, IndexRef);
            }

            // Creo chiave primaria
            if (pConn->CreatePrimaryKey(info.OldTableRef.get_name(), PrimaryKey.get_name(), 
                                        info.key_attrib.get_name()) == GS_BAD)
               // Se il provider non supporta la creazione di indice (vedi Excel) vado avanti comunque
               if (GS_ERR_COD != eGSExeNotSupported) break;
         }
      }

      // se esiste il progetto corrente ed è lo stesso di quello della classe da reindicizzare
      // ed esiste una sessione di lavoro corrente attiva
      if (GS_CURRENT_WRK_SESSION &&
          (GS_CURRENT_WRK_SESSION->get_status() == WRK_SESSION_ACTIVE || GS_CURRENT_WRK_SESSION->get_status() == WRK_SESSION_SAVE) &&
          GS_CURRENT_WRK_SESSION->get_PrjId() == get_PrjId())
      {
         C_STRING TempTableRef;

         // ricavo connessione OLE-DB per tabella TEMP
         if ((pConn = info.getDBConnection(TEMP)) == NULL) break;

         if (getTempTableRef(TempTableRef, GS_BAD) == GS_BAD) break; // senza creare la tabella
         if (pConn->ExistTable(TempTableRef) == GS_GOOD)
            pConn->Reindex(TempTableRef.get_name());
      }

      // reindicizzo le tabelle secondarie
      if (reindex_sec(OnlyTemp) == GS_BAD) break;

      result = GS_GOOD;
   }
   while (0);

   // Scrivo messaggio nel file log
   if (result == GS_GOOD)
      swprintf(Msg, MAX_LEN_MSG, _T("Database reindex on class %d, %d terminated."), id.code, id.sub_code);
   else
      swprintf(Msg, MAX_LEN_MSG, _T("Database reindex on class %d, %d failed."), id.code, id.sub_code);

   gsc_write_log(Msg);

   return result;
}


/****************************************************************************/
/*.doc C_SUB::reportHTML                                         <external> */
/*+
  Questa funzione stampa su un file HTML i dati della C_SUB.
  Parametri:
  FILE *file;        Puntatore a file
  const TCHAR *Path; Path del file HTML in cui si sta scrivendo. Server unicamente
                     per poter scrivere le bitmap dei blocchi nello stesso direttorio
                     del file HTML (default = NULL).
  bool SynthMode;    Opzionale. Flag di modalità di report.
                     Se = true attiva il report sintetico (default = false)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/
/******************************************************************************/
int C_SUB::reportHTML(FILE *file, const TCHAR *Path, bool SynthMode)
{  
   if (id.reportHTML(file, SynthMode) == GS_BAD)   return GS_BAD;
   if (info.reportHTML(file, SynthMode) == GS_BAD) return GS_BAD;
   if (fas.reportHTML(this, file, Path, SynthMode) == GS_BAD) return GS_BAD;
   if (pGphInfo)
      if (pGphInfo->reportHTML(file, SynthMode) == GS_BAD) return GS_BAD;
   if (attrib_list.reportHTML(file, id.pPrj->get_key(), id.code, id.sub_code, 0,
                              SynthMode) == GS_BAD) return GS_BAD;
   if (connect_list.reportHTML(file, id.pPrj, id.code, id.sub_code, 
                               SynthMode) == GS_BAD) return GS_BAD;

   C_SINTH_SEC_TAB_LIST SinthSecList;
   C_SINTH_SEC_TAB      *pSinthSec;
   C_SECONDARY          *pSecondary;
   
   // leggo la lista delle tabelle secondarie
   if (get_pPrj()->getSinthClsSecondaryTabList(id.code, id.sub_code, SinthSecList) == GS_BAD) return GS_BAD;

   pSinthSec = (C_SINTH_SEC_TAB *) SinthSecList.get_head();
   while (pSinthSec)
   {
      if ((pSecondary = (C_SECONDARY *) find_sec(pSinthSec->get_key())) == NULL) return GS_BAD;
      if (pSecondary->reportHTML(file, SynthMode) == GS_BAD) return GS_BAD;

      pSinthSec = (C_SINTH_SEC_TAB *) SinthSecList.get_next();
   }

   return GS_GOOD;
}


/*********************************************************/
/*  FINE   FUNZIONI DELLA CATEGORIA C_SUB                */
/*  INIZIO FUNZIONI DELLA CATEGORIA C_SPAGHETTI          */
/*********************************************************/

C_SPAGHETTI::C_SPAGHETTI() : C_CLASS()
{
   id.category = CAT_SPAGHETTI;
   pGphInfo    = NULL;
} 
C_SPAGHETTI::~C_SPAGHETTI() 
{
   if (pGphInfo) delete pGphInfo;
}

int C_SPAGHETTI::is_validinfo() { GS_ERR_COD = eGSInvClassType; return GS_BAD; }

int C_SPAGHETTI::allocGraphInfo(GraphDataSourceEnum Type)
{
   deallocGphInfo();
   pGphInfo = gsc_alloc_GraphInfo(Type);
   return (pGphInfo == NULL) ? GS_BAD : GS_GOOD;
}
void C_SPAGHETTI::deallocGphInfo(void)
{ if (pGphInfo) { delete pGphInfo; pGphInfo = NULL; } }

int C_SPAGHETTI::ToFile(C_STRING &filename)
{
   C_PROFILE_SECTION_BTREE ProfileSections;
   bool                    Unicode = false;

   if (gsc_path_exist(filename) == GS_GOOD)
      if (gsc_read_profile(filename, ProfileSections, &Unicode) == GS_BAD) return GS_BAD;

   if (ToFile(ProfileSections) == GS_BAD) return GS_BAD;

   return gsc_write_profile(filename, ProfileSections, Unicode);
}
int C_SPAGHETTI::ToFile(C_PROFILE_SECTION_BTREE &ProfileSections)
{
   TCHAR sez[SEZ_PROFILE_LEN];

   swprintf(sez, SEZ_PROFILE_LEN, _T("%d.0"), id.code);
   if (id.ToFile(ProfileSections, sez) == GS_BAD)  return GS_BAD;
   if (fas.ToFile(ProfileSections, sez) == GS_BAD) return GS_BAD;   
   // C_GRAPH_INFO
   if (ptr_GphInfo())
      if (ptr_GphInfo()->ToFile(ProfileSections, sez) == GS_BAD) return GS_BAD;

   return GS_GOOD;
}
/*********************************************************/
/*.doc C_SPAGHETTI::to_rb                       <external> */
/*+
  Questa funzione scrive la definizione di una classe C_SPAGHETTI 
  in formato resbuf.
  (<C_ID><C_FAS><C_GPH_INFO>) 
  Parametri:
  presbuf rb;     lista descrizione classe
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
resbuf *C_SPAGHETTI::to_rb(void)             
{
   C_RB_LIST List;

   if ((List << acutBuildList(RTLB, 0)) == NULL) return NULL;
   // C_ID
   if ((List += id.to_rb()) == NULL) return NULL;
   if ((List += acutBuildList(RTLE, RTLB, 0)) == NULL) return NULL;
   // C_FAS
   if ((List += fas.to_rb()) == NULL) return NULL;
   if ((List += acutBuildList(RTLE, RTLB, 0)) == NULL) return NULL;
   // C_GPH_INFO
   if (ptr_GphInfo())
   {
      if ((List += ptr_GphInfo()->to_rb()) == NULL) return NULL;
      if ((List += acutBuildList(RTLE, RTLB, 0)) == NULL) return NULL;
   }
   
   if ((List += acutBuildList(RTLE, 0)) == NULL) return NULL;
   
   List.ReleaseAllAtDistruction(GS_BAD);

   return List.get_head();
}


//-----------------------------------------------------------------------//
int C_SPAGHETTI::load(TCHAR *filename, int cl)
{
   C_PROFILE_SECTION_BTREE ProfileSections;

   if (gsc_read_profile(filename, ProfileSections) == GS_BAD) return GS_BAD;
   return load(ProfileSections, cl);
}
int C_SPAGHETTI::load(C_PROFILE_SECTION_BTREE &ProfileSections, int cl)
{
   TCHAR               sez[SEZ_PROFILE_LEN];
   GraphDataSourceEnum SrcType;
   int                 Result;

   swprintf(sez, SEZ_PROFILE_LEN, _T("%d.0"), cl);
   if ((Result = id.load(ProfileSections, sez)) != GS_GOOD) return Result;
   if (fas.load(ProfileSections, sez) != GS_GOOD)           return GS_BAD;  

   if ((SrcType = gsc_getGraphDataSourceType(ProfileSections, sez)) == GSNoneGphDataSource)
      return GS_BAD;
   if (allocGraphInfo(SrcType) == GS_BAD) return GS_BAD;
   return ptr_GphInfo()->load(ProfileSections, sez);
}


//-----------------------------------------------------------------------//
int C_SPAGHETTI::copy(C_CLASS *out)
{
   if (!out) { GS_ERR_COD=eGSNotAllocVar; return GS_BAD; }
   id.copy(out->ptr_id());
   fas.copy(out->ptr_fas());

   if (ptr_GphInfo())
   {
      out->allocGraphInfo(ptr_GphInfo()->getDataSourceType());
      ptr_GphInfo()->copy(out->ptr_GphInfo());
   }

   connect_list.copy(out->ptr_connect_list());

   return GS_GOOD;
}
                   

/*********************************************************/
/*.doc C_SPAGHETTI::from_rb <internal> */
/*+
  Questa funzione carica i dati di una classe C_SPAGHETTI da un resbuf.
  (<id><fas><gph_info>)
  Parametri:
  presbuf rb;     lista descrizione classe
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_SPAGHETTI::from_rb(resbuf *rb)
{
   presbuf             p;
   GraphDataSourceEnum SrcType;

   if (id.from_rb(gsc_nth(0,rb))==GS_BAD)   return GS_BAD;
   if (fas.from_rb(gsc_nth(1,rb))==GS_BAD)  return GS_BAD;

   p = gsc_nth(2, rb);
   if ((SrcType = gsc_getGraphDataSourceType(p)) == GSNoneGphDataSource) return GS_BAD;
   if (allocGraphInfo(SrcType) == GS_BAD) return GS_BAD;
   if (ptr_GphInfo()->from_rb(p) == GS_BAD) return GS_BAD;

   return GS_GOOD;
}


/*********************************************************/
/*.doc from_db <internal> */
/*+
  Questa funzione carica la definizione di una classe C_SPAGHETTI dai database.
  Parametri:
  C_RB_LIST &ColValues;                lista colonna-valore della riga di GS_CLASS
  GSDataPermissionTypeEnum cod_level;  livello di abilitazione per la classe
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_SPAGHETTI::from_db(C_RB_LIST &ColValues, GSDataPermissionTypeEnum cod_level)
{  
   // C_ID
   if (id.from_rb_db(ColValues, cod_level) == GS_BAD) return GS_BAD;

   // C_FAS
   if (fas.from_db(id.pPrj, id.code, id.sub_code) == GS_BAD) return GS_BAD;
   // C_GPH_INFO
   if ((pGphInfo = gsc_GphDataSrcFromDB(id.pPrj, id.code, id.sub_code)) == NULL)
      return GS_BAD;

   return GS_GOOD;
}   
   
  
/*********************************************************/
/*.doc create <internal> */
/*+
  Questa funzione crea una classe C_SPAGHETTI nei database.
    
  Restituisce codice classe in caso di successo altrimenti restituisce 0.
-*/  
/*********************************************************/
int C_SPAGHETTI::create(void)
{
   C_RB_LIST spaghetti;
   presbuf   p;
   int       new_code, error_code, result = GS_BAD;

   // verifico abilitazione
   if (gsc_check_op(opCreateClass) == GS_BAD) return 0;

   acutPrintf(_T("%s <%s>..."), gsc_msg(346), id.name); // "\nCreazione classe"

   if (ptr_GphInfo() == NULL) return 0;

   // Inizializzazioni
   id.code   = 0;
   id.type   = TYPE_SPAGHETTI;
   id.abilit = GSUpdateableData;
   id.sel    = DESELECTED;

   // verifico id
   if (is_validid() == GS_BAD) return 0;
   // verifico fas
   if (is_validfas(id.type, NULL, ptr_attrib_list()) == GS_BAD) return 0;
   // verifico connessione a sorgente grafica
   if (ptr_GphInfo()->isValid(id.type) == GS_BAD) return 0;

   if ((spaghetti << acutBuildList(RTLB, 0)) == NULL) return 0;
   
   // C_ID
   if (id.to_rb_db(&p) == GS_BAD) return 0;
   spaghetti += p;
   
   if ((spaghetti += acutBuildList(RTLE, 0)) == NULL) return 0;

   // inserisco nuova classe in GS_CLASS
   if ((new_code = ins_cls_to_gs_class(spaghetti)) == GS_BAD) return 0;

   // Inizializzo la GphInfo
   bool GeomExist;
   ptr_GphInfo()->prj = id.pPrj->get_key();
   ptr_GphInfo()->cls = new_code;
   ptr_GphInfo()->sub = 0;
   // Se esiste già la risorsa grafica e
   if (ptr_GphInfo()->ResourceExist(&GeomExist) && 
       // se si tratta di dwg oppure 
       // se si tratta di db ed esiste la tabelle geometrica che non è stata dichiarata come "collegata"
       (ptr_GphInfo()->getDataSourceType() == GSDwgGphDataSource ||
        (ptr_GphInfo()->getDataSourceType() == GSDBGphDataSource &&
         (GeomExist && !((C_DBGPH_INFO *) ptr_GphInfo())->LinkedTable))))
   {
      C_DBCONNECTION *pConn;
      C_STRING       statement, ClassesTableRef;

      if (get_pPrj()->getClassesTabInfo(&pConn, &ClassesTableRef) == GS_GOOD)
      {
         // cancello la riga in GS_CLASS
         statement = _T("DELETE FROM ");
         statement += ClassesTableRef;
         statement += _T(" WHERE GS_ID=");
         statement += new_code;
         pConn->ExeCmd(statement);
      }

      GS_ERR_COD = eGSGraphResourceAlreadyExisting; 
      return 0; 
   }

   do
   {   
      // Inserisco caratteristiche grafiche in DB
      if (fas.to_db(get_pPrj(), new_code) == GS_BAD) break;

      // Inserisco informazioni sulla sorgente grafica in DB
      ptr_GphInfo()->prj = id.pPrj->get_key();
      ptr_GphInfo()->cls = new_code;
      ptr_GphInfo()->sub = 0;
      if (ptr_GphInfo()->to_db() == GS_BAD) break;

      // creo sorgente grafica
      if (ptr_GphInfo()->CreateResource(id.type) == GS_BAD) break;

      result = GS_GOOD;
   }
   while (0);

   if (result == GS_BAD)
   {
      error_code = GS_ERR_COD;
      del((TCHAR *) GEOsimAppl::GS_USER.pwd);
      GS_ERR_COD = error_code;
      return 0;
   }

   // creazione collegamento progetto -> classe
   if (get_pPrj()->ptr_classlist()->add_tail(this) == GS_BAD) return 0;
   // aggiorno il codice progressivo per la creazione di classi del progetto
   get_pPrj()->setNextClassId(id.code + 1);

   // memorizzo il codice del progetto in GEOSIM.INI
   gsc_setLastUsedPrj(get_PrjId());

   return new_code;
}
                           
  
/*********************************************************/
/*.doc del <internal> */
/*+
  Questa funzione cancella una classe C_SPAGHETTI nei database.
  Parametri:
  const TCHAR *Password;    Password dell'utente corrente (per controllo)
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_SPAGHETTI::del(const TCHAR *Password)
{
   C_FAMILY_LIST  family_list;
   C_DBCONNECTION *pConn;
   C_STRING       statement, ClassesTableRef;
   int            result;
   
   // verifico abilitazione
   if (gsc_check_op(opDelClass) == GS_BAD) return GS_BAD;
   if (ptr_id()->abilit != GSUpdateableData)
      { GS_ERR_COD = eGSClassLocked; return GS_BAD; }
   // verifico che la password sia corretta
   if (gsc_strcmp(Password, (TCHAR *) GEOsimAppl::GS_USER.pwd) != 0)
      { GS_ERR_COD = eGSInvalidPwd; return GS_BAD; }

   // verifico se la classe che si sta cancellando è legata ad altre
   if (gsc_getfamily(get_pPrj(), &family_list) == GS_BAD) return GS_BAD;
   if (family_list.search_list(id.code) != NULL)
      { GS_ERR_COD = eGSMemberOfGroup; return GS_BAD; }

   // blocco la classe in modo esclusivo GS_CLASS usando come semaforo
   // il codice della sessione attiva, se esistente, altrimenti il codice utente 
   long OwnerCode = (GS_CURRENT_WRK_SESSION) ? GS_CURRENT_WRK_SESSION->get_id() : GEOsimAppl::GS_USER.code * -1;
   if (set_exclusive_use(OwnerCode, &result) == GS_BAD || result == GS_BAD)
      return GS_BAD;

   // verifico se la classe fa parte di una sessione di lavoro
   long WrkSessionId;
   if (gsc_is_inarea(get_PrjId(), id.code, &WrkSessionId) == GS_BAD || WrkSessionId > 0)
      { GS_ERR_COD = eGSSessionsFound; return GS_BAD; }

   acutPrintf(_T("%s %s..."), gsc_msg(356), id.name); // "\nCancellazione classe"

   // cancello le informazioni grafiche della classe
   fas.del_db(get_pPrj(), id.code, 0);
   
   // cancello le informazioni relative alla sorgente grafica 
   // della classe ed eventuali sottoclassi
   // rimuovendo anche le risorse grafiche (disegni, cartelle ...)
   if (ptr_GphInfo()) ptr_GphInfo()->del_db(true);

   // cancello abilitazioni alla classe per tutti gli utenti 
   gsc_delClassPermissions(get_PrjId(), id.code);

   // Cancello la classe dal set di classi del progetto
   del_db_ClassSet();

   if (get_pPrj()->getClassesTabInfo(&pConn, &ClassesTableRef) == GS_BAD)
      { set_share_use(); return GS_BAD; }
   // cancello la riga in GS_CLASS
   statement = _T("DELETE FROM ");
   statement += ClassesTableRef;
   statement += _T(" WHERE GS_ID=");
   statement += id.code;
   if (pConn->ExeCmd(statement) == GS_BAD) return GS_BAD;

   // cancellazione collegamento progetto -> classe
   return get_pPrj()->ptr_classlist()->remove(this);
}


/*****************************************************************************/
/*.doc C_SPAGHETTI::AlignGraphDataOnCopyClass                     <internal> */
/*+
  Questa funzione copia tutti gli oggetti grafici della classe
  in una nuova classe e allineando i marker ed eventualmente la fas.
  Parametri:
  C_CLASS *new_cls;   puntatore alla classe destinazione della copia

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/ 
/*****************************************************************************/ 
int C_SPAGHETTI::AlignGraphDataOnCopyClass(C_CLASS *new_cls)
{
   int        result = GS_BAD;
   int        OldPrj, NewPrj, OldCls, NewCls;
   C_RB_LIST  env_variab;
   C_INT_LIST cls_list_2_extract;
   C_INT      *pcls_2_extract;
   C_STRING   session_dir, oldtable;
   C_WRK_SESSION WrkSession(get_pPrj());
   long       i, BitForChangeFAS, BitForDiffFAS;
   C_FAS      *p_old_fas = ptr_fas(), *p_new_fas = new_cls->ptr_fas();
   C_SELSET   GraphObjs;
   ads_name   ent;
   C_EED      eed;
   C_STATUSLINE_MESSAGE StatusLineMsg(gsc_msg(1081)); // "Riallineamento banca dati"

   if (GS_CURRENT_WRK_SESSION) { GS_ERR_COD = eGSSessionsFound; return GS_BAD; }

   // verifico abilitazione
   if (gsc_check_op(opCopyClass) == GS_BAD) return GS_BAD;
   if ((env_variab << gsc_setVarForCommandSpeed()) == NULL) return GS_BAD;

   OldPrj = get_PrjId();
   NewPrj = new_cls->ptr_id()->pPrj->get_key();
   OldCls = id.code;
   NewCls = new_cls->ptr_id()->code;

   do                                       
   {
      session_dir = _T("GEOSIM_COPY_GRAPH_CLS");
      session_dir += OldCls;
      if (WrkSession.set_name(session_dir.get_name()) == GS_BAD) break;

      session_dir = get_pPrj()->get_dir();
      session_dir += _T("\\GSCOPYGPH_CLS");
      session_dir += OldCls;
      if (WrkSession.set_dir(session_dir.get_name()) == GS_BAD) break;
   
      WrkSession.set_level(GSUpdateableData);  

      // imposto lo srid della sessione corrente come quello della classe sorgente
      C_STRING *pAutocadSRID = NULL;
      if (ptr_GphInfo()->getDataSourceType() == GSDBGphDataSource)
         pAutocadSRID = ((C_DBGPH_INFO *) ptr_GphInfo())->get_ClsSRID_converted_to_AutocadSRID();
      else
         pAutocadSRID = &(ptr_GphInfo()->coordinate_system);
      if (pAutocadSRID) WrkSession.set_coordinate(pAutocadSRID->get_name());

      // seleziono la classe origine per la prossima estrazione
      if ((pcls_2_extract = new C_INT(OldCls)) == NULL)
         { GS_ERR_COD = eGSOutOfMem; break; }
      cls_list_2_extract.add_tail(pcls_2_extract);
      
      // seleziono classe da estrarre, ed eseguo estrazione
      // effettuo estrazione rendendo la classe in sola lettura alle altre sessioni
      if (gsc_extract_classes(get_pPrj(),             // progetto
                              WrkSession,             // sessione di lavoro
                              cls_list_2_extract,     // lista classi
                              TRUE,                   // estrazione in esclusiva
                              NULL,                   // condizione spaziale
                              NULL,                   // condizione di proprietà
                              FALSE,                  // forma NOT oppure no
                              EXTRACTION,             // modo di estrazione
                              &GraphObjs) == GS_BAD)  // gruppo di selezione estratto
         break;

      GphDetach(); // rilascio tutti i DWG della classe sorgente

      if (gsc_callCmd(_T("_.ZOOM"), RTSTR, _T("_E"), 0) != RTNORM) break;

      StatusLineMsg.Init(gsc_msg(310), MEDIUM_STEP); // ogni 100 "%ld entità GEOsim elaborate."
         
      result = GS_GOOD;

      // se la classe di destinazione ha la grafica in DB verifico la compatibilità
      // delle geometrie degli oggetti grafici
      if (new_cls->ptr_GphInfo()->getDataSourceType() == GSDBGphDataSource)
      {
         C_SELSET IncompatibleSS, ExplodedSS, NewSS;

         i = 0;
         while (GraphObjs.entname(i++, ent) == GS_GOOD)
         {
            // Se si vogliono importare degli oggetti non compatibili
            // in classe spaghetti provo ad esplodere gli oggetti finchè
            // si riducono in oggetti elementari (punti, linee)
            if (new_cls->ptr_GphInfo()->HasCompatibleGeom(ent, true, &ExplodedSS) == false)
            {
               C_RB_LIST Descr;
               presbuf   rb1;
               Descr << acdbEntGet(ent);
               rb1 = gsc_rbsearch(0, Descr.get_head()); // per debug

               result = GS_BAD;
               break;
            }

            if (ExplodedSS.length() > 0)
            {
               IncompatibleSS.add(ent);
               NewSS.add_selset(ExplodedSS);
            }

            if (result == GS_BAD) break;
         }

         if (result == GS_BAD) break;

         if (NewSS.length() > 0)
         {
            i = 0;
            while (NewSS.entname(i++, ent) == GS_GOOD)
            {
               if (ins_data(ent, env_variab) == GS_BAD)
                  { result = GS_BAD; break; }
               GraphObjs.add(ent);
            }

            if (result == GS_BAD) break;
         }

         GraphObjs.subtract(IncompatibleSS);
      }

      i      = 0;
      while (GraphObjs.entname(i++, ent) == GS_GOOD)
      {
         StatusLineMsg.Set(i); // "%ld entità GEOsim elaborate."

         // cerco la classe a cui appartiene l'oggetto
         if (eed.load(ent) == GS_GOOD)
         {
            // aggiorno la EED
            // L'entità viene aggiunta anche in GEOsimAppl::SAVE_SS
            eed.cls = NewCls;
            if (eed.save(ent) != GS_GOOD) { result = GS_BAD; break; }
         }
      }
      StatusLineMsg.End(gsc_msg(310), i); // "%ld entità GEOsim elaborate."
      if (result == GS_BAD) break;

      // Verifico le caratteristiche variate rispetto alla FAS originale
      BitForDiffFAS = p_old_fas->get_GraphDifferences(*p_new_fas);

      if (BitForDiffFAS != GSNoneSetting)  // cambio la FAS
      {
         // ricavo quali sono le caratteristiche grafiche modificabili della classe
         BitForChangeFAS = what_is_graph_updateable();

         // considero elevazione, rotazione
         // come caratteristiche geometriche che non vanno variate in fase di copia
         if (BitForChangeFAS & GSElevationSetting) BitForChangeFAS -= GSElevationSetting;
         if (BitForChangeFAS & GSRotationSetting) BitForChangeFAS -= GSRotationSetting;

         // Considero solo le caratteristiche variate rispetto alla FAS della 
         // classe originale
         BitForChangeFAS = BitForChangeFAS & BitForDiffFAS;

         if (gsc_modifyEntToFas(GraphObjs, p_new_fas, BitForChangeFAS) == GS_BAD)
            { result = GS_BAD; break; }
      }

      // ricavo il nome della vecchia tabella interna e la cancello
      gsc_getODTableName(OldPrj, OldCls, 0, oldtable);
      if (gsc_oddeletetab(oldtable.get_name()) != GS_GOOD) { result = GS_BAD; break; }

      // ricavo il nome della nuova tabella interna creandola se non esiste
      gsc_setODTable(NewPrj, NewCls, 0);

      // salvataggio modifiche degli oggetti nei disegni di origine
      if (new_cls->save_GeomData() == GS_BAD)
		   { result = GS_BAD; break; }
   }
   while (0);

   gsc_setVarForCommandNormal(env_variab.get_head());

   if (GS_CURRENT_WRK_SESSION) 
   {  // rilascio tutti i DWG della classe destinazione 
      // altrimenti non si potrebbe
      // ristorare il backup dei DWG che risulterebbero in uso
      new_cls->GphDetach();
      // uscita dalla sessione di lavoro
      if (gsc_ExitCurrSession() == GS_BAD) return GS_BAD;
   }

   return result;
}

                           
/*********************************************************/
/*.doc is_validfas <internal> */
/*+
  Questa funzione verifica la correttezza della C_FAS.
  Parametri (per compatibilità con C_SIMPLEX::is_validfas):
  int type;                      Tipo della classe 
  C_DBCONNECTION *pConn;         Connessione OLE-DB (usata per compatibilità)
  C_ATTRIB_LIST *p_attrib_list;  Lista attributi
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_SPAGHETTI::is_validfas(int type, C_DBCONNECTION *pConn, C_ATTRIB_LIST *p_attrib_list)
{  
   if (fas.color.getColorMethod() == C_COLOR::None) return GS_BAD;
   if (gsc_validlinetype(fas.line) == GS_BAD) return GS_BAD;
   if (gsc_validscale(fas.line_scale) == GS_BAD) return GS_BAD;
   if (gsc_validtextstyle(fas.style) == GS_BAD) return GS_BAD;
   if (gsc_validwidth(fas.width) == GS_BAD) return GS_BAD;
   if (gsc_validthickness(fas.thickness) == GS_BAD) return GS_BAD;
   if (gsc_validtextstyle(fas.style) == GS_BAD) return GS_BAD;
   if (gsc_validhtext(fas.h_text) == GS_BAD) return GS_BAD;
   if (gsc_validthickness(fas.thickness) == GS_BAD) return GS_BAD;
   if (gsc_validblock(fas.block) == GS_BAD) return GS_BAD;
   if (gsc_validscale(fas.block_scale) == GS_BAD) return GS_BAD;

   if (gsc_validhatch(fas.hatch) == GS_BAD) return GS_BAD;
   if (fas.hatch_color.getColorMethod() == C_COLOR::None) return GS_BAD;
   if (gsc_validscale(fas.hatch_scale) == GS_BAD) return GS_BAD;
   if (gsc_validlayer(fas.hatch_layer) == GS_BAD) return GS_BAD;

   // Nelle versioni precedenti non esisteva lo stile di quotatura quindi
   // se non esiste viene impostato quello di default
   if (fas.dimension_style.len() == 0) fas.dimension_style = DEFAULT_DIMSTYLE;
   if (gsc_validDimStyle(fas.dimension_style.get_name()) == GS_BAD) return GS_BAD;

   // verifico validità layer
   if (gsc_validlayer(fas.layer) == GS_BAD) return GS_BAD;
   
   return GS_GOOD;
}  


/****************************************************************************/
/*.doc C_SPAGHETTI::reportHTML                                   <external> */
/*+
  Questa funzione stampa su un file HTML i dati della C_SPAGHETTI.
  Parametri:
  FILE *file;        Puntatore a file
  const TCHAR *Path; Path del file HTML in cui si sta scrivendo. Server unicamente
                     per poter scrivere le bitmap dei blocchi nello stesso direttorio
                     del file HTML (default = NULL).
  bool SynthMode;    Opzionale. Flag di modalità di report.
                     Se = true attiva il report sintetico (default = false)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/
/******************************************************************************/
int C_SPAGHETTI::reportHTML(FILE *file, const TCHAR *Path, bool SynthMode)
{  
   if (id.reportHTML(file, SynthMode) == GS_BAD)   return GS_BAD;
   if (fas.reportHTML(this, file, Path, SynthMode) == GS_BAD)  return GS_BAD;
   if (pGphInfo)
      if (pGphInfo->reportHTML(file, SynthMode) == GS_BAD) return GS_BAD;
   if (connect_list.reportHTML(file, id.pPrj, id.code, id.sub_code,
                               SynthMode) == GS_BAD) return GS_BAD;

   return GS_GOOD;
}


/****************************************************************************/
/*.doc C_SPAGHETTI::synchronize                                  <external> */
/*+
  Questa funzione verifica che gli oggetti nei disegni siano effettivamente della
  classe.
  Parametri:
  const TCHAR *DeletedObjsDWG; Path del disegno in cui inserire gli oggetti che
                               sono stati cancellati da questa funzione
  TCHAR *NextCmd;              Stringa che identifica una eventuale chiamata 
                               ad un comando da lanciare a fine sessione 
                               (dopo il comando di "NEW"), default = NULL.
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/
/******************************************************************************/
int C_SPAGHETTI::synchronize(const TCHAR *DeletedObjsDWG, TCHAR *NextCmd)
{
   C_WRK_SESSION  WrkSession(get_pPrj());
   C_SELSET       SSEnt, SSToErase;
   C_EED          eed;
   C_RB_LIST      env_variab;
   C_STRING       session_dir, ODTableName, ODValue;
   C_INT          *pcls_2_extract;
   C_INT_LIST     cls_list_2_extract;
   int            result = GS_BAD, Prj = get_PrjId();
   long           i;
   ads_name       ent;
   TCHAR          Msg[MAX_LEN_MSG];
   C_STATUSLINE_MESSAGE StatusLineMsg(gsc_msg(1085), id.name); // "Sincronizzazione classe <%s>"

   // verifico abilitazione
   if (gsc_check_op(opSynchronizeClass) == GS_BAD) return GS_BAD;

   // Se i dati geometrici sono in tabella DB collegata
   if (ptr_GphInfo()->getDataSourceType() == GSDBGphDataSource && 
       ((C_DBGPH_INFO *) ptr_GphInfo())->LinkedTable)
         { GS_ERR_COD = eGSClassLocked; return GS_BAD; }

   // setto i valori di UNDO, BLIPMODE, HIGHLIGHT per avere massima velocità di ACAD
   if ((env_variab << gsc_setVarForCommandSpeed()) == NULL) return GS_BAD;
   gsc_disableUndoRecording(true);

   swprintf(Msg, MAX_LEN_MSG, _T("Synchronization class %d started."), id.code);  
   gsc_write_log(Msg);

   do
   {
      session_dir = _T("GEOSIM_SYNCHRONIZE_CLS");
      session_dir += id.code;
      if (WrkSession.set_name(session_dir.get_name()) == GS_BAD) break;

      session_dir = get_pPrj()->get_dir();
      session_dir += _T("\\GSSYNCHRONIZE_CLS");
      session_dir += id.code;
      if (WrkSession.set_dir(session_dir.get_name()) == GS_BAD) break;
      WrkSession.set_level(GSUpdateableData);
   
      // Alloca un oggetto C_INT
      if ((pcls_2_extract = new C_INT(id.code)) == NULL)
         { GS_ERR_COD = eGSOutOfMem; break; }
      cls_list_2_extract.add_tail(pcls_2_extract);

      // seleziono classe da estrarre, ed eseguo estrazione
      // effettuo estrazione rendendo la classe in sola lettura alle altre sessioni
      if (gsc_extract_classes((C_PROJECT *) id.pPrj,  // progetto
                              WrkSession,             // sessione di lavoro
                              cls_list_2_extract,     // lista classi
                              TRUE,                   // estrazione in esclusiva
                              NULL,                   // condizione spaziale
                              NULL,                   // condizione di proprietà
                              FALSE,                  // forma NOT oppure no
                              EXTRACTION,             // modo di estrazione
                              &SSEnt) == GS_BAD)      // gruppo di selezione estratto
         break;

      // se la classe è stata in modifica
      // (perchè bloccata da un'altra sessione di lavoro)
      if (id.abilit != GSUpdateableData) { GS_ERR_COD = eGSClassLocked; break; }

      if (gsc_callCmd(_T("_.ZOOM"), RTSTR, _T("_E"), 0) != RTNORM) break;

      // setto la tabella interna
      gsc_getODTableName(Prj, id.code, id.sub_code,
                         ODTableName);
      
      StatusLineMsg.Init(gsc_msg(310), MEDIUM_STEP); // ogni 100 "%ld entità GEOsim elaborate."

      i = 0;
      while (SSEnt.entname(i++, ent) == GS_GOOD)
      {
         // se non c'è il codice della classe o è sbagliato
         if (eed.load(ent) == GS_BAD || eed.cls != id.code)
            // Inserisco nel gruppo di oggetti da cancellare
            SSToErase.add(ent);
         else
            // ricavo ID dell'entità dalla tabella precedente
            if (gsc_getIDfromODTable(ent, ODTableName, ODValue) != GS_GOOD)
               // memorizzo identificatore nell'entità
               if (gsc_setID2ODTable(ent, ODTableName) == GS_BAD)
               {  // solo se la sorgente grafica é DWG
                  if (ptr_GphInfo()->getDataSourceType() == GSDwgGphDataSource)
                     // Inserisco nel gruppo di oggetti da cancellare
                     SSToErase.add(ent);
               }
               else
               {
                  // Segnalo l'errore su file .LOG e a video
                  swprintf(Msg, MAX_LEN_MSG, _T("Object Data corrected on entity: ODTableName %s."),
                           ODTableName.get_name());
                  gsc_write_log(Msg);
                  // "\nDati oggetto corretti per una entità: Tabella %s.\n"
                  acutPrintf(gsc_msg(86), ODTableName.get_name());

                  // Aggiungo in GEOsimAppl::SAVE_SS per salvataggio
                  gsc_addEnt2savess(ent);
               }

         StatusLineMsg.Set(i); // "%ld entità GEOsim elaborate."
      }
      StatusLineMsg.End(gsc_msg(310), i - 1); // "\r%ld entità GEOsim elaborate."
   
      if (SSToErase.length() > 0)
      {
         ads_name ss;

         // Segnalo l'errore su file .LOG e a video
         swprintf(Msg, MAX_LEN_MSG, _T("Erased some entities having wrong EED."));
         gsc_write_log(Msg);
         acutPrintf(gsc_msg(73)); // "\nAlcune entità con entità estesa errata saranno cancellate."

         if (DeletedObjsDWG)
         {  // Esporto oggetti in un file DWG cancellandoli dalla sessione
            ads_point pt;
            C_STRING  dummy(DeletedObjsDWG), ext;

            ads_point_clear(pt);

            // Controlla Correttezza Path
            if (gsc_nethost2drive(dummy) == GS_GOOD)            
            {
               C_SELSET SStoExport;

               gsc_splitpath(dummy, NULL, NULL, NULL, &ext);
               if (ext.len() == 0) dummy += _T(".DWG"); // aggiungo l'estensione "DWG"                 

               // Duplicazione oggetti principali con cancellazione link a database e
               // EED (per permettere una successiva importazione)
               i = 0;
               while (SSToErase.entname(i++, ent) == GS_GOOD)
                  if (gsc_is_DABlock(ent) == GS_BAD)
                  {
                     gsc_DeepClone2ModSpace(ent);
                     acdbEntLast(ent);
                     SStoExport.add(ent);
                     eed.clear(ent);
                  }

               if (SStoExport.length() > 0)
               {
                  SStoExport.get_selection(ss);

                  if (gsc_path_exist(dummy) == GS_GOOD)
                  {
                     if (gsc_delfile(dummy) == GS_GOOD)
                        gsc_callCmd(_T("_.WBLOCK"), RTSTR, dummy.get_name(), RTSTR, GS_EMPTYSTR, RTPOINT, pt, RTPICKS, ss, RTSTR, GS_EMPTYSTR, RTSTR, _T("_N"), 0);
                  }
                  else
                     gsc_callCmd(_T("_.WBLOCK"), RTSTR, dummy.get_name(), RTSTR, GS_EMPTYSTR, RTPOINT, pt, RTPICKS, ss, RTSTR, GS_EMPTYSTR, RTSTR, _T("_N"), 0);

                  swprintf(Msg, MAX_LEN_MSG, _T("Please, look at the <%s> file."), dummy.get_name());
                  gsc_write_log(Msg);
               }
            }
         }

         // Aggiungo in GEOsimAppl::SAVE_SS per salvataggio
         gsc_addSS2savess(SSToErase);
         
         // Prima di cancellare gli oggetti ciclo su di essi per verificare
         // se qualcuno ha una EED NON della classe in oggetto
         // in questo caso devo correggerla altrimenti il salvataggio lo considererà
         i = 0;
         while (SSToErase.entname(i++, ent) == GS_GOOD)
		      if (eed.load(ent) != GS_GOOD || eed.cls != id.code || eed.sub != 0)
            {
               eed.cls = id.code;
               eed.sub = 0;
               eed.save(ent, GS_BAD); // non aggiungo in GEOsimAppl::SAVE_SS perchè già fatto
            }

         // Cancello gli oggetti
         SSToErase.Erase();
      }

      // salvataggio della parte grafica delle entità di GEOsim
      if (save_GeomData() == GS_BAD) break;
      result = GS_GOOD;
   }
   while (0);

   swprintf(Msg, MAX_LEN_MSG, _T("Synchronization class %d terminated."), id.code);  
   gsc_write_log(Msg);

   // rispristino i valori precedenti di UNDO, BLIPMODE, HIGHLIGHT
   gsc_disableUndoRecording(false);
   gsc_setVarForCommandNormal(env_variab.get_head());

   // uscita dalla sessione di lavoro
   if (GS_CURRENT_WRK_SESSION)
   { 
      // Inizializzo queste variabili prima di chiamare gsc_ExitCurrSession che 
      // toglie dalla memoria questa classe
      TCHAR Msg[256];
      int   Cls = id.code;

      swprintf(Msg, 256, gsc_msg(289), id.name);

      // rilascio tutti i DWG della classe altrimenti non si potrebbe
      // ristorare il backup dei DWG che risulterebbero in uso
      GphDetach();

      // uscita dalla sessione di lavoro
      if (gsc_ExitCurrSession(GS_BAD, NextCmd) == GS_GOOD)
      {
         // "Messaggio GEOsim: La classe <%s> non è più in uso esclusivo."
         gsc_NotifyWaitForSave(Prj, Cls, Msg);
         gsc_NotifyWaitForExtraction(Prj, Cls, Msg);
      }
   }

   // memorizzo il codice del progetto in GEOSIM.INI
   gsc_setLastUsedPrj(Prj);

   return result;
}


/*********************************************************/
/*  FINE   FUNZIONI DELLA CATEGORIA C_SPAGHETTI          */
/*********************************************************/


/*********************************************************/
/*.doc gsc_readdef <internal> */
/*+
  Questa funzione carica i valori di default degli attributi.
  Parametri:
  C_DBCONNECTION *pConn;         Puntatore connessione OLE-DB
  C_STRING       &TableRef;      Riferimento completo alla tabella
  const TCHAR     *key_attrib;    Attributo chiave per la ricerca
  C_RB_LIST      &DefaultValues; Lista resbuf (colonna, valore)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/  
/*********************************************************/
int gsc_readdef(C_DBCONNECTION *pConn, C_STRING &TableRef, const TCHAR *key_attrib,
                C_RB_LIST &DefaultValues)
{
   C_STRING      statement, FldName(key_attrib);
   _RecordsetPtr pRs;

   if (gsc_AdjSyntax(FldName, pConn->get_InitQuotedIdentifier(), pConn->get_FinalQuotedIdentifier(),
                     pConn->get_StrCaseFullTableRef()) == GS_BAD) return GS_BAD;

   statement = _T("SELECT * FROM ");
   statement += TableRef;
   statement += _T(" WHERE ");
   statement += FldName; 
   statement += _T("=0");

   // leggo le righe della tabella senza bloccarla
   if (pConn->OpenRecSet(statement, pRs) == GS_BAD) return GS_BAD;

   if (gsc_isEOF(pRs) == GS_GOOD) // Non ci sono i valori di default
   {
      DefaultValues.remove_all();
      gsc_DBCloseRs(pRs);
      GS_ERR_COD = eGSMissingDefValue;
      return GS_BAD;
   }

   if (gsc_DBReadRow(pRs, DefaultValues) == GS_BAD)
      { gsc_DBCloseRs(pRs); return GS_BAD; }

   return gsc_DBCloseRs(pRs);
}
  

/*********************************************************/
/*.doc del_dwg <internal> */
/*+
  Questa funzione cancella il file dwg della classe.
  Parametri:
  int prj;        codice progetto
  int cls;        codice classe
  TCHAR *dir_dwg; direttorio dei DWG (in questo modo la classe può non essere
                  ancora creata; vedi cancellazione in fase di creaz. classe)
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/  
/*********************************************************/
int gsc_del_dwg(int prj, int cls, TCHAR *dir_dwg)
{
   C_DWG_LIST DwgList;
   C_DWG      *pDwg;
   C_STRING   BackUpDwg, pathfile;
   TCHAR      *separator;
   C_RB_LIST  filename_list, fileattr_list;
   presbuf    pname, pattr;

   if (!dir_dwg) { GS_ERR_COD = eGSInvalidArg; return GS_BAD; }

   if (DwgList.load(prj, cls, dir_dwg) == GS_BAD) return GS_BAD;

   pDwg = (C_DWG *) DwgList.get_head();
   while (pDwg)
   {
      if (gsc_delfile(pDwg->get_name()) == GS_BAD) return GS_BAD;
      // cancello anche altri file ausiliari
      if ((separator = wcsrchr(pDwg->get_name(), _T('.'))) != NULL)
      {
         // eventuale file di backup
         if (BackUpDwg.set_name(pDwg->get_name(), 0, (int) (separator - pDwg->get_name())) == GS_BAD)
            return GS_BAD;
         BackUpDwg += _T("BAK"); 
         if (gsc_path_exist(BackUpDwg) == GS_GOOD)
            if (gsc_delfile(BackUpDwg) == GS_BAD) return GS_BAD;
         
         // eventuale file di blocco
         if (BackUpDwg.set_name(pDwg->get_name(), 0, (int) (separator - pDwg->get_name())) == GS_BAD)
            return GS_BAD;
         BackUpDwg += _T("DWK"); 
         if (gsc_path_exist(BackUpDwg) == GS_GOOD)
            if (gsc_delfile(BackUpDwg) == GS_BAD) return GS_BAD;

         // eventuale file di informazioni
         if (BackUpDwg.set_name(pDwg->get_name(), 0, (int) (separator - pDwg->get_name())) == GS_BAD)
            return GS_BAD;
         BackUpDwg += _T("INF"); 
         if (gsc_path_exist(BackUpDwg) == GS_GOOD)
            if (gsc_delfile(BackUpDwg) == GS_BAD) return GS_BAD;
      }
      pDwg = (C_DWG *) DwgList.get_next();
   }

   // cancello anche eventuali file di dati MAP-GUIDE
   pathfile = dir_dwg;
   pathfile += _T("\\*.SDF");
   if (gsc_adir(pathfile.get_name(), &pname, NULL, NULL, &pattr) > 0)
   {
      filename_list += pname;
      fileattr_list += pattr;
   }
   // cancello anche eventuali file di indice dati MAP-GUIDE
   pathfile = dir_dwg;
   pathfile += _T("\\*.SIF");
   if (gsc_adir(pathfile.get_name(), &pname, NULL, NULL, &pattr) > 0)
   {
      filename_list += pname;
      fileattr_list += pattr;
   }
   // cancello anche eventuali file di AutoCAD
   pathfile = dir_dwg;
   pathfile += _T("\\*.MAP");
   if (gsc_adir(pathfile.get_name(), &pname, NULL, NULL, &pattr) > 0)
   {
      filename_list += pname;
      fileattr_list += pattr;
   }
   // cancello anche eventuali file di query
   pathfile = dir_dwg;
   pathfile += _T("\\*.QRY");
   if (gsc_adir(pathfile.get_name(), &pname, NULL, NULL, &pattr) > 0)
   {
      filename_list += pname;
      fileattr_list += pattr;
   }
   pname = filename_list.get_head();
   pattr = fileattr_list.get_head();
   while (pname) 
   {
      // NON è un direttorio          
      if (pname->restype == RTSTR && *(pattr->resval.rstring + 4) != _T('D'))
      {
         pathfile = dir_dwg;
         pathfile += _T('\\');
         pathfile += pname->resval.rstring;
         if (gsc_delfile(pathfile) == GS_BAD) return GS_BAD;
      }
      pname = pname->rbnext;
      pattr = pattr->rbnext;
   }

   return GS_GOOD;
}   


/*********************************************************/
/*.doc gsc_check_mod_attr <internal> */
/*+
  Questa funzione verifica la possibilità di modificare una caratteristica
  di un attributo di una tabella.


                                               SI     NO    NOME MACRO
   1  modificabilità del valore di default         0      1    BIT_MOD_DEF
   2  modificabilità della funz. di validità       0      2    BIT_MOD_VALID
   3  modificabilità della funz. calcolo           0      4    BIT_MOD_CALC
   4  modificabilità dell'obbligatorietà           0      8    BIT_MOD_MAND
   5  modificabilità della visibilità              0      16   BIT_MOD_VIS
   6  modificabilità del numero di decimali        0      32   BIT_MOD_DEC
   7  modificabilità della lunghezza               0      64   BIT_MOD_LEN
   8  modificabilità del tipo                      0      128  BIT_MOD_TYPE
   9  modificabilità del nome                      0      256  BIT_MOD_NAME
   10 possibilità di eliminazione dell'attributo   0      512  BIT_DEL_ATTR
   11 modificabilità della descrizione             0     1024  BIT_MOD_DESCR
   12 modificabilità del messaggio di errore per validità 0 2048 BIT_MOD_VALIDATION_ERR_MSG
   13 modificabilità del prefisso grafico          0     4096 BIT_MOD_GPH_PREFIX_SUFFIX
   14 modificabilità del suffisso grafico          0     4096 BIT_MOD_GPH_PREFIX_SUFFIX
   15 modificabilità della maschera di input       0     8192 BIT_MOD_INPUT_MASK
   16 modificabilità della visibilità in tooltip   0    16384 BIT_MOD_VIS_ON_TOOLTIP
   17 modificabilità dell'etichetta                0    32768 BIT_MOD_CAPTION

  Parametri:
  int prj;             codice progetto
  int cls;             codice classe
  int sub;             codice sottoclasse
  TCHAR *fieldname;     nome delll'attributo
  int bit;             numero decimale indicante il bit da verificare
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int gsc_check_mod_attr(int prj, int cls, int sub, TCHAR *fieldname, int bit)
{ 
   C_ATTRIB *pattrib;
   C_CLASS *pCls;
     
   // Ritorna il puntatore alla classe cercata
   if ((pCls = gsc_find_class(prj, cls, sub)) == NULL) return GS_BAD;
   // non valido per tipo spaghetti
   if (pCls->get_category() == CAT_SPAGHETTI)
      { GS_ERR_COD = eGSInvClassType; return GS_BAD; }
   // cerco attributo
   if ((pattrib = (C_ATTRIB*) (pCls->ptr_attrib_list())->search_name(fieldname, FALSE)) == NULL)
      { GS_ERR_COD = eGSInvAttribName; return GS_BAD; }

   if (gsc_check_mod_attr(pattrib->mod_attr, bit) == GS_BAD) return GS_BAD;

   return GS_GOOD;
}
int gsc_check_mod_attr(int flag, int bit)
{ 
   if (bit == BIT_MOD_DEF  || bit == BIT_MOD_VALID || bit == BIT_MOD_CALC ||
       bit == BIT_MOD_MAND || bit == BIT_MOD_VIS || bit == BIT_MOD_DEC ||
       bit == BIT_MOD_LEN  || bit == BIT_MOD_TYPE || bit == BIT_MOD_NAME ||
       bit == BIT_DEL_ATTR || bit == BIT_MOD_DESCR || bit == BIT_MOD_VALIDATION_ERR_MSG ||
       bit == BIT_MOD_GPH_PREFIX_SUFFIX || bit == BIT_MOD_INPUT_MASK ||
       bit == BIT_MOD_VIS_ON_TOOLTIP || bit == BIT_MOD_CAPTION)
   {
      if (flag & bit) { GS_ERR_COD = eGSInvalidOpCod; return GS_BAD; }
   }    
   else { GS_ERR_COD = eGSInvalidArg; return GS_BAD; }          

   return GS_GOOD;
}

    
/*********************************************************/
/*.doc gs_alloc_mod_stru <internal> */
/*+
  Questa funzione LISP viene usata come prima funzione per il cambiamento 
  della struttura di una tabella.
  Lista resbuf: <prj><cls>[<sub>[<sec>]]
    
  Restituisce TRUE in caso di successo altrimenti restituisce NIL.
-*/  
/*********************************************************/
int gs_alloc_mod_stru(void)
{   
   resbuf  *arg;
   int     prj, cls, sub, sec = 0;

   acedRetNil();

   // Legge nella lista dei parametri il progetto
   arg = acedGetArgs();
   if (arg_to_prj_cls_sub(&arg, &prj, &cls, &sub) == GS_BAD) return RTERROR;

   if (arg != NULL)
      if (arg->restype != RTSHORT)  // codice secondaria opzionale
         { GS_ERR_COD = eGSInvalidArg; return GS_BAD; }
      else  sec = (int) arg->resval.rint;

   if (gsc_alloc_mod_stru(prj, cls, sub, sec) == GS_BAD) return RTERROR;

   acedRetT();

   return RTNORM;
}

    
/*********************************************************/
/*.doc gsc_alloc_mod_stru <internal> */
/*+
  Questa funzione alloca una lista di sottoliste nella variabile GS_RESBUF.
  La prima contiene l'elenco originale dei nomi dei campi della tabella.
  La seconda contiene la struttura della nuova tabella.
  La terza (link) contiene coppie di nomi dei campi.
  ( (campo_1 campo_2) (descrizione struttura tabella) ((campo_1 campo_1) (campo_n campo_n)) )
  La funzione viene usata come prima funzione per il cambiamento della 
  struttura di una tabella.
  Parametri:
  int prj;             codice progetto
  int cls;             codice classe
  int sub;             codice sottoclasse
  int sec;             codice secondaria
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int gsc_alloc_mod_stru(int prj, int cls, int sub, int sec)
{
   C_RB_LIST     LinkList, ResultList;
   C_CLASS       *pCls;
   C_SECONDARY   *pSec;
   C_ATTRIB_LIST *pAttribList;
   C_ATTRIB      *pAttrib;
   int           indice = 0;
   long          SessionCode;

   // verifico abilitazione
   if (gsc_check_op(opModClass) == GS_BAD) return GS_BAD;

   if (gsc_dealloc_GS_RESBUF() == GS_BAD) return GS_BAD;

   if (sec == 0)
   {  // Ritorna il puntatore alla classe cercata
      if ((pCls = gsc_find_class(prj, cls, sub)) == NULL) return GS_BAD;
      // verifico se la classe fa parte di una sessione di lavoro
      if (pCls->is_inarea(&SessionCode) == GS_BAD || SessionCode > 0)
         { GS_ERR_COD = eGSSessionsFound; return GS_BAD; }
      if ((pAttribList = pCls->ptr_attrib_list()) == NULL)
         { GS_ERR_COD = eGSInvClassType; return GS_BAD; }
   }
   else
   {
      // Ritorna il puntatore alla tabella secondaria cercata
      if ((pSec = gsc_find_sec(prj, cls, sub, sec)) == NULL) return GS_BAD;
      if (pSec->type == GSExternalSecondaryTable) { GS_ERR_COD = eGSInvSecType; return GS_BAD; }         
      pAttribList = pSec->ptr_attrib_list();
   }

   if ((ResultList << acutBuildList(RTLB, RTLB, 0)) == NULL) return GS_BAD;
   if ((LinkList << acutBuildList(RTLB, 0)) == NULL) return GS_BAD;
   pAttrib = (C_ATTRIB *) pAttribList->get_head();
   while (pAttrib)
   {      
      // Lista dei nomi della tabella
      if ((ResultList += acutBuildList(RTSTR, pAttrib->get_name(), 0)) == NULL) return GS_BAD;
      // Lista dei link della tabella
      if ((LinkList += acutBuildList(RTLB, RTSTR, pAttrib->get_name(),
                                     RTSTR, pAttrib->get_name(), RTLE, 0)) == NULL)
         return GS_BAD;
      pAttrib = (C_ATTRIB *) pAttrib->get_next();
   }
   if ((ResultList += acutBuildList(RTLE, 0)) == NULL) return GS_BAD;
   if ((LinkList += acutBuildList(RTLE, 0)) == NULL) return GS_BAD;
   
   // Leggo la struttura della tabella
   if ((ResultList += acutBuildList(RTLB, 0)) == NULL) return GS_BAD;
   if ((ResultList += pAttribList->to_rb()) == NULL) return GS_BAD;
   if ((ResultList += acutBuildList(RTLE, 0)) == NULL) return GS_BAD;

   ResultList += LinkList.get_head();
   LinkList.ReleaseAllAtDistruction(GS_BAD);   
   if ((ResultList += acutBuildList(RTLE, 0)) == NULL) return GS_BAD;

   GS_RESBUF = ResultList.get_head();
   ResultList.ReleaseAllAtDistruction(GS_BAD);   

   return GS_GOOD;
}

    
/*********************************************************/
/*.doc gs_dealloc_mod_stru <internal> */
/*+
  Questa funzione LISP viene usata per deallocare GS_RESBUF.
    
  Restituisce TRUE in caso di successo altrimenti restituisce NIL.
-*/  
/*********************************************************/
int gs_dealloc_mod_stru(void)
{   
   acedRetNil();

   if (gsc_dealloc_GS_RESBUF() == GS_BAD) return RTERROR;

   acedRetT();

   return RTNORM;
}

    
/*********************************************************/
/*.doc gsc_dealloc_GS_RESBUF <internal> */
/*+
  Questa funzione dealloca la lista contenuta nella variabile GS_RESBUF.
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int gsc_dealloc_GS_RESBUF()
{   
   if (GS_RESBUF != NULL)
   {
      presbuf p = GS_RESBUF;

      while (p) // acutRelRb non rilascia i gruppi di selezione !
      {
         if (p->restype == RTPICKS) ads_ssfree(p->resval.rlname);
         p = p->rbnext;
      }

      acutRelRb(GS_RESBUF);
      GS_RESBUF = NULL;
   }

   return GS_GOOD;
}

    
/*********************************************************/
/*.doc gs_add_attr <internal> */
/*+
  Questa funzione LISP viene usata per aggiungere una o più colonne alla 
  struttura della tabella indicata in gsc_alloc_mod_stru.
  Lista resbuf: <name><tipo><len><dec><vis><obbl>(<file funz calc><funz calc>)
                (<file funz valid><funz valid>)<def><flag>
    
  Restituisce TRUE in caso di successo altrimenti restituisce NIL.
-*/  
/*********************************************************/
int gs_add_attr(void)
{   
   presbuf       arg, p;
   C_ATTRIB_LIST attr_list;
   
   acedRetNil();
   // Legge nella lista dei parametri il progetto
   arg = acedGetArgs();

   if (attr_list.from_rb(arg) == GS_BAD)
      { GS_ERR_COD=eGSInvalidArg; return RTERROR; }
   if ((p = gsc_scorri(arg)) != NULL && (p = p->rbnext) && p->restype == RTSHORT)
   {
      if (gsc_add_attr(&attr_list, p->resval.rint) == GS_BAD) return RTERROR;
   }  
   else
      if (gsc_add_attr(&attr_list) == GS_BAD) return RTERROR;

   acedRetT();

   return RTNORM;
}

    
/*********************************************************/
/*.doc gsc_add_attr <internal> */
/*+
  Questa funzione aggiunge colonne alla struttura della tabella della classe 
  indicata in gsc_alloc_mod_stru una lista di nuove colonne modificando 
  i resbuf puntati dalla variabile GS_RESBUF.
  Parametri:
  C_ATTRIB_LIST *p_NewAttrList;   lista delle colonne da aggiungere
  int Pos;                        Posizione in cui aggiungere (default = 0
                                  cioè in fondo); 1 = prima posizione
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int gsc_add_attr(C_ATTRIB_LIST *p_NewAttrList, int Pos)
{   
   presbuf       pstru, plink, pfldlist, p;
   C_ATTRIB_LIST struct_list, *p_copy_list;

   // verifico abilitazione
   if (gsc_check_op(opModClass) == GS_BAD) return GS_BAD;

   if (GS_RESBUF == NULL ||
       (pfldlist = gsc_nthcopy(0, GS_RESBUF)) == NULL ||
       (pstru = gsc_nth(1, GS_RESBUF)) == NULL ||
       (plink = gsc_nthcopy(2, GS_RESBUF)) == NULL ||
       struct_list.from_rb(pstru) == GS_BAD)
      { gsc_dealloc_GS_RESBUF(); GS_ERR_COD = eGSNotAllocVar; return GS_BAD; }
                    
   // aggiungo il/i nuovo/i attributo/i
   if ((p_copy_list = new C_ATTRIB_LIST) == NULL)
      { GS_ERR_COD = eGSOutOfMem; acutRelRb(plink); return GS_BAD; }

   if (p_NewAttrList->copy(p_copy_list) == GS_BAD)
      { acutRelRb(plink); return GS_BAD; }
   
   if (Pos == 0)
      struct_list.paste_tail(*p_copy_list);
   else
      struct_list.paste_before(Pos, p_copy_list);

   if (GS_RESBUF) acutRelRb(GS_RESBUF);
   if ((p = GS_RESBUF = acutBuildList(RTLB, 0)) == NULL)
      { acutRelRb(plink); GS_ERR_COD = eGSOutOfMem; return GS_BAD; }
   while (p->rbnext) p = p->rbnext;
   p->rbnext = pfldlist;
   while (p->rbnext) p = p->rbnext;
   if ((p->rbnext = acutBuildList(RTLB, 0)) == NULL)
      { acutRelRb(plink); GS_ERR_COD = eGSOutOfMem; return GS_BAD; }
   while (p->rbnext) p = p->rbnext;
   if ((p->rbnext = struct_list.to_rb()) == NULL)
      { acutRelRb(plink); GS_ERR_COD = eGSOutOfMem; return GS_BAD; }
   while (p->rbnext) p = p->rbnext;
   if ((p->rbnext = acutBuildList(RTLE, 0)) == NULL)
      { acutRelRb(plink); GS_ERR_COD = eGSOutOfMem; return GS_BAD; }
   while (p->rbnext) p = p->rbnext;
   p->rbnext = plink;
   while (p->rbnext) p = p->rbnext;
   if ((p->rbnext = acutBuildList(RTLE, 0)) == NULL)
      { GS_ERR_COD = eGSOutOfMem; return GS_BAD; }

   return GS_GOOD;
}

               
/*********************************************************/
/*.doc gs_del_attr <internal> */
/*+
  Questa funzione LISP viene usata per cancellare una o più colonne alla 
  struttura della tabella indicata in gsc_alloc_mod_stru.
    
  Restituisce TRUE in caso di successo altrimenti restituisce NIL.
-*/  
/*********************************************************/
int gs_del_attr(void)
{   
   resbuf  *arg;
   
   acedRetNil();
   // Legge nella lista dei parametri il progetto
   arg = acedGetArgs();

   if (arg == NULL) { GS_ERR_COD=eGSInvalidArg; return RTERROR; }

   if (gsc_del_attr(arg) == GS_BAD) return RTERROR;

   acedRetT();

   return RTNORM;
}

    
/*********************************************************/
/*.doc gsc_del_attr <internal> */
/*+
  Questa funzione cancella colonne alla struttura della tabella della classe
  indicata in gsc_alloc_mod_stru una lista di nuove colonne modificando
  i resbuf puntati dalla variabile GS_RESBUF.
  Parametri:
  presbuf list_colname;   lista dei nomi delle colonne da cancellare
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int gsc_del_attr(presbuf list_colname)
{   
   presbuf       pstru, plink, pstart, p, pnext, pend;
   int           indice = 0, j;
   C_ATTRIB_LIST attrib_list;
   C_ATTRIB      *p_attrib;
   TCHAR         *FieldName;
   
   // verifico abilitazione
   if (gsc_check_op(opModClass) == GS_BAD) return GS_BAD;
                              
   if (list_colname == NULL || list_colname->restype!=RTLB) // Parentesi '(' 
      { GS_ERR_COD = eGSInvRBType; return GS_BAD; }
   if (list_colname->rbnext == NULL || list_colname->rbnext->restype != RTSTR)
      { GS_ERR_COD = eGSInvRBType; return GS_BAD; } // Nome di attributo

   if (GS_RESBUF == NULL ||
       (pstru = gsc_nth(1, GS_RESBUF)) == NULL ||
       (plink = gsc_nth(2, GS_RESBUF)) == NULL) 
      { GS_ERR_COD = eGSNotAllocVar; return GS_BAD; }

   if (attrib_list.from_rb(pstru) == GS_BAD) return GS_BAD;
   
   // structure list - controllo che i nomi delle colonne siano validi
   while ((p = gsc_nth(indice++, list_colname)) != NULL)
   {                         
      if (p->restype != RTSTR) { GS_ERR_COD = eGSInvalidArg; return GS_BAD; } 
      // verifico che esista il nome dell'attributo
      if ((p_attrib = (C_ATTRIB*) attrib_list.search_name(p->resval.rstring, FALSE)) == NULL)
         { GS_ERR_COD = eGSInvAttribName; return GS_BAD; }
      // verifico flag di modificabilità
      if (gsc_check_mod_attr(p_attrib->mod_attr, BIT_DEL_ATTR) == GS_BAD)
         { GS_ERR_COD = eGSInvalidOpCod; return GS_BAD; }
      // cancello attributo dalla lista
      attrib_list.remove_at();
   }

   // structure list
   indice = 0;
   while ((pstart = gsc_nth(indice++, list_colname)) != NULL)
   {
      FieldName = pstart->resval.rstring;

      // cerco attributo nella vecchia struttura
      j = 0;
      p = NULL;
      while ((pstart = gsc_nth(j++, pstru)) != NULL)
         if ((p = gsc_CdrAssoc(_T("ATTRIB"), pstart, FALSE)) != NULL && 
             p->restype == RTSTR && 
             gsc_strcmp(p->resval.rstring, FieldName, FALSE) == 0)
            break;

      p = pstart->rbnext;
      if ((pend = gsc_scorri(pstart)) == NULL)
         { gsc_dealloc_GS_RESBUF(); return GS_BAD; }
      if ((pnext = pend->rbnext) == NULL)
         { gsc_dealloc_GS_RESBUF(); return GS_BAD; }
        
      pstart->restype = (pnext->restype == RTLB) ? RTLB : RTLE;

      pstart->rbnext = pnext->rbnext;
      pend->rbnext = NULL;
      acutRelRb(p);
   }
      
   // link list
   indice = 0;
   while ((pstart = gsc_nth(indice++, list_colname)) != NULL)
   {                
      if ((pstart = gsc_assoc(pstart->resval.rstring, plink)) == NULL) continue;
      p = pstart->rbnext;
      if ((pend = gsc_scorri(pstart)) == NULL)
         { gsc_dealloc_GS_RESBUF(); return GS_BAD; }
      if ((pnext = pend->rbnext) == NULL)
         { gsc_dealloc_GS_RESBUF(); return GS_BAD; }
      
      pstart->restype = (pnext->restype == RTLB) ? RTLB : RTLE;

      pstart->rbnext = pnext->rbnext;
      pend->rbnext = NULL;
      acutRelRb(p);
   }

   return GS_GOOD;
}

               
/*********************************************************/
/*.doc gs_mod_attr <internal> */
/*+
  Questa funzione LISP viene usata per modificare una o più colonne della 
  struttura della tabella indicata in gsc_alloc_mod_stru.
    
  Restituisce TRUE in caso di successo altrimenti restituisce NIL.
-*/  
/*********************************************************/
int gs_mod_attr(void)
{   
   resbuf  *arg;
   C_ATTRIB_LIST attr_list;
   
   acedRetNil();
   // Legge nella lista dei parametri il progetto
   arg = acedGetArgs();

   if (arg == NULL) { GS_ERR_COD=eGSInvalidArg;  return RTERROR; }

   if (gsc_mod_attr(arg) == GS_BAD) return RTERROR;

   acedRetT();

   return RTNORM;
}

    
/*********************************************************/
/*.doc gsc_mod_attr <internal> */
/*+
  Questa funzione modifica colonne della struttura della tabella della classe
  indicata in gsc_alloc_mod_stru una lista di nuove colonne modificando
  i resbuf puntati dalla variabile GS_RESBUF.
  Parametri:
  presbuf lista;   lista dei nomi delle colonne da modificare
  ( (nome colonna (nuova struttura)) (nome colonna (nuova struttura)) )

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int gsc_mod_attr(presbuf lista)
{
   presbuf       pstru, pnewstru, plink, pstart, pattr, pnext, pend, p, pFldList;
   int           indice = 0, j;
   TCHAR         *fieldname, *newfieldname;
   C_ATTRIB_LIST attrib_list;
   C_ATTRIB      *p_attrib, NewField;
   
   // verifico abilitazione
   if (gsc_check_op(opModClass) == GS_BAD) return GS_BAD;

   if (GS_RESBUF == NULL ||
       (pFldList = gsc_nth(0, GS_RESBUF)) == NULL ||
       (pstru = gsc_nth(1, GS_RESBUF)) == NULL ||
       (plink = gsc_nth(2, GS_RESBUF)) == NULL) 
      { GS_ERR_COD = eGSNotAllocVar; return GS_BAD; }
   
   if (attrib_list.from_rb(pstru) == GS_BAD) return GS_BAD;

   // ciclo di controllo per modificabilità attributi
   while ((pattr = gsc_nth(indice++, lista)) != NULL)
   {               
      // nome vecchio attributo
      if ((p = gsc_nth(0, pattr)) == NULL || p->restype != RTSTR)
         { GS_ERR_COD = eGSInvalidArg; return GS_BAD; } 
      fieldname = p->resval.rstring;
      // verifico che esista il nome dell'attributo nella vecchia struttura
      if ((p_attrib = (C_ATTRIB*) attrib_list.search_name(fieldname, FALSE)) == NULL)
         { GS_ERR_COD = eGSInvAttribName; return GS_BAD; }
         
      // nuova struttura
      if ((pnewstru = gsc_nth(1, pattr)) == NULL)
         { GS_ERR_COD = eGSInvalidArg; return GS_BAD; }

      if (NewField.from_rb(pnewstru) == GS_BAD) return GS_BAD;

      // se si vuole modificare il nome
      if (NewField.name.comp(fieldname, FALSE) != 0)
         if (gsc_check_mod_attr(p_attrib->mod_attr, BIT_MOD_NAME) == GS_BAD)
            { GS_ERR_COD = eGSInvalidOpCod; return GS_BAD; }

      // se si vuole modificare l'etichetta
      if (p_attrib->Caption.len() > 0 && NewField.Caption.len() > 0 &&
         p_attrib->Caption.comp(NewField.Caption) != 0)
         if (gsc_check_mod_attr(p_attrib->mod_attr, BIT_MOD_CAPTION) == GS_BAD)
            { GS_ERR_COD = eGSInvalidOpCod; return GS_BAD; }

      // se si vuole modificare il tipo dell'attributo
      if (gsc_strcmp(p_attrib->type, NewField.type) != 0)
         if (gsc_check_mod_attr(p_attrib->mod_attr, BIT_MOD_TYPE) == GS_BAD)
            { GS_ERR_COD = eGSInvalidOpCod; return GS_BAD; }

      // se si vuole modificare la lunghezza dell'attributo
      if (p_attrib->len != NewField.len)
         if (gsc_check_mod_attr(p_attrib->mod_attr, BIT_MOD_LEN) == GS_BAD)
            { GS_ERR_COD = eGSInvalidOpCod; return GS_BAD; }

      // se si vuole modificare i decimali dell'attributo 
      // (qualora siano supportati dal tipo quindi diversi da -1)
      if (p_attrib->dec != NewField.dec && NewField.dec != -1)
         if (gsc_check_mod_attr(p_attrib->mod_attr, BIT_MOD_DEC) == GS_BAD)
            { GS_ERR_COD = eGSInvalidOpCod; return GS_BAD; }

      // se si vuole modificare la visibilità dell'attributo
      if (p_attrib->vis != NewField.vis)
         if (gsc_check_mod_attr(p_attrib->mod_attr, BIT_MOD_VIS) == GS_BAD)
            { GS_ERR_COD = eGSInvalidOpCod; return GS_BAD; }

      // se si vuole modificare la visibilità dell'attributo
      if (p_attrib->VisOnTooltip != NewField.VisOnTooltip)
         if (gsc_check_mod_attr(p_attrib->mod_attr, BIT_MOD_VIS_ON_TOOLTIP) == GS_BAD)
            { GS_ERR_COD = eGSInvalidOpCod; return GS_BAD; }

      // se si vuole modificare la obbligatorietà dell'attributo
      if (p_attrib->man != NewField.man)
         if (gsc_check_mod_attr(p_attrib->mod_attr, BIT_MOD_MAND) == GS_BAD)
            { GS_ERR_COD = eGSInvalidOpCod; return GS_BAD; }

      // se si vuole modificare la calcolabilità verifico flag di modificabilità
      if (gsc_strcmp(p_attrib->calc_file, NewField.calc_file) != 0 ||
          gsc_strcmp(p_attrib->calc_func, NewField.calc_func) != 0)
            if (gsc_check_mod_attr(p_attrib->mod_attr, BIT_MOD_CALC) == GS_BAD)
               { GS_ERR_COD = eGSInvalidOpCod; return GS_BAD; }

      // se si vuole modificare la validità verifico flag di modificabilità
      if (gsc_strcmp(p_attrib->valid_file, NewField.valid_file) != 0 ||
          gsc_strcmp(p_attrib->valid_func, NewField.valid_func) != 0)
            if (gsc_check_mod_attr(p_attrib->mod_attr, BIT_MOD_CALC) == GS_BAD)
               { GS_ERR_COD = eGSInvalidOpCod; return GS_BAD; }

      // se si vuole modificare il default verifico flag di modificabilità
      if (gsc_equal(p_attrib->def, NewField.def) == GS_BAD)
         if (gsc_check_mod_attr(p_attrib->mod_attr, BIT_MOD_DEF) == GS_BAD)
            { GS_ERR_COD = eGSInvalidOpCod; return GS_BAD; }

      // se si vuole modificare la descrizione dell'attributo
      if (p_attrib->Descr.len() > 0 && NewField.Descr.len() > 0 &&
          p_attrib->Descr.comp(NewField.Descr) != 0)
         if (gsc_check_mod_attr(p_attrib->mod_attr, BIT_MOD_DESCR) == GS_BAD)
            { GS_ERR_COD = eGSInvalidOpCod; return GS_BAD; }

      // se si vuole modificare la descrizione dell'attributo
      if ((p_attrib->ValidErrMsg.len() > 0 || NewField.ValidErrMsg.len() > 0) &&
          p_attrib->ValidErrMsg.comp(NewField.ValidErrMsg) != 0)
         if (gsc_check_mod_attr(p_attrib->mod_attr, BIT_MOD_VALIDATION_ERR_MSG) == GS_BAD)
            { GS_ERR_COD = eGSInvalidOpCod; return GS_BAD; }

      // se si vuole modificare il prefisso grafico dell'attributo
      if ((p_attrib->GphPrefix.len() > 0 || NewField.GphPrefix.len() > 0) &&
          p_attrib->GphPrefix.comp(NewField.GphPrefix) != 0)
         if (gsc_check_mod_attr(p_attrib->mod_attr, BIT_MOD_GPH_PREFIX_SUFFIX) == GS_BAD)
            { GS_ERR_COD = eGSInvalidOpCod; return GS_BAD; }

      // se si vuole modificare il suffisso grafico dell'attributo
      if ((p_attrib->GphSuffix.len() > 0 || NewField.GphSuffix.len() > 0) &&
          p_attrib->GphSuffix.comp(NewField.GphSuffix) != 0)
         if (gsc_check_mod_attr(p_attrib->mod_attr, BIT_MOD_GPH_PREFIX_SUFFIX) == GS_BAD)
            { GS_ERR_COD = eGSInvalidOpCod; return GS_BAD; }

      // se si vuole modificare la maschera di input dati dell'attributo
      if ((p_attrib->InputMask.len() > 0 || NewField.InputMask.len() > 0) &&
          p_attrib->InputMask.comp(NewField.InputMask) != 0)
         if (gsc_check_mod_attr(p_attrib->mod_attr, BIT_MOD_INPUT_MASK) == GS_BAD)
            { GS_ERR_COD = eGSInvalidOpCod; return GS_BAD; }

      if (p_attrib->set(&NewField) == GS_BAD) return GS_BAD;
   }

   indice = 0;
   // ciclo per ogni campo da modificare
   while ((pattr = gsc_nth(indice++, lista)) != NULL)
   {               
      // nome vecchio attributo
      if ((p = gsc_nth(0, pattr)) == NULL || p->restype != RTSTR)
         { GS_ERR_COD = eGSInvalidArg; return GS_BAD; } 
      fieldname = p->resval.rstring;
         
      // nuova struttura
      if ((pnewstru = gsc_nthcopy(1, pattr)) == NULL)
      {
         GS_ERR_COD = eGSInvalidArg; 
         gsc_dealloc_GS_RESBUF(); 
         return GS_BAD;
      }

      // nome nuovo attributo
      if ((p = gsc_CdrAssoc(_T("ATTRIB"), pnewstru, FALSE)) == NULL || p->restype != RTSTR)
      {
         GS_ERR_COD = eGSInvalidArg; 
         gsc_dealloc_GS_RESBUF();
         acutRelRb(pnewstru); 
         return GS_BAD;
      }
      newfieldname = p->resval.rstring;

      // cerco attributo nella vecchia struttura
      j = 0;
      p = NULL;
      while ((pstart = gsc_nth(j++, pstru)) != NULL)
         if ((p = gsc_CdrAssoc(_T("ATTRIB"), pstart, FALSE)) != NULL && 
             p->restype == RTSTR && 
             gsc_strcmp(p->resval.rstring, fieldname, GS_BAD) == 0)
            break;

      if (!p)
      { 
         gsc_dealloc_GS_RESBUF(); 
         GS_ERR_COD = eGSInvAttribName;
         return GS_BAD;
      }

      p = pstart->rbnext;
      if ((pend = gsc_scorri(pstart)) == NULL)
         { gsc_dealloc_GS_RESBUF(); return GS_BAD; }
      if ((pnext = pend->rbnext) == NULL)
         { gsc_dealloc_GS_RESBUF(); return GS_BAD; }

      pstart->rbnext = pnewstru->rbnext;
      pstart = pnewstru;
      // vado in fondo
      while (pstart->rbnext != NULL) pstart = pstart->rbnext;

      pstart->rbnext = pnext;
      pend->rbnext = NULL;
      acutRelRb(p);
      pnewstru->rbnext = NULL;
      acutRelRb(pnewstru);

      // link list
      if ((pstart = gsc_assoc(fieldname, plink)) != NULL)
      { // già esisteva in lista
         pstart = pstart->rbnext;
         free(pstart->resval.rstring); 
         if ((pstart->resval.rstring = gsc_tostring(newfieldname)) == NULL)
            { gsc_dealloc_GS_RESBUF(); return GS_BAD; }
      }              
      else
      { // non esisteva in lista
         if ((pstart = gsc_assoc(fieldname, pFldList)) != NULL)
         { // se faceva parte della struttura originale della tabella
            if ((p = acutBuildList(RTSTR, newfieldname, 
                                   RTSTR, fieldname,
                                   RTLE, RTLE, 0)) == NULL)
               { gsc_dealloc_GS_RESBUF(); return GS_BAD; }
            if ((pend = gsc_scorri(plink)) == NULL)
               { gsc_dealloc_GS_RESBUF(); return GS_BAD; }
            if ((pnext = pend->rbnext) == NULL)
               { gsc_dealloc_GS_RESBUF(); return GS_BAD; }
            pend->restype = RTLB;   
            pend->rbnext = p;
            p->rbnext->rbnext->rbnext->rbnext = pnext;
         }
      }   
   }

   return GS_GOOD;
}


/*********************************************************/
/*.doc gsc_getextclasstypes <external> */
/*+
  Questa funzione restituisce la lista delle tipologie di classi di entita
  sotto forma di lista.
  ((categoria tipo name)(categoria tipo name) ...)
-*/  
/*********************************************************/
presbuf gsc_getextclasstypes(void)
{
   presbuf  lista, p;
   int      i = 1;
   TCHAR    sez[SEZ_PROFILE_LEN], *desc = NULL;
   C_STRING path;

   path = GEOsimAppl::GEODIR;
   path += _T('\\');
   path += GEOEXT;
   path += _T('\\');
   path += GEOEXTERN;
   if ((p = lista = acutBuildList(RTLB, 0)) == NULL)
      { GS_ERR_COD = eGSOutOfMem; return NULL; }

   swprintf(sez, SEZ_PROFILE_LEN, _T("%d"), i);
   while (gsc_get_profile(path.get_name(), sez, _T("DESC"), &desc, 0, 0) != GS_BAD)
   {
      if ((p->rbnext = acutBuildList(RTLB,
                                     RTSHORT, CAT_EXTERN, // categoria
                                     RTSHORT, i ,         // tipo
                                     RTSTR, desc,         // nome tipologia
                                     RTLE, 0)) == NULL)
         { acutRelRb(lista); free(desc); GS_ERR_COD = eGSOutOfMem; return NULL; }
      while (p->rbnext != NULL) p = p->rbnext;
      free(desc); desc = NULL;
      i++;
      swprintf(sez, SEZ_PROFILE_LEN, _T("%d"), i);
   }
   if ((p->rbnext = acutBuildList(RTLE, 0)) == NULL)
      { GS_ERR_COD = eGSOutOfMem; return NULL; }

   return lista;
}


/*********************************************************/
/*.doc gs_getlisttypeclass <external> */
/*+
  Questa funzione restituisce la lista delle tipologie di classi di entita sotto forma di lista.
  Parametri
  [External Data]
  External Data = se T significa che si vuole la lista dei tipi di classi GEOsim 
                  che supportano il collegamento a dati esterni già esistenti. 
                  In tutti gli altri casi si vuole la lista di tutti i tipi 
                  di classi GEOsim (default nil)
  Ritorna
  ((tip1 cat1 descr1)(tip2 cat2 descr2) ...)
-*/  
/*********************************************************/
int gs_getlisttypeclass(void)
{
   presbuf   arg;
   C_RB_LIST ret;
   bool      ExternalData = false;

   if ((arg = acedGetArgs()) && arg->restype == RTT) ExternalData = true;

   ret = gsc_getlisttypeclass(ExternalData);
   ret.LspRetList();

   return RTNORM;
}


/*********************************************************/
/*.doc gsc_getlisttypeclass <external> */
/*+
  Questa funzione restituisce la lista delle tipologie di classi di entita sotto forma di lista.
  Parametri:
  bool ExternalData; Se true significa che si vuole la lista dei tipi di classi GEOsim 
                     che supportano il collegamento a dati esterni già esistenti 
                     altrimenti si vuole la lista di tutti i tipi di classi GEOsim
                     (default = false)

  Ritorna
  ((cat1 tip1 descr1)(cat2 tip2 descr2) ...)
-*/  
/*********************************************************/
presbuf gsc_getlisttypeclass(bool ExternalData)
{
   C_RB_LIST list;

   if (ExternalData)
   {
      // non possono esserci chiamate multiple a gsc_msg nella stessa funzione perchè
      // tutte le chiamate restituirebbero un puntatore allo stesso vettore globale (GS_MSG)
      if ((list << acutBuildList(RTLB,
                                    RTSHORT, CAT_SIMPLEX,
                                    RTSHORT, TYPE_POLYLINE,
                                    RTSTR, gsc_msg(68),      // "Polilinea"
                                 RTLE, 0)) == NULL) return GS_BAD;
      if ((list += acutBuildList(RTLB,
                                    RTSHORT, CAT_SIMPLEX,
                                    RTSHORT, TYPE_TEXT,
                                    RTSTR, gsc_msg(14),      // "Testo"
                                 RTLE, 0)) == NULL) return GS_BAD;
      if ((list += acutBuildList(RTLB,
                                    RTSHORT, CAT_SIMPLEX,
                                    RTSHORT, TYPE_NODE,
                                    RTSTR, gsc_msg(530),     // "Nodo"
                                 RTLE, 0)) == NULL) return GS_BAD;
      if ((list += acutBuildList(RTLB,
                                    RTSHORT, CAT_SIMPLEX,
                                    RTSHORT, TYPE_SURFACE,
                                    RTSTR, gsc_msg(535),     // "Superficie"
                                 RTLE, 0)) == NULL) return GS_BAD;
      if ((list += acutBuildList(RTLB,
                                    RTSHORT, CAT_SPAGHETTI,
                                    RTSHORT, TYPE_SPAGHETTI,
                                    RTSTR, gsc_msg(534),    // "Spaghetti"
                                 RTLE, 0)) == NULL) return GS_BAD;
   }
   else
   {
      presbuf lista_ext;

      // non possono esserci chiamate multiple a gsc_msg nella stessa funzione perchè
      // tutte le chiamate restituirebbero un puntatore allo stesso vettore globale (GS_MSG)
      if ((list << acutBuildList(RTLB,
                                    RTSHORT, CAT_SIMPLEX,
                                    RTSHORT, TYPE_POLYLINE,
                                    RTSTR, gsc_msg(68),      // "Polilinea"
                                 RTLE, 0)) == NULL) return GS_BAD;
      if ((list += acutBuildList(RTLB,
                                    RTSHORT, CAT_SIMPLEX,
                                    RTSHORT, TYPE_TEXT,
                                    RTSTR, gsc_msg(14),      // "Testo"
                                 RTLE, 0)) == NULL) return GS_BAD;
      if ((list += acutBuildList(RTLB,
                                    RTSHORT, CAT_SIMPLEX,
                                    RTSHORT, TYPE_NODE,
                                    RTSTR, gsc_msg(530),     // "Nodo"
                                 RTLE, 0)) == NULL) return GS_BAD;
      if ((list += acutBuildList(RTLB,
                                    RTSHORT, CAT_SIMPLEX,
                                    RTSHORT, TYPE_SURFACE,
                                    RTSTR, gsc_msg(535),     // "Superficie"
                                 RTLE, 0)) == NULL) return GS_BAD;
      if ((list += acutBuildList(RTLB,
                                    RTSHORT, CAT_GRID,
                                    RTSHORT, TYPE_GRID,
                                    RTSTR, gsc_msg(531),     // "Griglia"
                                 RTLE, 0)) == NULL) return GS_BAD;
      if ((list += acutBuildList(RTLB,
                                    RTSHORT, CAT_GROUP,
                                    RTSHORT, TYPE_GROUP,
                                    RTSTR, gsc_msg(533),     // "Gruppo"
                                 RTLE, 0)) == NULL) return GS_BAD;
      if ((list += acutBuildList(RTLB,
                                    RTSHORT, CAT_SPAGHETTI,
                                    RTSHORT, TYPE_SPAGHETTI,
                                    RTSTR, gsc_msg(534),    // "Spaghetti"
                                 RTLE, 0)) == NULL) return GS_BAD;

      lista_ext = gsc_getextclasstypes();
      list += gsc_rbforlsp(&lista_ext); // tolgo prima e ultima tonda
   }

   list.ReleaseAllAtDistruction(GS_BAD);

   return list.get_head();
}


/*********************************************************/
/*.doc gs_getdefaultattr <external> */
/*+
  Restituisce la lista degli attributi di default di una classe con
  collegamento OLE-DB noto e di categoria e tipo conosciuti.
  Parametri:
  (("UDL_FILE" <file UDL> || <stringa di connessione>) ("UDL_PROP" <value>)
   ("CATEGORY" <categoria>) ("TYPE" <tipo>))
                                                
-*/  
/*********************************************************/
int gs_getdefaultattr(void)
{
   int            catalog, type;
   presbuf        arg = acedGetArgs(), p;
   C_DBCONNECTION *pConn;

   acedRetNil();

   if ((pConn = gsc_getConnectionFromLisp(arg)) == NULL) return RTERROR;

   if ((p = gsc_CdrAssoc(_T("CATEGORY"), arg, FALSE)) == NULL) return RTERROR;
   if (gsc_rb2Int(p, &catalog) == GS_BAD) return RTERROR;

   if ((p = gsc_CdrAssoc(_T("TYPE"), arg, FALSE)) == NULL) return RTERROR;
   if (gsc_rb2Int(p, &type) == GS_BAD) return RTERROR;

   if (gsc_getdefaultattr(pConn, catalog, type, &p) == GS_GOOD)
   {
      C_RB_LIST ret(p);
      ret.LspRetList();
   }

   return RTNORM;
}


/*********************************************************/
/*.doc gsc_getdefaultattr <external> */
/*+
  Restituisce la lista degli attributi di default per un tipo di classe noto
  nel seguente formato:
  ((<nome><tipo><len><dec><vis><obbl>(<calc_file><calc_funz>)(<val_file><val_funz>)
   <default><flags><descrizione><msg.validità><prefisso gph><suffisso gph><mask>)
   ...
  )

  Parametri:
  C_DBCONNECTION *pConn;   Puntatore connessione OLE-DB
  int categoria            Categoria della classe
  int type                 Tipo della classe
  presbuf *result_list;    Risultato

  Il valore di flags è un numero intero codificato nel seguente modo:

                                                               SI     NO
  modifibabilità del valore di default                         0      1
  modificabilità della funz. di validità                       0      2 
  modificabilità della funz. calcolo                           0      4
  modificabilità dell'obbligatorietà                           0      8
  modificabilità della visibilità                              0      16
  modificabilità del numero di decimali                        0      32
  modificabilità della lunghezza                               0      64
  modificabilità del tipo                                      0      128
  modificabilità del nome                                      0      256
  possibilità di eliminazione dell'attributo                   0      512
  modificabilità della descrizione                             0      1024
  modificabilità del messaggio di errore per validità          0      2048
  modificabilità del prefisso grafico                          0      4096
  modificabilità del suffisso grafico                          0      4096
  modificabilità dell maschera di input                        0      8192
-*/  
/*********************************************************/
int gsc_getdefaultattr(C_DBCONNECTION *pConn, int categoria, int type,
                       presbuf *result_list)
{
   C_RB_LIST List;
   long      len;
   int       dec;
   C_STRING  ProviderDescr;
   C_ATTRIB  KeyAttrib, TextAttrib;

   // converto campo da codice ADO in Provider dipendente (numero intero)
   if (pConn->Type2ProviderType(CLASS_KEY_TYPE_ENUM, // DataType per campo chiave
                                FALSE,               // IsLong
                                FALSE,               // IsFixedPrecScale
                                RTT,                 // IsFixedLength
                                TRUE,                // IsWrite
                                CLASS_LEN_KEY_ATTR,  // Size
                                0,                   // Prec
                                ProviderDescr,       // ProviderDescr
                                &len, &dec) == GS_BAD)
      return GS_BAD;

   KeyAttrib.name    = DEFAULT_KEY_ATTR;
   if (pConn->IsValidFieldName(KeyAttrib.name) == GS_BAD) return GS_BAD;

   KeyAttrib.Caption = DEFAULT_KEY_ATTR;
   gsc_strcpy(KeyAttrib.type, ProviderDescr.get_name(), MAX_LEN_FIELDTYPE);
   KeyAttrib.len = len;
   KeyAttrib.dec = dec;
   KeyAttrib.def = acutBuildList(RTSHORT, 0, 0);
   KeyAttrib.mod_attr = BIT_MOD_INPUT_MASK+  // no modifica maschera di input
                        BIT_MOD_VALIDATION_ERR_MSG+ // no modifica messaggio errore per validità
                        BIT_DEL_ATTR+        // non cancellabile
                        BIT_MOD_NAME+        // no modifica nome
                        BIT_MOD_TYPE+        // no modifica tipo
                        BIT_MOD_DEC+         // no modifica decimali
                        BIT_MOD_MAND+        // no modifica obbligatorietà
                        BIT_MOD_CALC+        // no modifica calcolato
                        BIT_MOD_VALID+       // no modifica validità
                        BIT_MOD_DEF;         // no modifica default
   KeyAttrib.Descr = gsc_msg(795); // "Codice GEOsim univoco per l'entità"

   if (!(List << KeyAttrib.to_rb())) return GS_BAD;

   switch (categoria)
   {
      case CAT_SIMPLEX:
         switch(type)
         {
            case TYPE_TEXT:
            {
               C_PROVIDER_TYPE *providerType;
               if ((providerType = pConn->getCharProviderType()) == NULL) return GS_BAD;

               // converto campo da codice ADO in Provider dipendente (testo)
               if (pConn->Type2ProviderType(providerType->get_Type(), // DataType per campo testo
                                            FALSE,          // IsLong
                                            FALSE,          // IsFixedPrecScale
                                            RTNIL,          // IsFixedLength
                                            TRUE,           // IsWrite
                                            LEN_TEXT_ATTR,  // Size
                                            0,              // Prec
                                            ProviderDescr,  // ProviderDescr
                                            &len, &dec) == GS_BAD)
                  return GS_BAD;
               
               TextAttrib.name    = DEFAULT_TEXT_ATTR;
               if (pConn->IsValidFieldName(TextAttrib.name) == GS_BAD) return GS_BAD;

               TextAttrib.Caption = DEFAULT_TEXT_ATTR;
               gsc_strcpy(TextAttrib.type, ProviderDescr.get_name(), MAX_LEN_FIELDTYPE);
               TextAttrib.len = len;
               TextAttrib.dec = dec;
               TextAttrib.vis = VISIBLE;
               TextAttrib.man = GS_GOOD;
               TextAttrib.def = acutBuildList(RTSTR, _T("?"), 0);
               TextAttrib.mod_attr = BIT_DEL_ATTR+        // non cancellabile
                                     BIT_MOD_NAME+        // no modifica nome
                                     BIT_MOD_TYPE+        // no modifica tipo
                                     BIT_MOD_DEC+         // no modifica decimali
                                     BIT_MOD_VIS+         // no modifica visibilità
                                     BIT_MOD_MAND;        // no modifica obbligatorietà
               TextAttrib.Descr = gsc_msg(796); // "Valore del testo da visualizzare"

               if (!(List += TextAttrib.to_rb())) return GS_BAD;

               break;
            }
            case TYPE_POLYLINE:
            case TYPE_NODE:
            case TYPE_SURFACE:
               break;
            default:
               return GS_BAD;
         }
         break;
      case CAT_GROUP:
         if (type != TYPE_GROUP) return GS_BAD;
         break;
      case CAT_GRID:
         if (type != TYPE_GRID) return GS_BAD;
         break;
      case CAT_EXTERN:
         break;
      case CAT_SPAGHETTI:
         if (type != TYPE_SPAGHETTI) return GS_BAD;
         break;
      case CAT_SECONDARY:
         if (type == GSExternalSecondaryTable) return GS_BAD;
         break;
   }
   *result_list = List.get_head();
   List.ReleaseAllAtDistruction(GS_BAD);

   return GS_GOOD;
}


/*********************************************************/
/*.doc gs_getAttrListFromBlock                <external> */
/*+
  Funzione LISP che restituisce la lista degli attributi letti da un
  blocco autocad con attributi convertiti nel collegamento OLE-DB noto.
  Parametri:
  (<OLE_DB conn><BlockName>)
  dove
  <OLE_DB conn> = (("UDL_FILE" <Connection>) ("UDL_PROP" <Properties>))
  <Connection>  = <file UDL> | <stringa di connessione>
  <Properties>  = stringa delle proprietà | ((<prop1><value>)(<prop1><value>)...)
                                                
-*/  
/*********************************************************/
int gs_getAttrListFromBlock(void)
{
   presbuf        arg = acedGetArgs();
   C_RB_LIST      ret;
   C_DBCONNECTION *pConn;
   C_ATTRIB_LIST  AttribList;

   acedRetNil();

   if ((pConn = gsc_getConnectionFromLisp(arg)) == NULL) return RTERROR;
   // BLOCK
   if (!(arg = gsc_nth(1, arg)) || arg->restype != RTSTR) { GS_ERR_COD = eGSInvalidArg; return RTERROR; }

   if (AttribList.from_Block(pConn, arg->resval.rstring) == GS_BAD) return RTERROR;
   if ((ret << AttribList.to_rb()))
      ret.LspRetList();

   return RTNORM;
}


/*********************************************************/
/*.doc gs_getAttrListFromOD                   <external> */
/*+
  Funzione LISP che restituisce la lista degli attributi letti da una tabella
  Object Data convertiti nel collegamento OLE-DB noto.
  Parametri:
  (<OLE_DB conn><OD TableName>)
  dove
  <OLE_DB conn> = (("UDL_FILE" <Connection>) ("UDL_PROP" <Properties>))
  <Connection>  = <file UDL> | <stringa di connessione>
  <Properties>  = stringa delle proprietà | ((<prop1><value>)(<prop1><value>)...)
-*/  
/*********************************************************/
int gs_getAttrListFromOD(void)
{
   presbuf        arg = acedGetArgs();
   C_RB_LIST      ret;
   C_DBCONNECTION *pConn;
   C_ATTRIB_LIST  AttribList;

   acedRetNil();

   if ((pConn = gsc_getConnectionFromLisp(gsc_nth(0, arg))) == NULL) return RTERROR;
   // OD_TABLE
   if (!(arg = gsc_nth(1, arg)) || arg->restype != RTSTR) { GS_ERR_COD = eGSInvalidArg; return RTERROR; }

   if (AttribList.from_OD(pConn, arg->resval.rstring) == GS_BAD) return RTERROR;
   if ((ret << AttribList.to_rb()))
      ret.LspRetList();

   return RTNORM;
}


/*********************************************************/
/*.doc gs_getAttrListFromDB                   <external> */
/*+
  Funzione LISP che restituisce la lista degli attributi letti da una tabella
  di database di un collegamento DB trasformata in un altro collegamento 
  OLE-DB noto.
  Parametri:
  (<OLE_DB conn dst> <OLE_DB conn src>)
  dove:
  <OLE_DB conn src> = <OLE_DB table conn>
  <OLE_DB conn dst> = <OLE_DB conn>
  <OLE_DB table conn> = (("UDL_FILE" <Connection>) ("UDL_PROP" <Properties>) ("TABLE_REF" <TableRef>))
  <OLE_DB conn> = (("UDL_FILE" <Connection>) ("UDL_PROP" <Properties>))
  <Connection>  = <file UDL> | <stringa di connessione>
  <Properties>  = stringa delle proprietà | ((<prop1><value>)(<prop1><value>)...)
  <TableRef>   = riferimento completo tabella | (<cat><schema><tabella>)                                               
-*/  
/*********************************************************/
int gs_getAttrListFromDB(void)
{
   presbuf        arg = acedGetArgs();
   C_RB_LIST      ret;
   C_DBCONNECTION *pDstConn, *pSrcConn;
   C_STRING       FullRefTable;
   C_ATTRIB_LIST  AttribList;

   acedRetNil();

   // destination
   if ((pDstConn = gsc_getConnectionFromLisp(gsc_nth(0, arg))) == NULL) return RTERROR;
   // source
   if ((pSrcConn = gsc_getConnectionFromLisp(gsc_nth(1, arg), &FullRefTable)) == NULL) return RTERROR;

   if (AttribList.from_DB(pDstConn, pSrcConn, FullRefTable.get_name()) == GS_BAD) 
      return RTERROR;
   if ((ret << AttribList.to_rb()))
      ret.LspRetList();

   return RTNORM;
}


/*********************************************************/
/*.doc gsc_NoGraphCharact2attriblist          <external> */
/*+
  Questa funzione carica su una C_ATTRIB_LIST precedentemente gia'
  inizializzata con almeno i nomi degli attributi, per ciascun attributo
  le caratteristiche non grafiche lette da un set di dati selezionato da GS_ATTR.
  Parametri:
  _RecordsetPtr &pRs;            recordset di dati
  C_ATTRIB_LIST *p_attrib_list;  lista degli attributi
    
  Restituisce GS_GOOD in caso di successo altrimenti GS_BAD.
-*/  
/*********************************************************/
int gsc_NoGraphCharact2attriblist(_RecordsetPtr &pRs, C_ATTRIB_LIST *p_attrib_list)
{   
   presbuf   pAttr, pOrderPos, pCaption, pVisib, pVisOnTooltip, pMandat;
   presbuf   pCalcFile, pCalcFun, pIsDefCalc;
   presbuf   pValidFile, pValidFun, pMod, pLen, pDec, pDescr, pValidErrMsg, pInputMask;
   int       OrderPos, visib, VisOnToolTip, mandat, result = GS_GOOD, IsDefCalc, i = 0;
   C_STRING  path_valid, path_calc, func_valid, func_calc, Descr, ValidErrMsg;
   C_STRING  _Caption, GphPrefix, GphSuffix, InputMask;
   C_ATTRIB  *pattrib;
   C_RB_LIST ColValues;

   if (gsc_InitDBReadRow(pRs, ColValues) == GS_BAD) return GS_BAD;

   pAttr        = ColValues.CdrAssoc(_T("ATTRIB"));       // ATTRIB
   pOrderPos    = ColValues.CdrAssoc(_T("ORDER_POS"));    // ORDER_POS
   pCaption     = ColValues.CdrAssoc(_T("CAPTION"));      // CAPTION
   pVisib       = ColValues.CdrAssoc(_T("VISIBIL"));      // VISIBIL
   pVisOnTooltip = ColValues.CdrAssoc(_T("VISIB_ON_TOOLTIP")); // VISIB_ON_TOOLTIP
   pMandat      = ColValues.CdrAssoc(_T("MANDAT"));       // MANDAT
   pValidFile   = ColValues.CdrAssoc(_T("FILE_VALID"));   // FILE_VALID
   pValidFun    = ColValues.CdrAssoc(_T("FUN_VALID"));    // FUN_VALID
   pCalcFile    = ColValues.CdrAssoc(_T("FILE_CALC"));    // FILE_CALC
   pCalcFun     = ColValues.CdrAssoc(_T("FUN_CALC"));     // FUN_CALC
   pIsDefCalc   = ColValues.CdrAssoc(_T("IS_DEF_CALC"));  // IS_DEF_CALC
   pMod         = ColValues.CdrAssoc(_T("MOD_ATTR"));     // MOD_ATTR
   pLen         = ColValues.CdrAssoc(_T("LEN"));          // LEN
   pDec         = ColValues.CdrAssoc(_T("DECIM"));        // DECIM
   pDescr       = ColValues.CdrAssoc(_T("DESCRIPTION"));  // DESCRIPTION
   pValidErrMsg = ColValues.CdrAssoc(_T("VALIDATION_ERR_MSG")); // VALIDATION_ERR_MSG
   pInputMask   = ColValues.CdrAssoc(_T("INPUT_MASK"));   // MASCHERA DI INPUT DATI

   // scorro le caratteristiche attributi
   while (gsc_isEOF(pRs) == GS_BAD)
   {
      if (gsc_DBReadRow(pRs, ColValues) == GS_BAD) return GS_BAD;
      
      // nome attributo 
      if (pAttr->restype != RTSTR) { GS_ERR_COD = eGSInvAttribName; return GS_BAD; }
      
      // cerco attributo in lista
      if ((pattrib = (C_ATTRIB *) p_attrib_list->search_name(gsc_alltrim(pAttr->resval.rstring), FALSE)) == NULL)
         { GS_ERR_COD = eGSInvAttribName; return GS_BAD; }
      
      // Posizione attributo in visualizzazione
      if (gsc_rb2Int(pOrderPos, &OrderPos) == GS_BAD) OrderPos = i;
      i++;

      // descrizione attributo 
      _Caption = (pCaption->restype == RTSTR) ? pCaption->resval.rstring : pAttr->resval.rstring;

      // visibilità attributo 
      if (gsc_rb2Int(pVisib, &visib) == GS_BAD) visib = 0;
      visib = (visib == 0) ? GS_BAD : GS_GOOD; // si accettano solo GS_GOOD E GS_BAD

      // visibilità in tooltip attributo
      if (gsc_rb2Int(pVisOnTooltip, &VisOnToolTip) == GS_BAD) VisOnToolTip = 1;
      VisOnToolTip = (VisOnToolTip == 0) ? GS_BAD : GS_GOOD; // si accettano solo GS_GOOD E GS_BAD

      // obbligatorietà attributo 
      if (gsc_rb2Int(pMandat, &mandat) == GS_BAD) mandat = 0;
      mandat = (mandat == 0) ? GS_BAD : GS_GOOD; // si accettano solo GS_GOOD E GS_BAD
        
      // file contenente la funzione di validità 
      if (pValidFile->restype == RTSTR)
      {
         path_valid = gsc_alltrim(pValidFile->resval.rstring);
         // traduco dir assoluto in dir relativo
         if (gsc_nethost2drive(path_valid) == GS_BAD) return GS_BAD;
      }
      else path_valid = GS_EMPTYSTR;

      // funzione di validità 
      if (pValidFun->restype == RTSTR)
         func_valid = gsc_alltrim(pValidFun->resval.rstring);
      else func_valid = GS_EMPTYSTR;
         
      // direttorio del file contenente la funzione di calcolo 
      if (pCalcFile->restype == RTSTR)
      {
         path_calc = gsc_alltrim(pCalcFile->resval.rstring);
         // traduco dir assoluto in dir relativo
         if (gsc_nethost2drive(path_calc) == GS_BAD) return GS_BAD;
      }
      else path_calc = GS_EMPTYSTR;
         
      // funzione di calcolo 
      if (pCalcFun->restype == RTSTR)
         func_calc = gsc_alltrim(pCalcFun->resval.rstring);
      else func_calc = GS_EMPTYSTR;

      // Flag che indica se la funzione di calcolo è riferita al valore di default 
      if (gsc_rb2Int(pIsDefCalc, &IsDefCalc) == GS_BAD) IsDefCalc = 0;
      IsDefCalc = (IsDefCalc == 0) ? GS_BAD : GS_GOOD; // si accettano solo GS_GOOD E GS_BAD

      // modificabilità attributo 
      if (gsc_rb2Int(pMod, &(pattrib->mod_attr)) == GS_BAD) pattrib->mod_attr = 0;

      // lunghezza attributo 
      if (gsc_rb2Lng(pLen, &(pattrib->len)) == GS_BAD) pattrib->len = 0;

      // decimali attributo 
      if (gsc_rb2Int(pDec, &(pattrib->dec)) == GS_BAD) pattrib->dec = 0;

      // descrizione attributo 
      Descr = (pDescr->restype == RTSTR) ? pDescr->resval.rstring: NULL;

      // messaggio di errore per validazione attributo
      if (pValidErrMsg)
         ValidErrMsg = (pValidErrMsg->restype == RTSTR) ? pValidErrMsg->resval.rstring: NULL;

      // maschera di input
      if (pInputMask)
         InputMask = (pInputMask->restype == RTSTR) ? pInputMask->resval.rstring: NULL;
      
      if (pattrib->set_charact(OrderPos,            // posizione
                               _Caption,            // etichetta
                               visib, VisOnToolTip, // visibilità, visibilità in tooltip
                               mandat,              // obbligatorietà 
                               path_calc.get_name(), func_calc.get_name(), IsDefCalc, // funz. di calcolo
                               path_valid.get_name(), func_valid.get_name(), ValidErrMsg, // funz. di validità
                               Descr,                   // Descrizione
                               GphPrefix, GphSuffix, InputMask) == GS_BAD)
         return GS_BAD;

      gsc_Skip(pRs);
   }

   // Ordino gli attributi per OrderPos
   p_attrib_list->sort_by_orderpos();

   // Inizializzo ordine di calcolo per eventuali attributi calcolati
   if (p_attrib_list->InitCalcOrderPos() == GS_BAD) return GS_BAD;

   return GS_GOOD;
}


/*********************************************************/
/*.doc gsc_GraphCharact2attriblist             <external> */
/*+
  Questa funzione carica su una C_ATTRIB_LIST precedentemente gia'
  inizializzata con almeno i nomi degli attributi, per ciascun attributo
  le caratteristiche grafiche lette da un set di dati selezionato da GS_ATTR_GRAPH.
  Parametri:
  _RecordsetPtr &pRs;            recordset di dati
  C_ATTRIB_LIST *p_attrib_list;  lista degli attributi
    
  Restituisce GS_GOOD in caso di successo altrimenti GS_BAD.
-*/  
/*********************************************************/
int gsc_GraphCharact2attriblist(_RecordsetPtr &pRs, C_ATTRIB_LIST *p_attrib_list)
{   
   presbuf   pRbAttr;
   C_ATTRIB  *pAttrib;
   C_RB_LIST ColValues;

   if (gsc_InitDBReadRow(pRs, ColValues) == GS_BAD) return GS_BAD;

   pRbAttr = ColValues.CdrAssoc(_T("ATTRIB"));       // ATTRIB

   // scorro le caratteristiche attributi
   while (gsc_isEOF(pRs) == GS_BAD)
   {
      if (gsc_DBReadRow(pRs, ColValues) == GS_BAD) return GS_BAD;
      
      // nome attributo 
      if (pRbAttr->restype != RTSTR) { GS_ERR_COD = eGSInvAttribName; return GS_BAD; }
      
      // cerco attributo in lista
      if ((pAttrib = (C_ATTRIB *) p_attrib_list->search_name(gsc_alltrim(pRbAttr->resval.rstring), FALSE)) == NULL)
         { GS_ERR_COD = eGSInvAttribName; return GS_BAD; }
         
      if (pAttrib->GraphInfoFromRb(ColValues) == GS_BAD) return GS_BAD;

      gsc_Skip(pRs);
   }

   return GS_GOOD;
}

  
/*********************************************************/
/*.doc gsc_stru_valdef2attriblist <external> */
/*+
  Questa funzione carica su una C_ATTRIB_LIST precedentemente gia'
  allocata, la lista delle colonne di una tabella e per ciascun attributo
  il valore di default.
  Parametri:
  C_CLASS *pCls;                puntatore alla classe
  int     def;                  flag se GS_GOOD -> carica anche i valori di default
    
  Restituisce GS_GOOD in caso di successo altrimenti GS_BAD.
-*/  
/*********************************************************/
int gsc_stru_valdef2attriblist(C_CLASS *pCls, int def)
{
   C_DBCONNECTION *pConn;
   C_ATTRIB_LIST  *p_attrib_list = pCls->ptr_attrib_list();
   C_INFO         *p_info = pCls->ptr_info();

   if (!pCls) { GS_ERR_COD = eGSInvalidArg; return GS_BAD; }
   if (!p_info || !p_attrib_list)
      { GS_ERR_COD = eGSInvClassType; return GS_BAD; }

   if (p_attrib_list->remove_all() == GS_BAD) return GS_BAD;

   // ricavo connessione OLE-DB
   if ((pConn = p_info->getDBConnection(OLD)) == NULL) return GS_BAD;
  
   return gsc_stru_valdef2attriblist(p_info->OldTableRef, pConn, p_attrib_list,
                                     p_info->key_attrib.get_name(), def);
}

  
/*********************************************************/
/*.doc gsc_stru_valdef2attriblist <external> */
/*+
  Questa funzione carica su una C_ATTRIB_LIST precedentemente gia'
  allocata, la lista delle colonne di una tabella e per ciascun attributo
  il valore di default.
  Parametri:
  C_STRING       &TableRef;      Riferimento alla tabella GS_CLASS
  C_DBCONNECTION *pConn;         Puntatore connessione OLE-DB
  C_ATTRIB_LIST  *p_attrib_list; lista attributi (out)
  TCHAR          *key_attrib;    Attributo di indicizzazione
  int            def;            Flag se GS_GOOD -> carica anche i valori di default
    
  Restituisce GS_GOOD in caso di successo altrimenti GS_BAD.
-*/  
/*********************************************************/
int gsc_stru_valdef2attriblist(C_STRING &TableRef, C_DBCONNECTION *pConn,
                               C_ATTRIB_LIST *p_attrib_list, TCHAR *key_attrib, 
                               int def)
{
   int          indice = 0, Dec, IsFixedPrecScale, IsFixedLength;
   presbuf      default_val = NULL, p_struattr, p_defattr, p;
   C_ATTRIB     *pattrib;
   C_RB_LIST    Stru, ColValues;
   C_STRING     TypeDescr, Name, dummyCaption, dummyDescr, dummyValidErrMsg;
   C_STRING     dummyGphPrefix, dummyGphSuffix, dummyInputMask;
   DataTypeEnum ADOType;
   long         Len;
   short        IsLong, IsWrite;

   if (p_attrib_list->remove_all() == GS_BAD) return GS_BAD;

   // leggo struttura tabella
   if ((p = pConn->ReadStruct(TableRef.get_name())) == GS_BAD) return GS_BAD;
   Stru << p;

   if (def == GS_GOOD)
      // leggo i valori di default degli attributi
      if (gsc_readdef(pConn, TableRef, key_attrib, ColValues) == GS_BAD)
         { p_attrib_list->remove_all(); return GS_BAD; }

   while ((p_struattr = gsc_nth(indice, Stru.get_head())) != NULL)
   {
      p_defattr = gsc_nth(1, gsc_nth(indice++, ColValues.get_head()));

      Name             = (p_struattr = p_struattr->rbnext)->resval.rstring;
      ADOType          = (DataTypeEnum) (p_struattr = p_struattr->rbnext)->resval.rlong;
      Len              = (p_struattr = p_struattr->rbnext)->resval.rlong;
      Dec              = (p_struattr = p_struattr->rbnext)->resval.rint;
      IsLong           = ((p_struattr = p_struattr->rbnext)->restype == RTT) ? TRUE : FALSE;
      IsFixedPrecScale = ((p_struattr = p_struattr->rbnext)->restype == RTT) ? TRUE : FALSE;
      IsFixedLength    = (p_struattr = p_struattr->rbnext)->restype;
      IsWrite          = ((p_struattr = p_struattr->rbnext)->restype == RTT) ? TRUE : FALSE;

      // tipo (descrizione), devo usare ExactMode = FALSE perchè in ACCESS97 direct
      // il campo data letto da struttura tabella ha dim 19 mentre lo stesso tipo 
      // chiesto al provider OLE-DB ha dim 8
      if (TypeDescr.paste(pConn->Type2ProviderDescr(ADOType,          // tipo
                                                    IsLong,           // is long
                                                    IsFixedPrecScale, // is FixedPrecScale
                                                    IsFixedLength,    // is FixedLength
                                                    IsWrite,          // is Write
                                                    Len,              // dimensione
                                                    FALSE)) == NULL)  // ExactMode
         { p_attrib_list->remove_all(); return GS_BAD; }

      if ((pattrib = new C_ATTRIB(Name,                 // nome attributo
                                  0,                    // posizione attributo
                                  dummyCaption,         // etichetta attributo
                                  TypeDescr.get_name(), // tipo attributo
                                  Len,                  // len attributo
                                  Dec,                  // dec attributo
                                  GS_BAD,               // visibilità
                                  GS_GOOD,              // visibilità in tooltip
                                  GS_BAD,               // obbligatorietà 
                                  NULL, NULL, FALSE,    // funz. di calcolo + def. calcolato 
                                  NULL, NULL,           // funz. di validità
                                  dummyValidErrMsg,     // Messaggio di errore per validità
                                  p_defattr,            // valore di default
                                  0,                    // flag
                                  dummyDescr,           // Descrizione
                                  dummyGphPrefix,       // Prefisso grafico
                                  dummyGphSuffix,       // Suffisso grafico
                                  dummyInputMask        // Maschera di input dati
                                  )) == NULL)  
         { p_attrib_list->remove_all(); return GS_BAD; }

      p_attrib_list->add_tail((C_NODE*) pattrib); // inserimento in lista
   }

   return GS_GOOD;
}


/*********************************************************/
/*  INIZIO FUNZIONI TABELLE SECONDARIE                   */
/*********************************************************/


/*********************************************************/
/*.doc C_CLASS::find_sec                      <external> */
/*+
  Ritorna il puntatore alla tabella secondaria della classe specificata.
  Parametri:
  int sec;  Codice secondaria
    
  Restituisce NULL in caso di errore.
-*/  
/*********************************************************/
C_NODE *C_CLASS::find_sec(int sec)
{
   C_SECONDARY *pSec;

   if (!ptr_secondary_list) return NULL;

   // Cerca la secondaria solo in memoria
   if ((pSec = (C_SECONDARY *) ptr_secondary_list->search_key(sec)) == NULL)
      // carico la classe da database
      if (!(pSec = (C_SECONDARY *) load_sec_from_db(sec))) return NULL;

   // se c'è una sessione di lavoro attiva con la classe madre della tabella secondaria già
   // estratta e la tabella secondaria di tipo GEOsim non ancora selezionata
   if (GS_CURRENT_WRK_SESSION != NULL && GS_CURRENT_WRK_SESSION->get_status() == WRK_SESSION_ACTIVE &&
       is_extracted() &&
       pSec->type == GSInternalSecondaryTable && pSec->sel == DESELECTED)
   {  // scrivo la classe su file
      C_STRING                pathfile,ClsPathFile;
      TCHAR                   buf[ID_PROFILE_LEN], entry[ID_PROFILE_LEN], *read_buffer = NULL;
      int                     i = 1;
      C_PROFILE_SECTION_BTREE ProfileSections;
      C_BPROFILE_SECTION      *pProfileSection;
      bool                    Unicode = false;

      GS_CURRENT_WRK_SESSION->get_TempInfoFilePath(pathfile);

      if (gsc_path_exist(pathfile) == GS_GOOD)
         if (gsc_read_profile(pathfile, ProfileSections, &Unicode) == GS_BAD) return GS_BAD;

      swprintf(entry, ID_PROFILE_LEN, _T("%d"), i);
      if ((pProfileSection = (C_BPROFILE_SECTION *) ProfileSections.search(SECONDARIES_LIST_SEZ)))
      {
         C_2STR_BTREE *pProfileEntries = (C_2STR_BTREE *) pProfileSection->get_ptr_EntryList();

         while (pProfileEntries->search(entry) != NULL)
            swprintf(entry, ID_PROFILE_LEN, _T("%d"), ++i);
      }

      GS_CURRENT_WRK_SESSION->get_TempInfoFilePath(ClsPathFile, id.code);
      if (pSec->ToFile(ClsPathFile) == GS_BAD) return GS_BAD;

      // aggiungo la secondaria nella sezione SECONDARIES_LIST_SEZ
      swprintf(buf, ID_PROFILE_LEN, _T("%d,%d,%d"), id.code, id.sub_code, pSec->code);
      swprintf(entry, ID_PROFILE_LEN, _T("%d"), i);
      if (ProfileSections.set_entry(_T("SECONDARIES_LIST"), entry, buf) == GS_BAD)
         return GS_BAD;
      pSec->sel = SELECTED;

      if (gsc_write_profile(pathfile, ProfileSections, Unicode) == GS_BAD) return GS_BAD; 
   }
   
   return pSec;
}

  
/*********************************************************/
/*.doc C_CLASS::load_sec_from_db                   <external> */
/*+
  Questa funzione carica una tabella secondaria in memoria da database.
  Parametri:
  int cod_sec;      Codice della tabella secondaria

  Restituisce il puntatore alla secondaria in caso di successo
  altrimenti NULL.
-*/  
/*********************************************************/
C_NODE *C_CLASS::load_sec_from_db(int cod_sec)
{
   C_DBCONNECTION *pConn;
   C_STRING       statement, TableRef;
   C_RB_LIST      ColValues;
   _RecordsetPtr  pRs;
   C_SECONDARY    *psecondary;
   C_4INT_STR_LIST usr_listSec;
   C_4INT_STR      *pusr_sec;
   GSDataPermissionTypeEnum cod_level;

   if (!ptr_secondary_list) return NULL;

   acutPrintf(_T("%s%d..."), gsc_msg(791), cod_sec); // "\nLettura definizione secondaria avente codice "

   ptr_secondary_list->remove_key(cod_sec);  // cancello elemento già presente
   
   if (gsc_superuser() != GS_GOOD)  // non è un SUPER USER
   {
      // leggo lista delle tabelle secondarie visibili per l'utente corrente

      // Uso una C_4INT_STR in cui:   
      // set_key() e get_key()           gestiscono il codice della classe
      // set_type() e get_type()         gestiscono il codice della sotto-classe
      // set_category() e get_category() gestiscono il codice della tabella secondaria
      // set_level() e get_level()       gestiscono l'abilitazione della tabella secondaria

      // lista tabelle secondarie utente
      if (gsc_getSecPermissions(GEOsimAppl::GS_USER.code, get_PrjId(), usr_listSec) == GS_BAD)
         return GS_BAD; // nessuna abilitazione

      if (!(pusr_sec = (C_4INT_STR *) usr_listSec.search(id.code, id.sub_code, cod_sec)) ||  // nessuna abilitazione   
          pusr_sec->get_level() == GSInvisibleData) // salto la tabella secondaria se invisibile
         return NULL; // tabella secondaria non abilitata
   }

   // setto il riferimento di GS_SEC (<catalogo>.<schema>.<tabella>)
   if (get_pPrj()->getSecsTabInfo(&pConn, &TableRef) == GS_BAD) return NULL;

   statement = _T("SELECT * FROM ");
   statement += TableRef;
   statement += _T(" WHERE CLASS_ID=");
   statement += id.code;
   statement += _T(" AND SUB_CL_ID=");
   statement += id.sub_code;
   statement += _T(" AND GS_ID=");
   statement += cod_sec;

   // leggo le righe della tabella senza bloccarla
   if (pConn->ExeCmd(statement, pRs) == GS_BAD) return NULL;
        
   if (gsc_isEOF(pRs) == GS_GOOD)
      { gsc_DBCloseRs(pRs); GS_ERR_COD = eGSInvSecCode; return NULL; }

   if (gsc_DBReadRow(pRs, ColValues) == GS_BAD) { gsc_DBCloseRs(pRs); return NULL; }

   if (gsc_DBCloseRs(pRs) == GS_BAD) return NULL;
   
   if (gsc_superuser() == GS_GOOD)
      cod_level = GSUpdateableData;   // classi modificabili 
   else                                     
      cod_level = pusr_sec->get_level();   // abilitazione tabella secondaria

   // Alloca una nuova classe
   if ((psecondary = new C_SECONDARY) == NULL)
       { GS_ERR_COD = eGSOutOfMem; return NULL; }

   // Collegamento secondaria -> classe
   psecondary->pCls = this;
   
   if (psecondary->from_db(ColValues, cod_level) == GS_BAD) { delete psecondary; return NULL; }

   // Collegamento classe -> secondaria
   ptr_secondary_list->add_tail(psecondary);
         
   return psecondary;
}


/*********************************************************/
/*.doc gs_rtab_sec <external> */
/*+
  Questa funzione LISP restituisce l'elenco delle tabelle secondarie
  di una classe visibile all'utente corrente.
  Parametri:
  (prj cls [sub])
  Lista risultato:
  (<sec> <name> <type>)
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int gs_rtab_sec(void)
{
   presbuf            arg;
   C_RB_LIST          ret;
   int                prj, cls, sub;
   C_INT_INT_STR_LIST lista;

   acedRetNil();
   // Legge nella lista dei parametri: progetto classe e sub //
   arg = acedGetArgs();
   if (arg_to_prj_cls_sub(&arg, &prj, &cls, &sub) == GS_BAD) return RTERROR;

   if (gsc_rtab_sec(prj, cls, sub, lista) == GS_BAD) return RTERROR;

   if ((ret << lista.to_rb()) == NULL) return RTERROR;
   if (ret.get_head()->restype != RTNIL) ret.LspRetList();

   return RTNORM;
}


/*********************************************************/
/*.doc gsc_rtab_sec <external> */
/*+
  Questa funzione restituisce l'elenco delle tabelle secondarie
  di una classe.
  Lista : (<codice classe> <livello> <nome classe> <categoria> <tipo>)
  Parametri:
  int prj;           Codice progetto
  int cls;           Codice classe
  int sub;           Codice sottoclasse
  C_INT_INT_STR_LIST *Lista di output

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int gsc_rtab_sec(int prj, int cls, int sub, C_INT_INT_STR_LIST &lista)
{
   C_CLASS *pCls;

   // cerca classe 
   if ((pCls = gsc_find_class(prj, cls, sub)) == NULL) return GS_BAD;

   if (pCls->rtab_sec(lista) == GS_BAD) return GS_BAD;

   return GS_GOOD;
}


/*********************************************************/
/*.doc rtab_sec <external> */
/*+
  Questa funzione restituisce l'elenco delle tabelle secondarie
  di una classe.
  Parametri:
  C_INT_INT_STR_LIST &SinthSecList; Lista di output (gs_id, type, name)
  int FilterType;                   Se <> -1 codice del tipo da filtrare
                                    GSExternalSecondaryTable = 0, GSInternalSecondaryTable = 1
                                    (default = -1 che significa "filro non applicato")
  int DynSegmentationSupportedOnly; Se = GS_GOOD filtra solo le classi che supportano
                                    La segmentazione dinamica (default = GS_BAD)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_CLASS::rtab_sec(C_INT_INT_STR_LIST &SinthSecList, int FilterType, int DynSegmentationSupportedOnly)
{
   C_DBCONNECTION *pConn;
   C_STRING       statement, TableRef;
   _RecordsetPtr  pRs;
   int            cod_sec, cod_type;
   TCHAR          name_sec[MAX_LEN_CLASSNAME];
   C_RB_LIST      ColValues;
   presbuf        pKey, pName, pType;
   C_INT_INT_STR  *pSinthSec;
   
   SinthSecList.remove_all();

   // setto il riferimento di GS_SEC (<catalogo>.<schema>.<tabella>)
   if (get_pPrj()->getSecsTabInfo(&pConn, &TableRef) == GS_BAD) return GS_BAD;

   statement = _T("SELECT GS_ID,NAME,TYPE FROM ");
   statement += TableRef;
   statement += _T(" WHERE CLASS_ID=");
   statement += id.code;
   statement += _T(" AND SUB_CL_ID=");
   statement += id.sub_code;
   if (FilterType != -1)
   {
      statement += _T(" AND TYPE=");
      statement += FilterType;
   }
   statement += _T(" ORDER BY GS_ID");

   // leggo le righe della tabella senza bloccarla
   if (pConn->ExeCmd(statement, pRs) == GS_BAD) return GS_BAD;
   
   if (gsc_InitDBReadRow(pRs, ColValues) == GS_BAD)
      { gsc_DBCloseRs(pRs); return GS_BAD; }

   pKey  = ColValues.CdrAssoc(DEFAULT_KEY_ATTR);
   pName = ColValues.CdrAssoc(_T("NAME"));
   pType = ColValues.CdrAssoc(_T("TYPE"));

   // scorro l'elenco delle secondarie
   while (gsc_isEOF(pRs) == GS_BAD)
   {
      if (gsc_DBReadRow(pRs, ColValues) == GS_BAD) { gsc_DBCloseRs(pRs); return GS_BAD; }

      gsc_rb2Int(pKey, &cod_sec);
      gsc_strcpy(name_sec, gsc_alltrim(pName->resval.rstring), MAX_LEN_CLASSNAME);
      gsc_rb2Int(pType, &cod_type);

      if ((pSinthSec = new C_INT_INT_STR()) == NULL)
         { gsc_DBCloseRs(pRs); GS_ERR_COD = eGSOutOfMem; return GS_BAD; }
         
      if (pSinthSec->set_name(name_sec) == GS_BAD || pSinthSec->set_key(cod_sec) == GS_BAD ||
          pSinthSec->set_type(cod_type) == GS_BAD)
         { delete pSinthSec; gsc_DBCloseRs(pRs); return GS_BAD; }

      SinthSecList.add_tail(pSinthSec);

      gsc_Skip(pRs);
   }
   
   if (gsc_DBCloseRs(pRs) == GS_BAD) return GS_BAD;

   if (DynSegmentationSupportedOnly == GS_GOOD)
   {
      C_SECONDARY *pSecondary;

      pSinthSec = (C_INT_INT_STR *) SinthSecList.get_head();
      while (pSinthSec)
      {
         if ((pSecondary = (C_SECONDARY *) find_sec(pSinthSec->get_key())) == NULL)
            return GS_BAD;

         if (pSecondary->DynSegmentationType() == GSNoneDynSegmentation)
         {
            SinthSecList.remove_at(); // cancella e va al successivo
            pSinthSec = (C_INT_INT_STR *) SinthSecList.get_cursor();
         }
         else
            pSinthSec = (C_INT_INT_STR *) SinthSecList.get_next();
      }
   }

   return GS_GOOD;
}


/*********************************************************/
/*.doc C_CLASS::del_all_tab_sec <internal> */
/*+
  Questa funzione cancella tutte le tabelle secondarie della classe.
  La funzione non si occupa di bloccare la classe agli altri utenti. Questo
  deve essere gestito dalla fuznione chiamante.
  Parametri:
  const TCHAR *Password;    Password dell'utente corrente (per controllo)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_CLASS::del_all_tab_sec(const TCHAR *Password)
{
   C_SINTH_SEC_TAB_LIST SinthSecList;
   C_SINTH_SEC_TAB      *pSinthSec;
   C_SECONDARY          *pSec;

   // leggo la lista delle tabelle secondarie
   if (get_pPrj()->getSinthClsSecondaryTabList(id.code, id.sub_code, SinthSecList) == GS_BAD) return GS_BAD;

   pSinthSec = (C_SINTH_SEC_TAB *) SinthSecList.get_head();
   while (pSinthSec)
   {
      if ((pSec = (C_SECONDARY *) find_sec(pSinthSec->get_key())) == NULL)
         return GS_BAD;
      if (pSec->del(Password) == GS_BAD) return GS_BAD;

      pSinthSec = (C_SINTH_SEC_TAB *) SinthSecList.get_next();
   }

   return GS_GOOD;
}


/******************************************************************************/
/*.doc C_CLASS::CheckGraphData                                                */
/*+
  Questa funzione esegue il controllo dei dati grafici di una classe
  Parametri:
  int WhatOperation;    Tipo di controllo da eseguire:
                        reindicizzazione (REINDEX)
                        sblocco degli oggetti bloccati (UNLOCKOBJS)
                        creazione file INF di estensione dei disegni (SAVEEXTENTS)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/******************************************************************************/
int C_CLASS::CheckGraphData(int WhatOperation)
{
   C_GPH_INFO *p;

   if (id.category == CAT_EXTERN)
   {
      C_SUB *pSub = (C_SUB *) ptr_sub_list()->get_head();
      p = pSub->ptr_GphInfo();
   }
   else
      // se non ha dati grafici: grazie è stato bello...
      if ((p = ptr_GphInfo()) == NULL) return GS_GOOD;

   return p->Check(WhatOperation);
}


/******************************************************************************/
/*.doc C_CLASS::DWGsUnlock                                                    */
/*+
  Questa funzione sblocca tutti i DWG della classe (cancella i *.DWK, *.DWL?, *.MAP).
  Parametri
  int *unlocked;              Flag di risultato (TRUE se ha sbloccato i DWG)
                              (default = NULL

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
  N.B. La funzione non verifica che i dwg siano in uso.
-*/  
/******************************************************************************/
int C_CLASS::DWGsUnlock(int *unlocked)
{
   C_DWG_LIST DwgList;
   C_DWG      *pDwg;
   C_STRING   drive, dir, name;
   C_STRING   DWKFile, DWLFiles, Prefix;

   if (unlocked) *unlocked = FALSE;
   // inizializzo la lista dei dwg della classe
   if (DwgList.load(id.pPrj->get_key(), id.code) == GS_GOOD)
   {
      pDwg = (C_DWG *) DwgList.get_head();
      if (pDwg)
      {
         C_STRING pathfile;
         presbuf  pname, pattr;
         
         gsc_splitpath(pDwg->get_name(), &drive, &dir, NULL, NULL);

         // cancello eventuali file temporanei *.MAP
         pathfile = drive;
         pathfile += dir;
         pathfile += _T("*.MAP");
         if (gsc_adir(pathfile.get_name(), &pname, NULL, NULL, &pattr) > 0)
         {
            while (pname) 
            {
               // NON è un direttorio          
               if (pname->restype == RTSTR && *(pattr->resval.rstring + 4) != _T('D'))
               {
                  pathfile = drive;
                  pathfile += dir;
                  pathfile += pname->resval.rstring;

                  if (gsc_path_exist(pathfile) == GS_GOOD) gsc_delfile(pathfile);
               }
               pname = pname->rbnext;
               pattr = pattr->rbnext;
            }
            acutRelRb(pname); acutRelRb(pattr);
         }

         // cancello eventuali file *.DWK, *.DWL?
         while (pDwg)
         {
            gsc_splitpath(pDwg->get_name(), &drive, &dir, &name);
            Prefix = drive;
            Prefix += dir;
            Prefix += name;

            DWKFile = Prefix;
            DWKFile += _T(".DWK");
            if (gsc_path_exist(DWKFile) == GS_GOOD) 
               if (gsc_delfile(DWKFile, ONETEST) == GS_GOOD)
                  if (unlocked) *unlocked = TRUE;

            DWLFiles = Prefix;
            DWLFiles += _T(".DWL?");
            if (gsc_delfiles(DWLFiles.get_name(), ONETEST) == GS_GOOD)
               if (unlocked) *unlocked = TRUE;

            pDwg = (C_DWG *) DwgList.get_next();
         }
      }
   }

   return GS_GOOD;
}


/******************************************************************************/
/*.doc C_CLASS::entExtract                                                    */
/*+
  Questa funzione estrae gli oggetti grafici dell'entità
  Parametri
  long KeyValue;              Codice chiave

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/******************************************************************************/
int C_CLASS::entExtract(long KeyValue)
{
   if (!GS_CURRENT_WRK_SESSION) { GS_ERR_COD = eGSNotCurrentSession; return GS_BAD; }

   // N.B. dopo aver fatto un congelamento non è possibile eseguire altre estrazioni
   // questo è fatto perchè dopo uno scongelamento se si eseguisse una estrazione
   // di un'area già estratta si duplicherebbero gli oggetti coincidenti (infatti, in
   // questa condizione, non esistono più i link tra oggetti e DWG di origine)
   if (GS_CURRENT_WRK_SESSION->HasBeenFrozen() == GS_GOOD)
      { GS_ERR_COD = eGSOpNotAbleInFrozenSession; return GS_BAD; }

   if (ptr_info() == NULL)
      { GS_ERR_COD = eGSInvClassType; return GS_BAD; }

   C_STRING       SQLCond, FldName(ptr_info()->key_attrib);
   C_DBCONNECTION *pConn = ptr_info()->getDBConnection(OLD);
   TCHAR          QuotedId;

   // Correggo la sintassi del nome del campo con i doppi apici (") per MAP
   // se il campo contiene degli spazi
   QuotedId = (FldName.at(_T(" "))) ? _T('\"') : _T('');
   if (gsc_AdjSyntax(FldName, QuotedId, QuotedId,
                     pConn->get_StrCaseFullTableRef()) == GS_BAD)
      return GS_BAD;
   SQLCond = FldName;
   SQLCond +=  _T('=');
   SQLCond += KeyValue;

   // leggo i codici delle entità che soddisfano la query SQL sulla tabella OLD
   return gsc_SQLExtract(id.code, id.sub_code, SQLCond.get_name(), EXTRACTION);
}


/*****************************************************************************/
/*.doc C_CLASS::CopyToPrj                                         <external> */
/*+
  Questa funzione copia la classe di entità nel progetto indicato modificandone
  il nome, il collegamento al DB e la FAS.
  Parametri:
  int NewPrj;                  Codice nuovo progetto
  const TCHAR *Name;           Nome della nuova classe
  const TCHAR *TableRef;       Riferimento completo alla tabella nuova classe (non
                               usato per le simulazioni)
  const TCHAR *ConnStrUDLFile; Stringa di connessione o file .UDL
  C_2STR_LIST &PropList;       Lista delle proprietà UDL da variare
  DataCopyTypeEnum CopyType;   Tipo di copia (GSStructureOnlyCopyType = solo struttura,
                                              GSStructureAndDataCopyType = tutto,
                                              GSDataLinkCopyType = solo link se la classe origine era esterna)
  C_FAS_LIST *fasList;         Lista di FAS
  C_GPH_INFO_LIST *pGraphInfoList; Lista di informazioni su sorgenti grafiche
  C_GROUP_LIST *pNewGroupList; Nuova lista di collegamento con classi figlie
                               usata qualora si voglia copiare un gruppo
                               da un progetto all'altro (default = NULL)

  Restituisce il puntatore alla nuova classe in caso di successo altrimenti NULL.
-*/  
/*****************************************************************************/
C_CLASS *C_CLASS::CopyToPrj(int NewPrj, const TCHAR *Name, const TCHAR *Descr,
                            const TCHAR *TableRef,
                            const TCHAR *ConnStrUDLFile, C_2STR_LIST &PropList,
                            DataCopyTypeEnum CopyType, C_FAS_LIST *fasList,
                            C_GPH_INFO_LIST *pGraphInfoList, C_INT_INT_LIST *pNewGroupList)
{
   C_CLASS *pNewCls;
   int     result = GS_BAD, NewCodeCls = 0, has_graph = FALSE;

   // Alloca una classe
   if ((pNewCls = gsc_alloc_new_class(get_category())) == NULL) return NULL;

   do
   {
      // copio la vecchia classe nella nuova
      if (copy(pNewCls) != GS_GOOD) break;

      // se non si tratta di simulazione
      if (pNewCls->get_category() != CAT_EXTERN)
      {
         // se la classe ha connessioni
         if (pNewCls->ptr_connect_list())
            // se la copia è fatta su un progetto diverso da quello di origine
            if (NewPrj != id.pPrj->get_key())
               // azzero la connect list della classe (se esiste)
               pNewCls->ptr_connect_list()->remove_all();
            else
            {
               C_INT_INT *pConnect = (C_INT_INT *) pNewCls->ptr_connect_list()->search_key(id.code);
         
               // se la classe origine era connessa con se stessa
               if (pConnect) pConnect->set_key(0);
            }

         // se la copia è fatta su un progetto diverso da quello di origine
         if (NewPrj != id.pPrj->get_key())
            // Se si tratta di un gruppo modifico la lista delle relazioni
            // con classi semplici
            if (get_category() == CAT_GROUP && pNewGroupList)
            {
               C_INT_INT *pLink = (C_INT_INT *) pNewCls->ptr_group_list()->get_head(), *p;

               while (pLink)
               {
                  if ((p = (C_INT_INT *) pNewGroupList->search_key(pLink->get_key())))
                     pLink->set_key(p->get_type());

                  pLink = (C_INT_INT *) pLink->get_next();
               }
            }
      }

      // cambio nome alla classe
      gsc_strcpy(pNewCls->id.name, Name, MAX_LEN_CLASSNAME);
      pNewCls->id.Descr = Descr;
      
      if (get_category() != CAT_EXTERN)
      {
         if (ptr_fas())
         {
            C_GPH_INFO *pGraphInfo;

            has_graph = TRUE;
            if (fasList && fasList->get_head()) // Imposto nuova FAS
				   ((C_FAS *) fasList->get_cursor())->copy(pNewCls->ptr_fas());
            
            // Se non si tratta di copiare solo il link alla tabella dati
            if (CopyType != GSDataLinkCopyType &&
                pGraphInfoList && (pGraphInfo = (C_GPH_INFO *) pGraphInfoList->get_head()))
            {  // Imposto nuova info grafica
               if (pNewCls->allocGraphInfo(pGraphInfo->getDataSourceType()) == GS_BAD)
                  break;
               // se la classe sorgente ha la tabella collegata e il tipo di destinazione è un db
               if (ptr_GphInfo()->getDataSourceType() == GSDBGphDataSource &&
                   ((C_DBGPH_INFO *) ptr_GphInfo())->LinkedTable && 
                   pGraphInfo->getDataSourceType() == GSDBGphDataSource)
               {
                  C_DBGPH_INFO *pDest = (C_DBGPH_INFO *) pNewCls->ptr_GphInfo(), *pSrc = (C_DBGPH_INFO *) pGraphInfo;
                  // copio solo: ConnStrUDLFile, UDLProperties, TableRef
                  pDest->ConnStrUDLFile = pSrc->ConnStrUDLFile;
                  pSrc->UDLProperties.copy(pDest->UDLProperties);
                  pDest->TableRef = pSrc->TableRef;
               }
               else
			         pGraphInfo->copy(pNewCls->ptr_GphInfo());
            }
         }

         // Se non si tratta di copiare solo il link alla tabella dati
         if (CopyType != GSDataLinkCopyType &&
             ptr_info())
         {  // Aggiorno le info della classe
            C_STRING ProviderDescr;
            C_ATTRIB *pKeyAttrib;

            pNewCls->ptr_info()->OldTableRef    = TableRef;
            pNewCls->ptr_info()->ConnStrUDLFile = ConnStrUDLFile;
            PropList.copy(pNewCls->ptr_info()->UDLProperties);
            pNewCls->ptr_info()->LinkedTable = false;
            // Conversione struttura tabella
            if (pNewCls->ptr_attrib_list()->Convert2ProviderType(ptr_info()->getDBConnection(OLD), 
                                                                 pNewCls->ptr_info()->getDBConnection(OLD)) == GS_BAD)
               break;

            if (!(pKeyAttrib = (C_ATTRIB *) pNewCls->ptr_attrib_list()->search_name(pNewCls->ptr_info()->key_attrib.get_name(), FALSE)))
               break;
            // Il valore chiave viene forzato al tipo di default del DBMS della classe (numero intero)
            if (pNewCls->ptr_info()->getDBConnection(OLD)->Type2ProviderType(CLASS_KEY_TYPE_ENUM, // DataType per campo chiave
                                                                             FALSE,               // IsLong
                                                                             FALSE,               // IsFixedPrecScale
                                                                             RTT,                 // IsFixedLength
                                                                             TRUE,                // IsWrite
                                                                             CLASS_LEN_KEY_ATTR,  // Size
                                                                             0,                   // Prec
                                                                             ProviderDescr,       // ProviderDescr
                                                                             &(pKeyAttrib->len),
                                                                             &(pKeyAttrib->dec)) == GS_BAD)
               break;
            gsc_strcpy(pKeyAttrib->type, ProviderDescr.get_name(), MAX_LEN_FIELDTYPE);
            // Il valore di default dell'attributo chiave deve essere = 0
            if (!pKeyAttrib->def) pKeyAttrib->def = acutBuildList(RTSHORT, 0, 0);
            else gsc_RbSubst(pKeyAttrib->def, 0);
         }
      }
      else // se si tratta di simulazioni
      {
         C_DBCONNECTION *pOldConn;
         C_SUB *pNewSub;
         int   i = 1;

         // Aggiorno le info della classe madre
			if ((pNewSub = ((C_SUB *) ptr_sub_list()->get_head())) == NULL) break;
         if (pNewSub->ptr_info())
         {
            if ((pOldConn = pNewSub->ptr_info()->getDBConnection(OLD)) == NULL) break;
            pNewSub->ptr_info()->copy(pNewCls->ptr_info());

            pNewCls->ptr_info()->OldTableRef    = TableRef;
            pNewCls->ptr_info()->ConnStrUDLFile = ConnStrUDLFile;
            PropList.copy(pNewCls->ptr_info()->UDLProperties);
         }

         pNewSub = (C_SUB *) pNewCls->ptr_sub_list()->getptr_at(i);
         while (pNewSub)
         {
            if (pNewSub->ptr_fas())
            {
               C_GPH_INFO *pGraphInfo;

               has_graph = TRUE;
               if (fasList && ((C_FAS *) fasList->getptr_at(i))) // Imposto nuova FAS
				      ((C_FAS *) fasList->get_cursor())->copy(pNewSub->ptr_fas());

               if (pGraphInfoList && (pGraphInfo = (C_GPH_INFO *) pGraphInfoList->getptr_at(i)))
               {  // Imposto nuova info grafica
                  if (pNewSub->allocGraphInfo(pGraphInfo->getDataSourceType()) == GS_BAD)
                     break;
				      pGraphInfo->copy(pNewSub->ptr_GphInfo());
               }
            }

            // Aggiorno le info delle sottoclassi
            if (pNewSub->ptr_info())
            {
               C_STRING ProviderDescr;
               C_ATTRIB *pKeyAttrib;

               pNewSub->ptr_info()->ConnStrUDLFile = ConnStrUDLFile;
               PropList.copy(pNewSub->ptr_info()->UDLProperties);

               // Conversione struttura tabella
               if (pNewSub->ptr_attrib_list()->Convert2ProviderType(pOldConn, 
                                                                    pNewSub->ptr_info()->getDBConnection(OLD)) == GS_BAD)
                  break;

               if (!(pKeyAttrib = (C_ATTRIB *) pNewSub->ptr_attrib_list()->search_name(pNewSub->ptr_info()->key_attrib.get_name(), FALSE)))
                  break;
               // Il valore chiave viene forzato al tipo di default del DBMS della classe (numero intero)
               if (pNewSub->ptr_info()->getDBConnection(OLD)->Type2ProviderType(CLASS_KEY_TYPE_ENUM, // DataType per campo chiave
                                                                                FALSE,               // IsLong
                                                                                FALSE,               // IsFixedPrecScale
                                                                                RTT,                 // IsFixedLength
                                                                                TRUE,                // IsWrite
                                                                                CLASS_LEN_KEY_ATTR,  // Size
                                                                                0,                   // Prec
                                                                                ProviderDescr,       // ProviderDescr
                                                                                &(pKeyAttrib->len),
                                                                                &(pKeyAttrib->dec)) == GS_BAD)
                  break;
               gsc_strcpy(pKeyAttrib->type, ProviderDescr.get_name(), MAX_LEN_FIELDTYPE);
               // Il valore di default dell'attributo chiave deve essere = 0
               if (!pKeyAttrib->def) pKeyAttrib->def = acutBuildList(RTSHORT, 0, 0);
               else gsc_RbSubst(pKeyAttrib->def, 0);
            }

            pNewSub = (C_SUB *) pNewSub->get_next();
            i++;
         }
      }
      
      result = GS_GOOD;
   }
   while (0);

   if (result == GS_BAD) { delete pNewCls; return NULL; }
 
   // creazione della classe
   if ((NewCodeCls = gsc_createclass(NewPrj, pNewCls)) == 0)
      { delete pNewCls; return NULL; }

   CopySupportFiles(pNewCls);

   if (CopyType == GSStructureAndDataCopyType)  // copio struttura e dati
   {
      C_DBCONNECTION *pSourceConn, *pDestConn;
      _RecordsetPtr  pReadRs;
      _CommandPtr    pInsCmd;
      C_STRING       statement;

      result = GS_BAD;
      do
      {
         if (get_category() != CAT_EXTERN)
         {
            if (ptr_info() && ptr_attrib_list())
            {  
               pSourceConn = ptr_info()->getDBConnection(OLD);
               pDestConn   = pNewCls->ptr_info()->getDBConnection(OLD);

               // Cancello il contenuto della tabella
               if (gsc_DBDelRows(pDestConn->get_Connection(),
                                 pNewCls->ptr_info()->OldTableRef.get_name()) == GS_BAD)
                  break;
               
               // copio il contenuto da una tabella all'altra
               if (pDestConn->InitInsRow(pNewCls->ptr_info()->OldTableRef.get_name(), pInsCmd) == GS_BAD)
                  break;

               statement = _T("SELECT * FROM ");
               statement += ptr_info()->OldTableRef;
               if (pSourceConn->OpenRecSet(statement, pReadRs, adOpenForwardOnly,
                                           adLockReadOnly, ONETEST) == GS_BAD)
                  break;

               // gsc_DBInsRowSet è implementato in una transaction
               if (gsc_DBInsRowSet(pInsCmd, pReadRs, ONETEST) == GS_BAD)
                  { gsc_DBCloseRs(pReadRs); break; }

               gsc_DBCloseRs(pReadRs);

               // se la tabella alfanumerica sorgente è collegata
               if (ptr_info()->LinkedTable)
               {
                  C_RB_LIST ColValues;

                  // verifico che ci sia il record di default
                  if (gsc_readdef(pSourceConn, ptr_info()->OldTableRef, 
                                  ptr_info()->key_attrib.get_name(), ColValues) == GS_BAD)
                     // scarico valori di default in tabella
                     if (pNewCls->default_to_db(pNewCls->ptr_attrib_list()) == GS_BAD) break;
               }
            }

            if (ptr_info()) pNewCls->ptr_info()->TempLastId = ptr_info()->TempLastId;

            // gruppi
            if (get_category() == CAT_GROUP)
            {
               C_STRING OldClsLinkTableRef, NewClsLinkTableRef;

               if (getOldLnkTableRef(OldClsLinkTableRef) == GS_BAD ||
                   pNewCls->getOldLnkTableRef(NewClsLinkTableRef) == GS_BAD)
                  break;

               // Cancello il contenuto della tabella
               if (gsc_DBDelRows(pDestConn->get_Connection(),
                                 NewClsLinkTableRef.get_name()) == GS_BAD)
                  break;
               
               // copio il contenuto da una tabella all'altra
               if (pDestConn->InitInsRow(NewClsLinkTableRef.get_name(), pInsCmd) == GS_BAD)
                  break;

               statement = _T("SELECT * FROM ");
               statement += OldClsLinkTableRef;
               if (pSourceConn->OpenRecSet(statement, pReadRs, adOpenForwardOnly,
                                           adLockReadOnly, ONETEST) == GS_BAD)
                  break;

               // gsc_DBInsRowSet è implementato in una transaction
               if (gsc_DBInsRowSet(pInsCmd, pReadRs, ONETEST) == GS_BAD)
               {
                  gsc_DBCloseRs(pReadRs);
                  break;
               }

               gsc_DBCloseRs(pReadRs);

               // se la copia è fatta su un progetto diverso da quello di origine
               if (NewPrj != id.pPrj->get_key() && pNewGroupList)
                  if (gsc_change_group_link(pNewCls, *pNewGroupList) == GS_BAD)
                      break;
            }
         }
         else // si tratta di simulazioni
         {
            C_SUB      *pNewSub, *pSub;
            C_STRING   SourceTopoTableRef, DestTopoTableRef;
            C_TOPOLOGY SourceTopo, DestTopo;

            SourceTopo.set_type(TYPE_POLYLINE);  // tipologia di tipo rete
            SourceTopo.set_cls(this);            // per classe madre
            SourceTopo.set_temp(GS_BAD);         // Topologia OLD

            DestTopo.set_type(TYPE_POLYLINE);  // tipologia di tipo rete
            DestTopo.set_cls(pNewCls);         // per classe madre
            DestTopo.set_temp(GS_BAD);         // Topologia OLD

            pSub    = (C_SUB *) ptr_sub_list()->get_head();
            pNewSub = (C_SUB *) pNewCls->ptr_sub_list()->get_head();
            while (pNewSub)
            {
               if (pNewSub->ptr_info() && pNewSub->ptr_attrib_list())
               {
                  pSourceConn = pSub->ptr_info()->getDBConnection(OLD);
                  pDestConn   = pNewSub->ptr_info()->getDBConnection(OLD);

                  if (SourceTopoTableRef.len() == 0)
                  {
                     C_STRING Catalog, Schema;

                     // Sorgente
                     if (pSourceConn->split_FullRefTable(pSub->ptr_info()->OldTableRef,
                                                         Catalog, Schema, SourceTopoTableRef) == GS_BAD)
                        break;
                     if (SourceTopo.getTopoTabName(pSourceConn, pSub->ptr_id()->pPrj->get_key(), pSub->ptr_id()->code,
                                                   Catalog.get_name(), Schema.get_name(), SourceTopoTableRef) == GS_BAD)
                        break;

                     // Destinazione
                     if (pDestConn->split_FullRefTable(pNewSub->ptr_info()->OldTableRef,
                                                       Catalog, Schema, DestTopoTableRef) == GS_BAD)
                        break;
                     if (DestTopo.getTopoTabName(pDestConn, pNewSub->ptr_id()->pPrj->get_key(), pNewSub->ptr_id()->code,
                                                 Catalog.get_name(), Schema.get_name(), DestTopoTableRef) == GS_BAD)
                        break;
                  }

                  // Cancello il contenuto della tabella
                  if (gsc_DBDelRows(pDestConn->get_Connection(),
                                    pNewSub->ptr_info()->OldTableRef.get_name()) == GS_BAD)
                     break;
               
                  // copio il contenuto da una tabella all'altra
                  if (pDestConn->InitInsRow(pNewSub->ptr_info()->OldTableRef.get_name(),
                                            pInsCmd) == GS_BAD)
                     break;

                  statement = _T("SELECT * FROM ");
                  statement += pSub->ptr_info()->OldTableRef.get_name();
                  if (pSourceConn->OpenRecSet(statement, pReadRs, adOpenForwardOnly, adLockReadOnly, ONETEST) == GS_BAD)
                     break; 

                  // gsc_DBInsRowSet è implementato in una transaction
                  if (gsc_DBInsRowSet(pInsCmd, pReadRs, ONETEST) == GS_BAD)
                  {
                     gsc_DBCloseRs(pReadRs);
                     break;
                  }

                  gsc_DBCloseRs(pReadRs);
               }
               pNewSub->ptr_info()->TempLastId = pSub->ptr_info()->TempLastId;

               pSub    = (C_SUB *) pSub->get_next();
               pNewSub = (C_SUB *) pNewSub->get_next();
            }
            pNewCls->ptr_info()->TempLastId = ptr_info()->TempLastId;

            if (pSourceConn->ExistTable(SourceTopoTableRef) == GS_GOOD)
            {
               // copio il contenuto da una tabella topologica all'altra
               if (pDestConn->InitInsRow(DestTopoTableRef.get_name(), pInsCmd) == GS_BAD)
                  return GS_BAD;

               statement = _T("SELECT * FROM ");
               statement += SourceTopoTableRef;
               if (pSourceConn->OpenRecSet(statement, pReadRs, adOpenForwardOnly, adLockReadOnly, ONETEST) == GS_BAD)
                  return GS_BAD;

               // gsc_DBInsRowSet è implementato in una transaction
               if (gsc_DBInsRowSet(pInsCmd, pReadRs, ONETEST) == GS_BAD)
               {
                  gsc_DBCloseRs(pReadRs);
                  return GS_BAD;
               }

               gsc_DBCloseRs(pReadRs);
            }
         }

         // aggiorno ENT_LAST
         pNewCls->RefreshOldLastId();
         pNewCls->set_unlocked(0, GS_BAD, true); // senza notifica

         // se la classe ha rappresentazione grafica
         if (has_graph)
            if (AlignGraphDataOnCopyClass(pNewCls) == GS_BAD)
               break;

         result = GS_GOOD;
      }
      while (0);
   }

   if (result == GS_BAD)
   {
      C_PROJECT *pPrj;
      int PrevErrCode = GS_ERR_COD;

      // Cerca progetto nella lista GEOsimAppl::PROJECTS
      if ((pPrj = (C_PROJECT *) GEOsimAppl::PROJECTS.search_key(NewPrj)) == NULL)
         { GS_ERR_COD = PrevErrCode; return NULL; }
      // Cancello la classe
      if (pPrj->DelClass(NewCodeCls, (TCHAR *) GEOsimAppl::GS_USER.pwd) == GS_BAD) return NULL;
         { GS_ERR_COD = PrevErrCode; return NULL; }
      
      GS_ERR_COD = PrevErrCode;
      return NULL;      
   }

   // ricavo di nuovo il puntatore alla nuova classe (perchè AlignGraphDataOnCopyClass 
   // rilascia tutte la classe estratta per la copia degli oggetti grafici)
   if ((pNewCls = gsc_find_class(NewPrj, NewCodeCls)) == NULL) return NULL;

   return pNewCls;
}


/*********************************************************/
/*.doc C_CLASS::BeginTransaction              <internal> */
/*+                                                                       
  Effettua, se possibile, l'inizio delle transazioni dei db della classe.
  Parametri:
  int Mode;    Flag che indica se effettuare la transazione sul
               DB temporaneo o su quello originale (TEMP o OLD)
  bool Sec;    Flag che indica se effettuare la transazione anche sui DB
               delle tabelle secondarie (qualora risiedano in un DB 
               diverso da quello delle classi madri). Usato solo nel caso
               in cui <Mode> = OLD.
  C_STR_LIST &TransConnStrList; Lista che indica per quali connessioni OLE-DB
                                è stato possibile iniziare la transazione

  Ritorna GS_GOOD in caso di successo altrimenti GS_BAD.
-*/  
/*********************************************************/
int C_CLASS::BeginTransaction(int Mode, bool Sec, C_STR_LIST &TransConnStrList)
{
   C_INFO         *pInfo;
   C_SECONDARY    *psecondary;
   C_DBCONNECTION *pConn;

   TransConnStrList.remove_all();

   if (id.category == CAT_EXTERN)
   {
      C_SUB *pSub = (C_SUB *) ptr_sub_list()->get_head();

      if (!(pInfo = pSub->ptr_info())) return GS_BAD;
      pConn = pInfo->getDBConnection(Mode);

      if (pConn->BeginTrans() == GS_GOOD)
         if (TransConnStrList.add_tail_str(pConn->get_OrigConnectionStr()) == GS_BAD)
            return GS_BAD;

      // Se si considera il DB OLD e la grafica era in formato DB
      if (Mode == OLD && pSub->ptr_GphInfo() && 
          pSub->ptr_GphInfo()->getDataSourceType() == GSDBGphDataSource)
      {
         C_DBGPH_INFO *pGphConn = (C_DBGPH_INFO *) pSub->ptr_GphInfo();

         pConn = pGphConn->getDBConnection();
         if (TransConnStrList.search_name(pConn->get_OrigConnectionStr()) == NULL)
            if (pConn->BeginTrans() == GS_GOOD)
               if (TransConnStrList.add_tail_str(pConn->get_OrigConnectionStr()) == GS_BAD)
               {
                  RollbackTrans(TransConnStrList);
                  return GS_BAD;
               }
      }

      if (Mode == OLD && Sec && ptr_secondary_list)
      {  
         // Ciclo sulle tabelle secondarie
         while (pSub)
         {
            if (pSub->ptr_secondary_list)
            {
               psecondary = (C_SECONDARY *) pSub->ptr_secondary_list->get_head();
               while (psecondary)
               {
                  // se secondaria di GEOsim non ancora verificata
                  if (psecondary->get_type() == GSInternalSecondaryTable &&
                      (pConn = psecondary->ptr_info()->getDBConnection(OLD)) &&
                      TransConnStrList.search_name(pConn->get_OrigConnectionStr()) == NULL)
                     if (pConn->BeginTrans() == GS_GOOD)
                        if (TransConnStrList.add_tail_str(pConn->get_OrigConnectionStr()) == GS_BAD)
                        {
                           RollbackTrans(TransConnStrList);
                           return GS_BAD;
                        }

                  psecondary = (C_SECONDARY *) ptr_secondary_list->get_next();
               }
            }

            pSub = (C_SUB *) ptr_sub_list()->get_next();
         }
      }
   }
   else
   {
      // Se si considera il DB OLD e la grafica era in formato DB
      if (Mode == OLD && ptr_GphInfo() && 
          ptr_GphInfo()->getDataSourceType() == GSDBGphDataSource)
      {
         C_DBGPH_INFO *pGphConn = (C_DBGPH_INFO *) ptr_GphInfo();

         pConn = pGphConn->getDBConnection();
         if (pConn->BeginTrans() == GS_GOOD)
            if (TransConnStrList.add_tail_str(pConn->get_OrigConnectionStr()) == GS_BAD)
               return GS_BAD;
      }

      if ((pInfo = ptr_info()))
      {
         pConn = pInfo->getDBConnection(Mode);

         if (TransConnStrList.search_name(pConn->get_OrigConnectionStr()) == NULL)
            if (pConn->BeginTrans() == GS_GOOD)
               if (TransConnStrList.add_tail_str(pConn->get_OrigConnectionStr()) == GS_BAD)
               {
                  RollbackTrans(TransConnStrList);
                  return GS_BAD;
               }

         if (Mode == OLD && Sec && ptr_secondary_list)
         {  // Ciclo sulle tabelle secondarie
            psecondary = (C_SECONDARY *) ptr_secondary_list->get_head();
            while (psecondary)
            {
               // se secondaria di GEOsim non ancora verificata
               if (psecondary->get_type() == GSInternalSecondaryTable &&
                   (pConn = psecondary->ptr_info()->getDBConnection(OLD)) &&
                   TransConnStrList.search_name(pConn->get_OrigConnectionStr()) == NULL)
                  if (pConn->BeginTrans() == GS_GOOD)
                     if (TransConnStrList.add_tail_str(pConn->get_OrigConnectionStr()) == GS_BAD)
                     {
                        RollbackTrans(TransConnStrList);
                        return GS_BAD;
                     }

               psecondary = (C_SECONDARY *) ptr_secondary_list->get_next();
            }
         }
      }
   }

   return GS_GOOD;
}


/*********************************************************/
/*.doc C_CLASS::RollbackTrans                 <internal> */
/*+                                                                       
  Effettua, se possibile, il rollback delle transazioni dei db della classe.
  Parametri:
  C_STR_LIST &TransConnStrList; Lista che indica per quali connessioni OLE-DB
                                delle tabelle secondarie è stato possibile
                                iniziare la transazione

  Ritorna GS_GOOD in caso di successo altrimenti GS_BAD.
-*/  
/*********************************************************/
int C_CLASS::RollbackTrans(C_STR_LIST &TransConnStrList)
{
   C_STR          *pConnectionStr = (C_STR *) TransConnStrList.get_head();
   C_DBCONNECTION *pConn;

   pConnectionStr = (C_STR *) TransConnStrList.get_head();
   while (pConnectionStr)
   {
      if ((pConn = GEOsimAppl::DBCONNECTION_LIST.search_connection(pConnectionStr->get_name())))
         pConn->RollbackTrans();

      pConnectionStr = (C_STR *) pConnectionStr->get_next();
   }

   return GS_GOOD;
}


/*********************************************************/
/*.doc C_CLASS::CommitTrans                 <internal> */
/*+                                                                       
  Effettua, se possibile, il commit delle transazioni dei db della classe.
  Parametri:
  C_STR_LIST &TransConnStrList; Lista che indica per quali connessioni OLE-DB
                                delle tabelle secondarie è stato possibile
                                iniziare la transazione

  Ritorna GS_GOOD in caso di successo altrimenti GS_BAD.
-*/  
/*********************************************************/
int C_CLASS::CommitTrans(C_STR_LIST &TransConnStrList)
{
   C_STR          *pConnectionStr = (C_STR *) TransConnStrList.get_head();
   C_DBCONNECTION *pConn;

   pConnectionStr = (C_STR *) TransConnStrList.get_head();
   while (pConnectionStr)
   {
      if ((pConn = GEOsimAppl::DBCONNECTION_LIST.search_connection(pConnectionStr->get_name())))
         pConn->CommitTrans();

      pConnectionStr = (C_STR *) pConnectionStr->get_next();
   }

   return GS_GOOD;
}


/*********************************************************/
/*.doc C_CLASS::TerminateSQL                  <external> */
/*+
  Questa funzione annulla la connessione OLE-DB da terminare.
  Parametri:
  C_DBCONNECTION *pConnToTerminate; Opzionale; connessione da terminare,
                                    se non passata termina tutte le connessioni
                                    (default = NULL)
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
void C_CLASS::TerminateSQL(C_DBCONNECTION *pConnToTerminate)
{
   // se la classe ha un DB associato
   if (ptr_info()) ptr_info()->TerminateSQL(pConnToTerminate);

   // Se i dati geometrici sono in tabelle DB
   if (ptr_GphInfo() && ptr_GphInfo()->getDataSourceType() == GSDBGphDataSource)
       ((C_DBGPH_INFO *) ptr_GphInfo())->TerminateSQL(pConnToTerminate);

   if (ptr_sub_list())
   {
      C_SUB *pSub = (C_SUB *) ptr_sub_list()->get_head();

      // Per tutte le sottoclassi
      while (pSub)
      {
         pSub->TerminateSQL(pConnToTerminate);
         pSub = (C_SUB *) pSub->get_next();
      }
   }

   if (ptr_secondary_list)
   {
      C_SECONDARY *pSec = (C_SECONDARY *) ptr_secondary_list->get_head();

      // per tutte le secondarie
      while (pSec)
      {
         pSec->ptr_info()->TerminateSQL(pConnToTerminate);
         pSec = (C_SECONDARY *) pSec->get_next();
      }
   }
}


/**************************************************************/
/*.doc C_CLASS::CopySupportFiles                              */
/*+
   Funzione che copia i files di supporto per lista di valori degli 
   attributi per renderli disponibili per una altra classe.
   Parametri:
   C_CLASS *pDstCls;   puntatore alla classe di destinazione

   Ritorna GS_GOOD in caso di successo altrimenti GS_BAD.
-*/                                             
/**************************************************************/
int C_CLASS::CopySupportFiles(C_CLASS *pDstCls)
{
   if (get_category() == CAT_EXTERN && pDstCls->get_category() == CAT_EXTERN)
   {
      C_SUB *pSrcSub = (C_SUB *) ptr_sub_list()->get_head();
      C_SUB *pDstSub = (C_SUB *) pDstCls->ptr_sub_list()->get_head();

      while (pSrcSub && pDstSub)
      {
         pSrcSub->CopySupportFiles(pDstSub);

         pSrcSub = (C_SUB *) ptr_sub_list()->get_next();
         pDstSub = (C_SUB *) pDstCls->ptr_sub_list()->get_next();
      }

      return GS_GOOD;
   }

   if (ptr_attrib_list() || pDstCls->ptr_attrib_list())
      pDstCls->ptr_attrib_list()->CopySupportFiles(get_PrjId(),           // progetto
                                                   id.code,               // classe
                                                   id.sub_code,           // sottoclasse
                                                   0,                     // sec
                                                   pDstCls->get_PrjId(),
                                                   pDstCls->ptr_id()->code,
                                                   pDstCls->ptr_id()->sub_code,
                                                   0);

   if (ptr_secondary_list)
   {
      C_SECONDARY *pSrcSec = (C_SECONDARY *) ptr_secondary_list->get_head();
      C_SECONDARY *pDstSec = (C_SECONDARY *) pDstCls->ptr_secondary_list->get_head();

      while (pSrcSec && pDstSec)
      {
         pSrcSec->CopySupportFiles(pDstSec);

         pSrcSec = (C_SECONDARY *) ptr_secondary_list->get_next();
         pDstSec = (C_SECONDARY *) pDstCls->ptr_secondary_list->get_next();
      }
   }

   return GS_GOOD;
}


/**************************************************************/
/*.doc C_CLASS::DelSupportFiles                               */
/*+
   Funzione che cancella i files di supporto per lista di valori degli 
   attributi di una classe (o sottoclasse o tabella secondaria).
   Parametri:

   Ritorna GS_GOOD in caso di successo altrimenti GS_BAD.
-*/                                             
/**************************************************************/
int C_CLASS::DelSupportFiles(void)
{
   if (get_category() == CAT_EXTERN)
   {
      C_SUB *pSub = (C_SUB *) ptr_sub_list()->get_head();

      while (pSub)
      {
         pSub->DelSupportFiles();

         pSub = (C_SUB *) ptr_sub_list()->get_next();
      }

      return GS_GOOD;
   }

   if (ptr_attrib_list())
      ptr_attrib_list()->DelSupportFiles(get_PrjId(),           // progetto
                                         id.code,               // classe
                                         id.sub_code,           // sottoclasse
                                         0);                    // sec

   if (ptr_secondary_list)
   {
      C_SECONDARY *pSec = (C_SECONDARY *) ptr_secondary_list->get_head();

      while (pSec)
      {
         pSec->DelSupportFiles();

         pSec = (C_SECONDARY *) ptr_secondary_list->get_next();
      }
   }

   return GS_GOOD;
}


//-----------------------------------------------------------------------//
///////////////////        C_CLASS FINE     ///////////////////////////////
///////////////////   FUNZIONI SVILUPPO C - INIZIO   //////////////////////
//-----------------------------------------------------------------------//


/*********************************************************/
/*.doc gsc_del_db_conc <internal> */
/*+
  Questa funzione cancella la lista dei collegamenti della classe nei database.
  La cancellazione viene effettuata selezionando le connessioni della classe
  in oggetto ed in più, opzionalmente, le connessioni delle altre classi 
  che si connettono con la classe in oggetto (se mode = ALL).
  Parametri:
  C_PROJECT *pPrj;   puntatore a progetto
  int  cls;          codice classe
  int  mode;         flag di modo, se = ALL cancella le connessioni della classe
                     e delle altre classi che si connettono con la classe 
                     (default = ALL + 1)
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int gsc_del_db_conc(C_PROJECT *pPrj, int cls, int mode)
{
   C_DBCONNECTION *pConn;
   C_STRING       statement, TableRef;
   
   // setto il riferimento di GS_CONCT (<catalogo>.<schema>.<tabella>)
   if (pPrj->getConnectionsTabInfo(&pConn, &TableRef) == GS_BAD) return GS_BAD;

   statement = _T("DELETE FROM ");
   statement += TableRef;
   statement += _T(" WHERE CLASS_ID=");
   statement += cls;
   
   if (mode == ALL)
   {  // cancella le connessioni delle altre classi che si connettono con la classe
      statement += _T(" OR LNK_CL_ID=");
      statement += cls;
   } 

   // cancello le righe della tabella
   return pConn->ExeCmd(statement);
}   


/*********************************************************/
/*.doc gs_what_is_graph_updateable            <external> */
/*+                                                                       
  La funzione LISP restituisce un flag contenente la codifica 
  delle caratteristiche grafiche modificabili secondo GraphSettingsEnum.
  Parametri:
  (<Prj><Cls>[<Sub>])

  Restituisce RTNORM in caso di successo altrimenti restituisce RTERROR. 
-*/  
/*********************************************************/
int gs_what_is_graph_updateable(void)
{
   C_CLASS  *pCls;
   presbuf  arg;
   int      prj, cls, sub;
   long     BitForChangeFAS;

   acedRetNil();
   // Legge nella lista dei parametri: progetto classe e sub
   arg = acedGetArgs();
   if (arg_to_prj_cls_sub(&arg, &prj, &cls, &sub) == GS_BAD) return RTERROR;
   
   // Ritorna il puntatore alla classe cercata
   if ((pCls = gsc_find_class(prj, cls, sub)) == NULL) return RTERROR;

   // Questa funzione esamina il corpo della funzione di calcolo grafico 
   // restituendo quali caratteristiche grafiche sono modificate
   // dalle funzioni di calcolo grafico
   if ((BitForChangeFAS = pCls->what_is_graph_updateable()) == -1) return RTERROR;
   acedRetReal(BitForChangeFAS);

   return RTNORM;
}


/*********************************************************/
/*.doc gsc_is_inarea <internal> */
/*+
  Questa funzione LISP restituisce il codice della prima sessione di lavoro
  che sta usando la classe.
  Parametri:
  lista di resbuf (<prj><cls>)
  
  Restituisce RTNORM in caso di successo altrimenti restituisce RTERROR. 
-*/  
/*********************************************************/
int gs_is_inarea(void)
{
   presbuf arg = acedGetArgs();
   int     prj, cls;
   long    SessionCode;
   
   acedRetNil();
   if (!arg || arg->restype != RTSHORT) 
      { GS_ERR_COD = eGSInvalidArg; return RTERROR; }
   prj = arg->resval.rint;
   if (!(arg = arg->rbnext) || arg->restype != RTSHORT)
      { GS_ERR_COD = eGSInvalidArg; return RTERROR; }
   cls = arg->resval.rint;
   
   if (gsc_is_inarea(prj, cls, &SessionCode) == GS_BAD) return RTERROR;
   acedRetReal(SessionCode);

   return RTNORM;
}


/*********************************************************/
/*.doc gsc_is_inarea <internal> */
/*+
  Questa funzione restituisce in result se la classe è presente
  in una sessione di lavoro.
  Parametri:
  int prj;            codice del progetto
  int cls;            codice della classe
  long *SessionCode;  codice sessione di lavoro o 0 se non esiste
  int *FilterByUser;  punt. a codice utente per filtrare solo le sessioni
                      appartenenti ad un certo utente (default = NULL)
  long *ExceptionCode; Codice sessione da escludere nel controllo (default = NULL)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/  
/*********************************************************/
int gsc_is_inarea(int prj, int cls, long *SessionCode, int *FilterByUser, long *ExceptionCode)
{
   C_WRK_SESSION_LIST lista_aree;
   C_WRK_SESSION      *p_area;

   if (lista_aree.rarea(prj) == GS_BAD) return GS_BAD;

   *SessionCode = 0;
   p_area = (C_WRK_SESSION *) lista_aree.get_head();
   while (p_area)
   {
      // se impostato un filtro per utente verifico il proprietario della sessione oppure
      // se impostata una eccezione verifico la sessione da non controllare
      if ((FilterByUser && p_area->get_usr() != *FilterByUser) ||
          (ExceptionCode && p_area->get_id() == *ExceptionCode))
      {
         p_area = (C_WRK_SESSION *) lista_aree.get_next();
         continue;
      }
      // leggo le classi già estratte nella sessione
      if (p_area->get_pClsCodeList()->search_key(cls) != NULL) // classe nella sessiones
         { *SessionCode = p_area->get_id(); return GS_GOOD; }
      p_area = (C_WRK_SESSION *) lista_aree.get_next();
   }

   return GS_GOOD;
}


/*********************************************************/
/*.doc gsc_create_tab <internal> */
/*+
  Questa funzione crea una la tabella.
  Parametri:
  C_STRING       &TableRef;     Riferimento completo alla tabella
  C_DBCONNECTION *pConn;        Puntatore connessione OLE-DB
  C_ATTRIB_LIST  *p_attriblist; struttura della tabella
  C_STRING       &IndexName;    Nome dell'indice da creare
  C_STRING       &key_attrib;   nome dell'attributo di indicizzazione
  IndexTypeEnum  IndexMode;     tipo di indice da creare (default = PRIMARY_KEY)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/  
/*********************************************************/
int gsc_create_tab(C_STRING &TableRef, C_DBCONNECTION *pConn,
                   C_ATTRIB_LIST *p_attriblist, 
                   C_STRING &IndexName, C_STRING &key_attrib, IndexTypeEnum IndexMode)
{
   C_RB_LIST Stru;

   // ricavo la struttura della tabella
   if ((Stru << p_attriblist->to_rb_db()) == NULL) return GS_BAD;
   // creo tabella                                  
   if (pConn->CreateTable(TableRef.get_name(), Stru.get_head()) == GS_BAD) return GS_BAD;

   if (IndexName.len() > 0 && key_attrib.len() > 0)
      if (IndexMode == PRIMARY_KEY)
      {
         // Creo chiave primaria
         if (pConn->CreatePrimaryKey(TableRef.get_name(), IndexName.get_name(), 
                                     key_attrib.get_name()) == GS_BAD)
            // Se il provider non supporta la creazione di indice (vedi Excel) vado avanti comunque
            if (GS_ERR_COD != eGSExeNotSupported)
            {
               pConn->DelTable(TableRef.get_name());
               return GS_BAD;
            }
      }
      else
      {
         C_STRING  Catalog, Schema, Name, IndexRef;

         if (pConn->split_FullRefTable(TableRef, Catalog, Schema, Name) == GS_BAD)
            return GS_BAD;

         // creo indice per GS_ID
         if (IndexRef.paste(pConn->getNewFullRefIndex(Catalog.get_name(),
                                                      Schema.get_name(),
                                                      IndexName.get_name(),
                                                      NULL)) == NULL)
            return GS_BAD;
         if (pConn->CreateIndex(IndexRef.get_name(), TableRef.get_name(), key_attrib.get_name(),
                                IndexMode) == GS_BAD)
            // Se il provider non supporta la creazione di indice (vedi Excel) vado avanti comunque
            if (GS_ERR_COD != eGSExeNotSupported)
            {
               pConn->DelTable(TableRef.get_name());
               return GS_BAD;
            }
      }
   
   return GS_GOOD;
}   

  
/*********************************************************/
/*.doc gsc_default_to_db <internal> */
/*+
  Questa funzione modifica i valori di default della tabella.
  Parametri:
  C_DBCONNECTION *pConn;            Puntatore connessione OLE-DB
  const TCHAR *TableRef;            Riferimento alla tabella
  TCHAR *key_attrib;                campo chiave
  C_ATTRIB_LIST *p_attrib_list_old; vecchia lista degli attributi
  C_ATTRIB_LIST *p_attrib_list_new; nuova lista attributi

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/  
/*********************************************************/
int gsc_default_to_db(C_DBCONNECTION *pConn, const TCHAR *TableRef,
                      TCHAR *key_attrib, C_ATTRIB_LIST *p_attrib_list_old,
                      C_ATTRIB_LIST *p_attrib_list_new)
{
   _RecordsetPtr pRs;
   C_STRING      statement, FldName(key_attrib);
   presbuf       p;
   C_RB_LIST     def_val;
   long          Qty;

   if (!key_attrib || !p_attrib_list_old)
      { GS_ERR_COD = eGSInvalidArg; return GS_BAD; }
   if (!p_attrib_list_new) return GS_GOOD;

   // ricavo i valori di default della tabella
   if (p_attrib_list_new->get_StaticDefValues(def_val) == GS_BAD) return GS_BAD;
   
   // modifico GS_ID scrittura scheda default
   p = def_val.CdrAssoc(key_attrib);
   if (p != NULL) 
   { 
      presbuf pdef;

      if ((pdef = acutBuildList(RTLONG, 0, 0)) == NULL)
         { GS_ERR_COD = eGSOutOfMem; return GS_BAD; }
      if (gsc_sostitutebuf(pdef, p) == GS_BAD) return GS_BAD;
      acutRelRb(pdef);
   }
   else { GS_ERR_COD = eGSInvalidKey; return GS_BAD; }

   GS_CALC_CLASS = NULL;  // vedi calcolo campi calcolati dalla grafica

   // calcolo e validazione dei dati
   if (p_attrib_list_new->TestAllCalc(def_val) == GS_BAD || 
       p_attrib_list_new->TestAllValid(def_val) == GS_BAD)
      return GS_BAD;

   if (gsc_AdjSyntax(FldName, pConn->get_InitQuotedIdentifier(), pConn->get_FinalQuotedIdentifier(),
                     pConn->get_StrCaseFullTableRef()) == GS_BAD) return GS_BAD;

   // seleziono riga default della classe
   statement = _T("SELECT * FROM ");
   statement += TableRef;
   statement += _T(" WHERE ");
   statement += FldName;
   statement += _T("=0");
   
   // prima era adOpenKeyset poi adOpenDynamic ma PostgreSQL
   // in una transazione fa casino (al secondo recordset che viene aperto)
   if (pConn->OpenRecSet(statement, pRs, adOpenForwardOnly, adLockOptimistic) == GS_BAD) return GS_BAD;
   if (gsc_RowsQty(pRs, &Qty) == GS_BAD) { gsc_DBCloseRs(pRs); return GS_BAD; }
   if (Qty > 0)
   {  // modifico riga esistente
      if (gsc_DBUpdRow(pRs, def_val) == GS_BAD) { gsc_DBCloseRs(pRs); return GS_BAD; }
   }
   else // aggiungo nuova riga
      if (gsc_DBInsRow(pRs, def_val) == GS_BAD) { gsc_DBCloseRs(pRs); return GS_BAD; }

   if (gsc_DBCloseRs(pRs) == GS_BAD) return GS_BAD;

   return GS_GOOD;   
}
                                             

/*********************************************************/
/*.doc gsc_carattattr_to_db <internal> */
/*+
  Questa funzione scarica la lista delle caratteristiche degli attributi
  della classe nei database.
  Parametri:
  C_NODE *pPrj;                puntatore a progetto
  int code;                    codice classe
  int sub_code;                codice sottoclasse
  int sec_code;                codice tabella secondaria
  C_ATTRIB_LIST *p_attrib_list lista attributi

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/  
/*********************************************************/
int gsc_carattattr_to_db(C_NODE *pPrj, int code, int sub_code, int sec_code,
                         C_ATTRIB_LIST *p_attrib_list)
{
   C_DBCONNECTION *pConn;
   _RecordsetPtr  pRs;
   C_STRING       TableRef;
   C_RB_LIST      ColValues;
   C_ATTRIB       *pAttrib;
   int            Result = GS_BAD;
  
   // setto il riferimento di GS_ATTR (<catalogo>.<schema>.<tabella>)
   if (((C_PROJECT *)pPrj)->getAttribsTabInfo(&pConn, &TableRef) == GS_BAD) return GS_BAD;

   int IsTransactionSupported = pConn->BeginTrans();

   do
   {
      // Cancella informazioni non grafiche e grafiche degli attributi
      if (gsc_del_db_carattattr(pPrj, code, sub_code, sec_code) == GS_BAD) break;
 
      // informazioni NON grafiche degli attributi
      if (pConn->InitInsRow(TableRef.get_name(), pRs) == GS_BAD) break;
   
      // scorro l'elenco
      pAttrib = (C_ATTRIB *) p_attrib_list->get_head();
      Result = GS_GOOD;
      while (pAttrib)
      { 
         if ((ColValues << acutBuildList(RTLB,
                                         RTLB, RTSTR, _T("CLASS_ID"), RTSHORT, code, RTLE,
                                         RTLB, RTSTR, _T("SUB_CL_ID"), RTSHORT, sub_code, RTLE,
                                         RTLB, RTSTR, _T("SEC_ID"), RTSHORT, sec_code, RTLE,
                                         0)) == NULL)
            { Result = GS_BAD; break; }
         if ((ColValues += pAttrib->NoGraphInfoToRb(true)) == NULL)
            { Result = GS_BAD; break; }
         if ((ColValues += acutBuildList(RTLE, 0)) == NULL)
            { Result = GS_BAD; break; }

         if (gsc_DBInsRow(pRs, ColValues) == GS_BAD)
            { Result = GS_BAD; break; }
      
         pAttrib = (C_ATTRIB *) pAttrib->get_next();
      }

      if (gsc_DBCloseRs(pRs) == GS_BAD) { Result = GS_BAD; break; }
      if (Result == GS_BAD) break;

      // mi fermo qui se si tratta di tabella secondaria
      if (sec_code > 0) { Result = GS_GOOD; break; }

      /////////////////////////////////////////////////////////////////////////
      // setto il riferimento di GS_ATTR_GRAPH (<catalogo>.<schema>.<tabella>)
      if (((C_PROJECT *)pPrj)->getGraphAttribsTabInfo(&pConn, &TableRef) == GS_BAD) return GS_BAD;

      // informazioni grafiche degli attributi
      if (pConn->InitInsRow(TableRef.get_name(), pRs) == GS_BAD) break;
   
      // scorro l'elenco
      pAttrib = (C_ATTRIB *) p_attrib_list->get_head();
      Result = GS_GOOD;
      while (pAttrib)
      {
         if (pAttrib->is_visible() == GS_GOOD)
         {
            if ((ColValues << acutBuildList(RTLB,
                                            RTLB, RTSTR, _T("CLASS_ID"), RTSHORT, code, RTLE,
                                            RTLB, RTSTR, _T("SUB_CL_ID"), RTSHORT, sub_code, RTLE,
                                            0)) == NULL)
               { Result = GS_BAD; break; }
            if ((ColValues += pAttrib->GraphInfoToRb()) == NULL)
               { Result = GS_BAD; break; }
            if ((ColValues += acutBuildList(RTLE, 0)) == NULL)
               { Result = GS_BAD; break; }

            if (gsc_DBInsRow(pRs, ColValues) == GS_BAD)
               { Result = GS_BAD; break; }
         }

         pAttrib = (C_ATTRIB *) pAttrib->get_next();
      }

      if (gsc_DBCloseRs(pRs) == GS_BAD) { Result = GS_BAD; break; }
      if (Result == GS_BAD) break;

      Result = GS_GOOD;
   }
   while (0);

   if (Result == GS_GOOD)
      { if (IsTransactionSupported == GS_GOOD) pConn->CommitTrans(); }
   else
      { if (IsTransactionSupported == GS_GOOD) pConn->RollbackTrans(); }

   return Result;
}   


/*********************************************************/
/*.doc gsc_del_db_carattattr <internal> */
/*+
  Questa funzione cancella la lista delle caratteristiche degli attributi
  della classe nei database. (se il codice di sotto classe è negativo vengono
  considerate tutte le sottoclassi della classe, se il codice della secondaria 
  è negativo vengono considerate tutte le secondarie della classe)
  Parametri:
  C_NODE *pPrj;                puntatore a progetto
  int code;                    codice classe
  int sub_code;                codice sottoclasse
  int sec_code;                codice tabella secondaria

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/  
/*********************************************************/
int gsc_del_db_carattattr(C_NODE *pPrj, int code, int sub_code, int sec_code)
{
   C_STRING       statement, TableRef;
   C_DBCONNECTION *pConn;

   // setto il riferimento di GS_ATTR (<catalogo>.<schema>.<tabella>)
   if (((C_PROJECT *) pPrj)->getAttribsTabInfo(&pConn, &TableRef) == GS_BAD) return GS_BAD;

   statement = _T("DELETE FROM ");
   statement += TableRef;
   statement += _T(" WHERE CLASS_ID=");
   statement += code;

   if (sub_code >= 0)
   {
      statement += _T(" AND SUB_CL_ID=");
      statement += sub_code;
   }
   if (sec_code >= 0)
   {
      statement += _T(" AND SEC_ID=");
      statement += sec_code;
   }

   // cancello le righe della tabella
   if (pConn->ExeCmd(statement) != GS_GOOD) return GS_BAD;

   // mi fermo qui se si tratta di tabella secondaria
   if (sec_code > 0) return GS_GOOD;

   ////////////////////////////////////////////////////////////////////////////
   // setto il riferimento di GS_ATTR_GRAPH (<catalogo>.<schema>.<tabella>)
   if (((C_PROJECT *) pPrj)->getGraphAttribsTabInfo(&pConn, &TableRef) == GS_BAD) return GS_BAD;

   statement = _T("DELETE FROM ");
   statement += TableRef;
   statement += _T(" WHERE CLASS_ID=");
   statement += code;

   if (sub_code >= 0)
   {
      statement += _T(" AND SUB_CL_ID=");
      statement += sub_code;
   }

   // cancello le righe della tabella
   return pConn->ExeCmd(statement);
} 


/*********************************************************/
/*.doc gsc_del_db_ClassSet                    <internal> */
/*+
  Questa funzione cancella la classe dal set di classi del progetto
  nel database.
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/  
/*********************************************************/
int gsc_del_db_ClassSet(C_NODE *pPrj, int cls)
{
   C_CLASS_SET ClassSet;

   if (ClassSet.from_db(pPrj) == GS_BAD) return GS_BAD;
   if (ClassSet.RemoveCls(cls) == GS_BAD) return GS_BAD;
   return ClassSet.to_db(pPrj);
}


/*********************************************************/
/*.doc (new 2) gsc_CheckValidFuncOnData <internal> */
/*+
  Questa funzione verifica le funzioni di validità prendendole
  da una struttura passata come parametro. Verifica che eventuali dati 
  già presenti soddisfino le funzioni (saltando la scheda di default).
  Parametri:
  C_DBCONNECTION *pClsConn;      Puntatore a connessione OLE-DB
  const TCHAR    *TableRef;      Riferimento completo alla tabella
  C_ATTRIB_LIST  *p_attrib_list; Lista attributi da cui leggere le funzioni
                                 di calcolo
  TCHAR *key_attrib;             campo chiave

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int gsc_CheckValidFuncOnData(C_DBCONNECTION *pConn, const TCHAR *TableRef,
                             C_ATTRIB_LIST *p_attrib_list, TCHAR *key_attrib)
{
   C_STRING      statement; 
   C_RB_LIST	  ColValues;
   _RecordsetPtr pRs;

   // preparo la statement
   statement = _T("SELECT * FROM ");
   statement += TableRef;
   if (key_attrib)
   {
      C_STRING FldName;

      statement += _T(" WHERE ");
      FldName = key_attrib;
      if (gsc_AdjSyntax(FldName, pConn->get_InitQuotedIdentifier(), pConn->get_FinalQuotedIdentifier(),
                        pConn->get_StrCaseFullTableRef()) == GS_BAD) return GS_BAD;
      statement += FldName;
      statement += _T("<>0");
   }

   if (pConn->OpenRecSet(statement, pRs) == GS_BAD) return GS_BAD;
   
   // scorro l'elenco delle entità della classe
   while (gsc_isEOF(pRs) == GS_BAD)
   {
      if (gsc_DBReadRow(pRs, ColValues) == GS_BAD) break;

      if (p_attrib_list->validate_all(ColValues) == GS_BAD)
      {
         gsc_DBCloseRs(pRs);

         if (key_attrib)
         {
            TCHAR   Msg[MAX_LEN_MSG];
            presbuf p;
            long    Key;

            // GS_ID
            if ((p = ColValues.CdrAssoc(key_attrib)) != NULL)
               if (gsc_rb2Lng(p, &Key) == GS_GOOD)
               { // "\nLa scheda %ld nella tabella <%s> non soddisfa la funzione di validità."
                  swprintf(Msg, MAX_LEN_MSG, gsc_msg(302), Key, TableRef);
                  gsc_write_log(Msg);
               }
         }
         return GS_BAD;
      }

      gsc_Skip(pRs);
   }
   
   return gsc_DBCloseRs(pRs);
}

    
/*********************************************************/
/*.doc (new 2) gsc_ChangeCalcFuncOnData <internal> */
/*+
  Questa funzione ricalcola i campi calcolati con le funzioni di calcolo
  prendendole da una struttura passata come parametro.
  Parametri:
  C_DBCONNECTION *pClsConn;      Puntatore a connessione OLE-DB
  const TCHAR    *TableRef;      Riferimento completo alla tabella
  C_ATTRIB_LIST *p_attrib_list;  lista attributi da cui leggere le funzioni
                                 di calcolo
  TCHAR *key_attrib;             campo chiave

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int gsc_ChangeCalcFuncOnData(C_DBCONNECTION *pConn, const TCHAR *TableRef,
                             C_ATTRIB_LIST *p_attrib_list, TCHAR *key_attrib)
{
   C_STRING      statement; 
   C_RB_LIST	  ColValues;
   _RecordsetPtr pRs;

   // preparo la statement
   statement = _T("SELECT * FROM ");
   statement += TableRef;

   if (pConn->OpenRecSet(statement, pRs, adOpenDynamic, adLockOptimistic) == GS_BAD) return GS_BAD;
   
   // scorro l'elenco delle entità della classe
   while (gsc_isEOF(pRs) == GS_BAD)
   {
      if (gsc_DBReadRow(pRs, ColValues) == GS_BAD) break;
   
      GS_CALC_CLASS = NULL; // non calcolo i valori da grafica (vedi funzioni di calcolo)

      // ricalcolo (con controllo valore dati per gli attributi calcolati),
      // controllo di tutti i valori e validazione dei dati
      if (p_attrib_list->calc_all(ColValues, MODIFY_ON_STRUCT_UPD) == GS_BAD ||
          p_attrib_list->CheckValues(ColValues) == GS_BAD ||
          p_attrib_list->validate_all(ColValues) == GS_BAD)
      {
         gsc_DBCloseRs(pRs);

         if (key_attrib)
         {
            TCHAR   Msg[MAX_LEN_MSG];
            presbuf p;
            long    Key;

            // GS_ID
            if ((p = ColValues.CdrAssoc(key_attrib)) != NULL)
               if (gsc_rb2Lng(p, &Key) == GS_GOOD)
               { // "\nLa scheda %ld nella tabella <%s> non soddisfa la funzione di calcolo."
                  swprintf(Msg, MAX_LEN_MSG, gsc_msg(303), Key, TableRef);
                  gsc_write_log(Msg);
               }
         }
         return GS_BAD;
      }

      // aggiorno il record
      if (gsc_DBUpdRow(pRs, ColValues) == GS_BAD) // Converto campi data
         { gsc_DBCloseRs(pRs); return GS_BAD; }

      gsc_Skip(pRs);
   }

   return gsc_DBCloseRs(pRs);
}


/*********************************************************/
/*.doc (new 2) gsc_CheckMandatoryOnData <internal> */
/*+
  Questa funzione ricalcola i campi calcolati con le funzioni di calcolo
  prendendole da una struttura passata come parametro.
  Parametri:
  C_DBCONNECTION *pClsConn;      Puntatore a connessione OLE-DB
  const TCHAR    *TableRef;      Riferimento completo alla tabella
  C_ATTRIB_LIST  *p_attrib_list; Lista attributi da cui leggere gli
                                 attributi obbligatori
  bool           AssignDefault;  Flag, se = TRUE se viene incontrato un 
                                 attributo che non soddisfa l'obbligatorietà 
                                 viene settato il valore di default
                                 (default = FALSE)
  bool       *VisAttribModified; Usato solo se il parametro "AssignDefault" = TRUE
                                 viene impostato a TRUE se è stato modificato il valore
                                 di qualche attributo visibile (default = NULL)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int gsc_CheckMandatoryOnData(C_DBCONNECTION *pConn, const TCHAR *TableRef, 
                             C_ATTRIB_LIST *p_attrib_list, bool AssignDefault,
                             bool *VisAttribModified)
{
   C_STRING Cond, FldName; 
   C_ATTRIB *pAttrib;

   pAttrib = (C_ATTRIB*) p_attrib_list->get_head();

   if (!AssignDefault)
   {
      int  Mandatory = FALSE;
      long n_entities;

      // c'è almeno un attributo obbligatorio ?
      while (pAttrib != NULL)
      {
         if (pAttrib->is_mandatory())
         {
            if (!Mandatory) Mandatory = TRUE;
            else Cond += _T(" OR ");

            FldName = pAttrib->name;
            if (gsc_AdjSyntax(FldName, pConn->get_InitQuotedIdentifier(), pConn->get_FinalQuotedIdentifier(),
                              pConn->get_StrCaseFullTableRef()) == GS_BAD) return GS_BAD;

            Cond += FldName;
            Cond += _T(" IS NULL");
         }
         pAttrib = (C_ATTRIB*) p_attrib_list->get_next();
      }
      if (!Mandatory) return GS_GOOD;

      // conto le righe della tabella
      n_entities = pConn->RowsQty(TableRef, Cond.get_name());

      if (n_entities > 0)
      {
         TCHAR Msg[MAX_LEN_MSG];

         // "\nCi sono %ld schede nella tabella <%s> che non soddisfano la regola di obbligatorietà."
         swprintf(Msg, MAX_LEN_MSG, gsc_msg(303), n_entities, TableRef);
         gsc_write_log(Msg);

         return GS_BAD;
      }

      return (n_entities > 0) ? GS_BAD : GS_GOOD;
   }
   else
   {
      if (VisAttribModified) *VisAttribModified = FALSE;

      // Inizializzo i tipi ADO per ogni attributo
      if (p_attrib_list->init_ADOType(pConn) == GS_BAD) return GS_BAD;

      // c'è almeno un attributo obbligatorio ?
      while (pAttrib != NULL)
      {
         if (pAttrib->is_mandatory())
         {
            C_STRING      statement;
            long          Qty = 0;
            _RecordsetPtr pRs;
            C_RB_LIST     ColValues;
            presbuf       p;
            int           Result = GS_GOOD;

            FldName = pAttrib->name;
            if (gsc_AdjSyntax(FldName, pConn->get_InitQuotedIdentifier(), pConn->get_FinalQuotedIdentifier(),
                              pConn->get_StrCaseFullTableRef()) == GS_BAD) return GS_BAD;

            statement = _T("SELECT ");
            statement += FldName;
            statement += _T(" FROM ");
            statement += TableRef;
            statement += _T(" WHERE ");
            statement += FldName;
            statement += _T(" IS NULL");

            if (pConn->OpenRecSet(statement, pRs, adOpenDynamic, adLockOptimistic) == GS_BAD)
               return GS_BAD;
            if (gsc_InitDBReadRow(pRs, ColValues) == GS_BAD) 
               { gsc_DBCloseRs(pRs); return GS_BAD; }
            if ((p = ColValues.CdrAssoc(pAttrib->name.get_name())) == NULL)
               { gsc_DBCloseRs(pRs); return GS_BAD; }

            while (gsc_isEOF(pRs) == GS_BAD)
            {
               if (gsc_DBReadRow(pRs, ColValues) == GS_BAD) { Result = GS_BAD; break; }
               // aggiorno il record
               gsc_RbSubst(p, pAttrib->def);
               if (gsc_DBUpdRow(pRs, ColValues) == GS_BAD) { Result = GS_BAD; break; }
               Qty++;

               gsc_Skip(pRs);
            }
            gsc_DBCloseRs(pRs);

            // Se è stato modificato il valore di un attributo visibile
            if (VisAttribModified && pAttrib->vis == GS_GOOD && Qty > 0)
               *VisAttribModified = TRUE;
         }
         pAttrib = (C_ATTRIB*) p_attrib_list->get_next();
      }

      return GS_GOOD;
   }
}


/*********************************************************/
/*.doc gsc_crea_grp_tablink <external> */
/*+
  Questa funzione crea la tabella dei link per i gruppi.
  Parametri:
  C_DBCONNECTION *pConn;         Puntatore a connessione OLE-DB
  C_STRING       &LnkTableRef;   Riferimento completo alla tabella dei link

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int gsc_crea_grp_tablink(C_DBCONNECTION *pConn, C_STRING &LnkTableRef)
{  
   long      KeyAttr_len, ClsID_len;
   int       KeyAttr_dec, ClsID_dec;
   C_STRING  KeyAttr_ProviderDescr, ClsID_ProviderDescr;
   C_STRING  Catalog, Schema, Name, IndexName;
   C_RB_LIST Stru;
   
   // converto campo da codice ADO in Provider dipendente (numero intero)
   if (pConn->Type2ProviderType(KEY_TYPE_ENUM, // DataType per campo chiave tab. GEOsim
                                FALSE,         // IsLong
                                FALSE,         // IsFixedPrecScale
                                RTT,           // IsFixedLength
                                TRUE,          // IsWrite
                                LEN_KEY_ATTR,  // Size
                                0,             // Prec
                                ClsID_ProviderDescr, // ProviderDescr
                                &ClsID_len, &ClsID_dec) == GS_BAD)
      return GS_BAD;

   // converto campo da codice ADO in Provider dipendente (numero intero)
   if (pConn->Type2ProviderType(CLASS_KEY_TYPE_ENUM, // DataType per campo chiave tab. classi
                                FALSE,               // IsLong
                                FALSE,               // IsFixedPrecScale
                                RTT,                 // IsFixedLength
                                TRUE,                // IsWrite
                                CLASS_LEN_KEY_ATTR,  // Size
                                0,                   // Prec
                                KeyAttr_ProviderDescr, // ProviderDescr
                                &KeyAttr_len, &KeyAttr_dec) == GS_BAD)
      return GS_BAD;

   if ((Stru << acutBuildList(RTLB,
   /* CODICE UNIVOCO DELLA */      RTLB,
   /* ENTITA' GRUPPO  */              RTSTR, _T("KEY_ATTRIB"),
                                         RTSTR, KeyAttr_ProviderDescr.get_name(),
                                         RTLONG, KeyAttr_len,
                                         RTSHORT, KeyAttr_dec,
                                   RTLE,
   /* CODICE DELLA CLASSE DELLA */ RTLB, 
   /* ENTITA' CHE HA UN LINK */          RTSTR, _T("CLASS_ID"),
   /* CON L'ENTITA' GRUPPO */         RTSTR, ClsID_ProviderDescr.get_name(),
                                         RTLONG, ClsID_len,
                                         RTSHORT, ClsID_dec,
                                   RTLE,
   /* CODICE DELL'ENTITA' CHE */   RTLB,
   /* HA UN LINK CON L'ENTITA' */        RTSTR, _T("ENT_ID"),
   /* GRUPPO */                       RTSTR, KeyAttr_ProviderDescr.get_name(),
                                         RTLONG, KeyAttr_len,
                                         RTSHORT, KeyAttr_dec,
                                   RTLE,
                             RTLE, 0)) == NULL)
      return GS_BAD;


   if (pConn->CreateTable(LnkTableRef.get_name(), Stru.get_head()) == GS_BAD)
      return GS_BAD;

   if (pConn->split_FullRefTable(LnkTableRef, Catalog, Schema, Name) == GS_BAD)
      return GS_BAD;

   return GS_GOOD;  
}    


/*********************************************************/
/*.doc gsc_del_grp_tab_link               <internal> */
/*+
  Questa funzione cancella la tabella dei link della classe gruppo.
  Parametri:
  C_DBCONNECTION *pConn;      Connessione OLE-DB per la classe
  C_STRING       &TableRef;   Riferimento completo alla tabella

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/  
/*********************************************************/
int gsc_del_grp_tab_link(C_DBCONNECTION *pConn, C_STRING &TableRef)
{
   C_STRING LinkTableRef, Catalog, Schema, Table;

   if (pConn->split_FullRefTable(TableRef, Catalog, Schema, Table) == GS_BAD)
      return GS_BAD;
   Table += _T("L");  // "L" per Link
   LinkTableRef.paste(pConn->get_FullRefTable(Catalog, Schema, Table));

   if (pConn->ExistTable(LinkTableRef) == GS_BAD) return GS_GOOD;
   // cancello la tabella
   return pConn->DelTable(LinkTableRef.get_name());
}


/*********************************************************/
/*.doc gsc_del_db_grp_rel <internal> */
/*+
  Questa funzione cancella la lista delle relazioni della classe nei database.
  Parametri:
  C_PROJECT *pPrj;     puntatore a progetto
  int       cls;       Struttura di identificazione classe
  
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD. 
-*/  
/*********************************************************/
int gsc_del_db_grp_rel(C_PROJECT *pPrj, int cls)
{
   C_DBCONNECTION *pConn;
   C_STRING       statement, TableRef;
   
   // setto il riferimento di GS_GROUP (<catalogo>.<schema>.<tabella>)
   if (pPrj->getGrpsTabInfo(&pConn, &TableRef) == GS_BAD) return GS_BAD;

   statement = _T("DELETE FROM ");
   statement += TableRef;
   statement += _T(" WHERE CLASS_ID=");
   statement += cls;
 
   // cancello le righe della tabella
   return pConn->ExeCmd(statement);
}   


/*********************************************************/
/*.doc gsc_is_from_graph <external> */
/*+
  Questa funzione, verifica se la funzione di calcolo passata come parametro
  riceve i dati da una caratteristica grafica (area, lunghezza, ...).
    
  Parametri:
  const TCHAR *func_calc;      funzione di calcolo

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
  N.B. le funzioni di calcolo grafico devono essere espresse in forma esplicita
       per ogni attributo e non possono essere quindi contenute in un file LISP.
       La funzione di calcolo deve essere la sola espressa come funzione di
       calcolo per ogni attributo (es. ".AREA" va bene, "(+ .AREA 1)" non va bene)
-*/  
/*********************************************************/
int gsc_is_from_graph(const TCHAR *func_calc)
{
   C_STRING str;

   if (!func_calc) return GS_BAD;

   str = func_calc;
   str.alltrim();
   str.toupper();

   for (long i = 0; i < VectorFromGraphGEOLispFunctionsLen(); i++)
      if (str.comp(VectorFromGraphGEOLispFunctions[i].Name, 0) == 0)
         return GS_GOOD;

   return GS_BAD;
}


/*********************************************************/
/*.doc gsc_get_default_from_graph <external> */
/*+
  Questa funzione, restituisce il valore di default per le funzioni di
  calcolo da grafica (area, lunghezza, ...).
    
  Parametri:
  const TCHAR *func_calc;      funzione di calcolo

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
resbuf *gsc_get_default_from_graph(const TCHAR *func_calc)
{
   C_STRING str;

   if (!func_calc) return GS_BAD;

   str = func_calc;
   str.alltrim();
   str.toupper();

   for (long i = 0; i < VectorFromGraphGEOLispFunctionsLen(); i++)
      if (str.comp(VectorFromGraphGEOLispFunctions[i].Name, 0) == 0)
         if (gsc_strcmp(VectorFromGraphGEOLispFunctions[i].Type, _T("real"), 0) == 0)
            return acutBuildList(RTREAL, _wtof(VectorFromGraphGEOLispFunctions[i].DefVal), 0);
         else
         if (gsc_strcmp(VectorFromGraphGEOLispFunctions[i].Type, _T("short"), 0) == 0)
            return acutBuildList(RTSHORT, _wtoi(VectorFromGraphGEOLispFunctions[i].DefVal), 0);
         else
         if (gsc_strcmp(VectorFromGraphGEOLispFunctions[i].Type, _T("point"), 0) == 0)
            return acutBuildList(RTSTR, VectorFromGraphGEOLispFunctions[i].DefVal, 0);
         else
         if (gsc_strcmp(VectorFromGraphGEOLispFunctions[i].Type, _T("long"), 0) == 0)
            return acutBuildList(RTREAL, _wtof(VectorFromGraphGEOLispFunctions[i].DefVal), 0);
         else
         if (gsc_strcmp(VectorFromGraphGEOLispFunctions[i].Type, _T("string"), 0) == 0)
            return acutBuildList(RTSTR, VectorFromGraphGEOLispFunctions[i].DefVal, 0);
         else
            return NULL;
   
   return NULL;
}


/*+
-------------------------------------------------------------
int gs_get_class_ord(void)
int gsc_get_class_ord(int prj,int cls,int sub)

  Ritorna il grado di una classe.
  Per grado di una classe si intende il livello di complessita'
  di relazione con le altre classi.
  Per esempio le classi semplici,spaghetti,simulazioni sono di 
  grado 1; i gruppi di semplici sono di grado 2; 
  i gruppi di gruppi di semplici sono di grado 3 e cosi' 
  via.
-------------------------------------------------------------
-*/
int gs_get_class_ord(void)
{
   resbuf *arg;
   int    a, b, c;
   
   acedRetNil();
   arg=acedGetArgs();
   if (arg==NULL || arg->restype!=RTSHORT) 
      { GS_ERR_COD=eGSInvalidArg; return RTERROR; }
   a=arg->resval.rint;
   arg=arg->rbnext;
   if (arg==NULL || arg->restype!=RTSHORT)
      { GS_ERR_COD=eGSInvalidArg; return RTERROR; }
   b=arg->resval.rint;
   arg=arg->rbnext;
   if (arg==NULL || arg->restype!=RTSHORT) c=0;
   else c=arg->resval.rint;

   if ((a=gsc_get_class_ord(a,b,c))==0) return RTERROR;
   acedRetInt(a);
   return RTNORM;
}

int gsc_get_class_ord(int prj,int cls,int sub)
{
   C_CLASS        *pclasse;
   C_GROUP_LIST *compl;
   C_NODE         *punt;
   int            order, tmp;

   if ((pclasse = gsc_find_class(prj, cls, sub)) == NULL) return 0;

   order = 0;
   if ((compl = pclasse->ptr_group_list()) != NULL)
   {
      punt = compl->get_head();
      while (punt!=NULL)
      {
         if (sub==0) tmp=gsc_get_class_ord(prj,punt->get_key(),0);
         else        tmp=gsc_get_class_ord(prj,cls,punt->get_key());
         if (tmp==0) return 0;
         if (tmp>order) order=tmp;
         punt=punt->get_next();
      }
   }
   order++;

   return order;
}


/*********************************************************/
/*.doc gsc_getClassBitmap                     <external> */
/*+
  Funzione che restituisce la bitmap della classe.
  Parametri:
  int category;      Categoria della classe di GEOsim
  int type;          Tipo della classe di GEOsim
  C_COLOR &color;    Colore della classe di GEOsim
  bool LargeSize;    Se vero la dimensione della bitmap sarà di 32x16
                     altrimenti sarà di 16x16
  CBitmap &CBMP;     Oggetto bitmap (output)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int gsc_getClassBitmap(int category, int type, C_COLOR &color, bool LargeSize, CBitmap &CBMP)
{
   UINT nIDResource;
   // When resource from this ARX app is needed, just
   // instantiate a local CAcModuleResourceOverride
   CAcModuleResourceOverride myResources;

	switch (category)
	{
		case CAT_SIMPLEX:
      {
			switch (type)
   		{
				case TYPE_POLYLINE:
					nIDResource = (LargeSize) ? IDB_POLYLINE_MASK_32X16 : IDB_POLYLINE_MASK_16X16;
					break;
				case TYPE_TEXT:
					nIDResource = (LargeSize) ? IDB_TEXT_MASK_32X16 : IDB_TEXT_MASK_16X16;
					break;
				case TYPE_NODE:
					nIDResource = (LargeSize) ? IDB_NODE_MASK_32X16 : IDB_NODE_MASK_16X16;
					break;
				case TYPE_SURFACE:
					nIDResource = (LargeSize) ? IDB_SURFACE_MASK_32X16 : IDB_SURFACE_MASK_16X16;
					break;
            default:
               return GS_BAD;
			}
			break;
      }
		case CAT_GROUP:
         color.setForeground();
			nIDResource = (LargeSize) ? IDB_GROUP_MASK_32X16 : IDB_GROUP_MASK_16X16;
			break;
		case CAT_GRID:
         color.setForeground();
			nIDResource = (LargeSize) ? IDB_GRID_MASK_32X16: IDB_GRID_MASK_16X16;
			break;
   	case CAT_EXTERN:
         color.setForeground();
			nIDResource = (LargeSize) ? IDB_SIMULATION_MASK_32X16: IDB_SIMULATION_MASK_16X16;
		   break;
		case CAT_SPAGHETTI:
			nIDResource = (LargeSize) ? IDB_SPAGHETTI_MASK_32X16 : IDB_SPAGHETTI_MASK_16X16;
			break;
      default:
         return GS_BAD;
   }

   HBITMAP hBitmap=LoadBitmap(_AtlBaseModule.GetResourceInstance(), MAKEINTRESOURCE(nIDResource));
   HGDIOBJ obj = CBMP.Detach();
   if (obj) ::DeleteObject(obj);
   if (CBMP.Attach(hBitmap) == false) return GS_BAD;
   //if (CBMP.LoadBitmap(nIDResource) == 0) return GS_BAD;

	if (color.getColorMethod() == C_COLOR::ByRGBColor ||
       color.getColorMethod() == C_COLOR::ByAutoCADColorIndex)
	{
      COLORREF crTo, crFrom;

      // Le bitmap sono con i colori da cambiare devono essere fatte in nero con sfondo bianco
      crFrom = RGB(0, 0, 0);	//	nero
		color.getRGB(&crTo);
      gsc_ChangeColorToBmp((HBITMAP) CBMP, crFrom, crTo);
   }

   return GS_GOOD;
}


/*********************************************************/
/*.doc gs_copy_class                         <external> */
/*+
  Questa funzione copia una classe di GEOsim.
  Parametri:
  Lista RESBUF
  (prj cls newPrj newNameCls newDescrCls
   (<UDLConnStr> <property list> <riferimento tabella>) | nil
   copyType [(fas1 fas2 ...)|(newLink1 newLink2 ...)
   [(<sec_list1> <sec_list2> ...)])]

  dove:
  <UDLConnStr>          = <file UDL> || <stringa di connessione>
  <property list>       = nil || ((prop.UDL)(Val.prop.)...)
  <riferimento tabella> = (<cat><sch><tab>)
  (fas1 fas2 ...)       = lista di fas
  <sec_list>            = (0|<sub>(<sel><sec><name><type><copytype><dblist>)
                          0 -> per semplici; sub -> per simulazioni
  <dblist>              = (<UDLConnStr> <property list> <riferimento tabella>)
  <UDLConnStr>          = <file UDL> || <stringa di connessione>
  <property list>       = nil || ((prop.UDL)(Val.prop.)...)
  <riferimento tabella> = (<cat><sch><tab>)

  Ritorna il codice della nuova classe in caso di successo altrimenti NULL.
-*/  
/*********************************************************/
int gs_copy_class(void)
{
   int             prj, cls;
	presbuf         arg;
	C_CLASS         *pold_cls, *pNewCls;
   C_INFO          InfoConn;
	C_FAS_LIST      fasList;
   C_GPH_INFO_LIST GraphInfoList;
   Common_Dcl_main_copy_class_Struct CommonStruct;
   C_GROUP_LIST    NewGroupList;
              
   acedRetNil();

   // ricavo i valori impostati
   arg = acedGetArgs();

   if (arg == NULL || arg->restype != RTSHORT) { GS_ERR_COD = eGSInvalidArg; return RTERROR; }
	else prj = arg->resval.rint;             // codice del progetto origine

   arg = arg->rbnext;
   if (arg == NULL || arg->restype != RTSHORT) { GS_ERR_COD = eGSInvalidArg; return RTERROR; }
   cls = arg->resval.rint;                      // codice classe origine

   arg = arg->rbnext;
   if (arg == NULL || arg->restype != RTSHORT) { GS_ERR_COD = eGSInvalidArg; return RTERROR; }
   CommonStruct.new_prj = arg->resval.rint;     // codice progetto destinazione 

   arg = arg->rbnext;                           // nome classe destinazione 
   if (arg == NULL || arg->restype != RTSTR) { GS_ERR_COD = eGSInvalidArg; return RTERROR; }
   gsc_strcpy(CommonStruct.nom_cls, arg->resval.rstring, MAX_LEN_CLASSNAME); 

   arg = arg->rbnext;                           // descrizione classe destinazione 
   if (arg == NULL) { GS_ERR_COD = eGSInvalidArg; return RTERROR; }
   if (arg->restype == RTSTR) CommonStruct.descr_cls = arg->resval.rstring;

   if ((arg = arg->rbnext) == NULL) { GS_ERR_COD = eGSInvalidArg; return RTERROR; }

   if ((pold_cls = gsc_find_class(prj, cls)) == NULL) return RTERROR;

   if (pold_cls->ptr_info())
   {
      if ((InfoConn.from_rb(arg)) == GS_BAD) return RTERROR;

      CommonStruct.TableRef.set_name(InfoConn.OldTableRef.get_name());
	   // Riferimento completo alla tabella OLD
	   CommonStruct.ConnStrUDLFile.set_name(InfoConn.ConnStrUDLFile.get_name());
	   // Stringa di connessione o File di tipo .UDL
	   InfoConn.UDLProperties.copy(CommonStruct.PropList);   // Lista di proprietà UDL
   }

   if (arg ->restype == RTLB)
	   // scorro la lista fino all'elemento successivo
      if ((arg = gsc_scorri(arg)) == NULL) { GS_ERR_COD = eGSInvalidArg; return RTERROR; }

	arg = arg->rbnext;
   if (arg == NULL || arg->restype != RTSHORT) { GS_ERR_COD = eGSInvalidArg; return RTERROR; }
   // tipologia di copia (GSStructureAndDataCopyType=0, GSStructureOnlyCopyType=1, GSDataLinkCopyType=2)
   CommonStruct.CopyType = (DataCopyTypeEnum) arg->resval.rint;

   arg = arg->rbnext;
   if (arg)
   {
      if (arg->restype == RTLB) 
      // argomento opzionale: nuova/e FAS oppure in caso di gruppo 
      // la nuova lista di relazioni con le classi figlie
      {
	      if (fasList.from_rb(arg) == GS_GOOD)
         {
	         fasList.copy(CommonStruct.fasList);
            arg = gsc_scorri(arg); // vado in fondo alla lista delle FAS

            arg = arg->rbnext;
            if (!arg || arg->restype != RTLB)
               { GS_ERR_COD = eGSInvalidArg; return RTERROR; }

	         if (GraphInfoList.from_rb(arg) == GS_BAD)
               { GS_ERR_COD = eGSInvalidArg; return RTERROR; }
            GraphInfoList.copy(CommonStruct.GraphInfoList);
         }
         else
            NewGroupList.from_rb(arg);

         // vado in fondo alla lista delle Informaz. grafiche (se esiste la lista di FAS)
         // oppure in fondo alla lista della nuova composizione del gruppo
         arg = gsc_scorri(arg);
      }

      arg = arg->rbnext; // vado all'elemento successivo della lista
   }
	// lancio la funzione che effettua la copia classe
   if ((pNewCls = pold_cls->CopyToPrj(CommonStruct.new_prj, CommonStruct.nom_cls,
		                                CommonStruct.descr_cls.get_name(),
                                      CommonStruct.TableRef.get_name(), 
												  CommonStruct.ConnStrUDLFile.get_name(),
												  InfoConn.UDLProperties, CommonStruct.CopyType, 
												  &CommonStruct.fasList,
                                      &CommonStruct.GraphInfoList,
                                      &NewGroupList)) == NULL) return RTERROR;

   // argomento opzionale: tabella/e secondaria/e
   if (arg && arg->restype == RTLB)
   {
      int              i = 0, j, sub, dummy, sec;
      DataCopyTypeEnum CopyType;
      presbuf          pItem, p, pSecDescr;
      C_SECONDARY      *pOldSec;
      TCHAR            *NewSecName;

      // per ogni sottoclasse (o solo per la classe)
      while ((pItem = gsc_nth(i++, arg)) != NULL)
      {
         // codice classe se = 0 altrimenti codice sottoclasse
         if (!(p = gsc_nth(0, pItem)) || gsc_rb2Int(p, &sub) == GS_BAD)
            { GS_ERR_COD = eGSInvalidArg; return RTERROR; }
         pItem = p->rbnext;
         j = 0;
         // per ogni secondaria
         while ((pSecDescr = gsc_nth(j++, pItem)) != NULL)
         {
            C_INFO_SEC SecInfoConn;

            // flag <sel>; se = 1 secondaria da copiare
            if (!(p = gsc_nth(0, pSecDescr)) || gsc_rb2Int(p, &dummy) == GS_BAD)
               { GS_ERR_COD = eGSInvalidArg; return RTERROR; }
            if (dummy != 1) continue; // secondaria da non copiare
            // <sec>; codice tabella secondaria da copiare
            if (!(p = gsc_nth(1, pSecDescr)) || gsc_rb2Int(p, &sec) == GS_BAD)
               { GS_ERR_COD = eGSInvalidArg; return RTERROR; }
            // <name>; nuovo nome tabella secondaria
            if (!(p = gsc_nth(2, pSecDescr)) || p->restype != RTSTR)
               { GS_ERR_COD = eGSInvalidArg; return RTERROR; }
            NewSecName = p->resval.rstring;

            // se la classe copia solo struttura lo stesso vale anche per le secondarie
            if (CommonStruct.CopyType == GSStructureOnlyCopyType) CopyType = GSStructureOnlyCopyType;
            else
               // <copytype>; tipo di copia se = GSStructureAndDataCopyType -> struttura+dati
               if (!(p = gsc_nth(4, pSecDescr)) || gsc_rb2Int(p, (int *) &CopyType) == GS_BAD)
                  { GS_ERR_COD = eGSInvalidArg; return RTERROR; }
            
            // <dblist>; lista per nuova connessione a DB
            if (!(p = gsc_nth(5, pSecDescr))) { GS_ERR_COD = eGSInvalidArg; return RTERROR; }
            if (SecInfoConn.from_rb(p) == GS_BAD) return RTERROR;
            //// UDL reference
            //if ((pVal = gsc_nth(0, p)) == NULL) return RTERROR;
            //if (pVal->restype == RTSTR) SecInfoConn.ConnStrUDLFile = pVal->resval.rstring;
            //// UDL Props
            //if ((pVal = gsc_nth(1, p)) == NULL) return RTERROR;
            //if (p->restype == RTLB) // potrebbe essere nil
            //   if (gsc_getUDLProperties(&pVal, SecInfoConn.UDLProperties) == GS_BAD) return RTERROR;
            //// Table reference
            //if ((p = gsc_nth(2, p)) == NULL) return GS_BAD;
            //// Catalogo
            //if ((pVal = gsc_nth(0, p)) == NULL) return GS_BAD;
            //Cat = (pVal->restype == RTSTR) ? pVal->resval.rstring : NULL;
            //// Schema
            //if ((pVal = gsc_nth(1, p)) == NULL) return GS_BAD;
            //Sch = (pVal->restype == RTSTR) ? pVal->resval.rstring : NULL;
            //// Tabella
            //if ((pVal = gsc_nth(2, p)) == NULL) return GS_BAD;
            //Tab = (pVal->restype == RTSTR) ? pVal->resval.rstring : NULL;
            //// Conversione path UDLProperties da assoluto in dir relativo
            //if ((pConn = SecInfoConn.getDBConnection(OLD)) == NULL) return GS_BAD;
            //if (pConn->UDLProperties_nethost2drive(SecInfoConn.UDLProperties) == GS_BAD) return GS_BAD;
            //if (SecInfoConn.OldTableRef.paste(pConn->get_FullRefTable(Cat, Sch, Tab)) == NULL)
            //   return GS_BAD;
            
            // Ricavo secondaria sorgente
            if (!(pOldSec = gsc_find_sec(prj, cls, sub, sec))) return RTERROR;
            // Copia secondaria
            acutPrintf(gsc_msg(696), pOldSec->name); // "\nCopia tabella secondaria <%s>..."
            if (pOldSec->CopyToCls(pNewCls->ptr_id()->pPrj->get_key(),
                                   pNewCls->ptr_id()->code, sub, CopyType,
                                   NewSecName, pOldSec->Descr.get_name(),
                                   SecInfoConn.OldTableRef.get_name(),
                                   SecInfoConn.ConnStrUDLFile.get_name(),
                                   SecInfoConn.UDLProperties) == NULL) return RTERROR;
         }
      }
   }

   acedRetInt(pNewCls->ptr_id()->code);

   return RTNORM;
}


///////////////////////////////////////////////////////////////////////////
/* 
Questa funzione salva in un file .sel la lista delle clasi selezionate in 
una sessione di lavoro. E' invocata dal LISP con parametri di passaggio 
<cod_prj> <nome_file> <list_nclassi>.
*/                                                    
///////////////////////////////////////////////////////////////////////////
int gs_save_class_sel(void)
{
   int     cod_prj, ris;
   TCHAR   *filename;
   presbuf arg;
   
   acedRetNil();

   // ricavo i valori impostati
   arg = acedGetArgs();

   cod_prj = arg->resval.rint;             // codice del progetto
   arg = arg->rbnext;
   filename = arg->resval.rstring;  // nome del file 
   arg = arg->rbnext;
   
   // Chiamo la funzione che salva i codici delle classi e del progetto nel file
   ris = gsc_save_class_sel(cod_prj, filename, arg);

   if (ris == GS_CAN) { acedRetNil(); return RTNORM; }
   if (ris != GS_GOOD) return RTERROR;

   acedRetT();
     
   return RTNORM;
}


/*********************************************************************/
/*.doc gsc_save_class_sel <internal> */
/*+
  Questa funzione riceve il nome di un file .sel in cui memorizzare il 
  codice del progetto e la lista dei codici delle classi selezionate per 
  poter essere ricaricate in tempi successivi.
  Parametri:
  int      cod_prj : codice progetto di appartenenza classi.
  TCHAR    *filename : nome del file in cui salvare il set di classi selezionate.
  presbuf  arg : resbuf che contiene la lista delle classi selezionate.

  La funzione restituisce GS_BAD in caso di errore altrimenti GS_GOOD.
-*/  
/*********************************************************************/
int gsc_save_class_sel(int cod_prj, TCHAR *filename, presbuf arg)
{
   FILE    *f;
   int     cont = 0;
   C_STRING buffer;
   presbuf  ris1, ris2, ris3;
   
   // apro il file in scrittura
   if ((f = gsc_fopen(filename, _T("w"))) == NULL) { GS_ERR_COD = eGSOpenFile; return GS_BAD; }

   buffer = cod_prj;
   // aggiungo il return finale 
   buffer += GS_LFSTR;
   fwrite(buffer.get_name(), sizeof(TCHAR), buffer.len(), f);

   while((ris1 = gsc_nth(cont, arg)) != NULL) 
   {
		if ((ris2= gsc_nth(0, ris1)) != NULL)
      {
         // verifico se la classe è selezionata=1 o estratta=3
         if (((ris3 = gsc_nth(6, ris1))->resval.rint == 1) ||
             ((ris3 = gsc_nth(6, ris1))->resval.rint == 3))
         {
            buffer = ris2->resval.rint;
            // aggiungo il return finale
            buffer += GS_LFSTR;
            fwrite(buffer.get_name(), sizeof(TCHAR), buffer.len(), f);
         }
      }
   	cont++;
   }
   gsc_fclose(f);

   return GS_GOOD;
}
///////////////////////////////////////////////////////////////////////////
/* 
Questa funzione carica da un file .sel i codici delle classi precedentemente 
selezionate e salvate. E' invocata dal LISP con parametri di passaggio 
<nome_file>.Ritorna una lista comprendebte il codice del progetto e la lista
delle classi selezionate.
*/                                                    
///////////////////////////////////////////////////////////////////////////
int gs_load_class_sel(void)
{
   TCHAR      *filename;
   int        flag_prj = 0, prj;
   C_INT_LIST lista_classi;
   presbuf    arg;
   C_RB_LIST  ret;
   
   acedRetNil();

   // ricavo i valori impostati
   arg = acedGetArgs();

   filename = arg->resval.rstring;               // nome del file 
   if (arg = arg->rbnext) flag_prj = arg->resval.rint;  // eventuale flag sul prj
   
   // Chiamo la funzione che legge i codici delle classi e del progetto nel file
   gsc_load_class_sel(filename, flag_prj, &prj, &lista_classi);
   if (lista_classi.get_count() == 0) acedRetNil();
   else
   {
      ret << acutBuildList(RTSHORT, prj, RTLB, 0);
      ret += lista_classi.to_rb();
      ret += acutBuildList(RTLE, 0);
      ret.LspRetList();
   }
    
   return RTNORM;
}


/*********************************************************************/
/*.doc gsc_load_class_sel <internal> */
/*+
  Questa funzione riceve il nome del file .sel su cui sono state memorizzate
  le classi di una precedente selezione e ritorna la lista dei codici delle
  stesse per utilizzi successivi.
  Parametri:
  TCHAR      *filename     nome del file in cui salvare il set di classi selezionate.
  int        flag_prj      flag che indica se considerare il progetto letto nel file 
                           come progetto corrente
  int        *prj;         codice progetto
  C_INT_LIST *lista        lista dei codici delle classi salvate.

  La funzione restituisce GS_BAD in caso di errore altrimenti GS_GOOD.
-*/  
/*********************************************************************/
int gsc_load_class_sel(TCHAR *filename, int flag_prj, int *prj, C_INT_LIST *lista)
{
   FILE  *f;
   int   cod_cls;
   C_INT *ClassToSel;
   TCHAR *riga = NULL;
   bool  Unicode;

   lista->remove_all();
   
   if (gsc_path_exist(filename) == GS_GOOD)
   {
      // apro il file in lettura
      if ((f = gsc_fopen(filename, _T("r"), MORETESTS, &Unicode)) == NULL)
         { GS_ERR_COD = eGSOpenFile; return GS_BAD; }

      // leggo il codice progetto salvato nel file
      if (gsc_readline(f, &riga, Unicode) != WEOF) swscanf(riga, _T("%d"), prj);

      // verifico che il codice del progetto corrente sia quello del set di classi salvato
      // se il flag_prj è = 0
      if (flag_prj == 0)
      {
         if (*prj != GS_CURRENT_WRK_SESSION->get_PrjId()) 
            { GS_ERR_COD = eGSInvalidPrjCode; return GS_BAD; }
      }
      // leggo i codici delle classi dal file
      while (gsc_readline(f, &riga, Unicode) != WEOF)
      {
         swscanf(riga, _T("%d"), &cod_cls);
         if ((ClassToSel = new (C_INT)) == NULL)
            { GS_ERR_COD = eGSOutOfMem; break; }
         ClassToSel->set_key(cod_cls);
         lista->add_tail(ClassToSel);
      }
      gsc_fclose(f);
   }

   return GS_GOOD;
}


/****************************************************/
/*.doc int gs_readAcpfile                           */
/*
   Funzione "C" che legge il file ACP e restituisce al
   Lisp la lista dei nomi, dei file e delle categorie delle classi da generare.
   ((<nome classe><path><categoria>) (...))
*/
/****************************************************/
int gs_readAcpfile()
{
   C_2STR_INT_LIST ItemList;
   C_2STR_INT      *pItem;
   C_STRING        filename, str, Path, Name, label;
   presbuf         arg = NULL;
   C_RB_LIST       ret;
   int             i;
   long            nTotClass;
   C_ID            ID;
   C_PROFILE_SECTION_BTREE ProfileSections, ClsProfileSections;
   C_BPROFILE_SECTION      *ProfileSection;
   C_2STR_BTREE            *pProfileEntries;
   C_B2STR                 *pProfileEntry;

   acedRetNil();
   arg = acedGetArgs();
   // Il primo e unico parametro è la path completa del file Acp
   if (arg == NULL || arg->restype != RTSTR) { GS_ERR_COD = eGSInvalidArg; return RTERROR; }
   filename = arg->resval.rstring;

   // Verifico l' esistenza del file di descrizione classi  
   if (gsc_read_profile(filename, ProfileSections) == GS_BAD) return RTERROR;

   // Lettura del numero di classi da creare dal file descrizioni nella sezione HEADER  
   if (!(pProfileEntry = (C_B2STR *) ProfileSections.get_entry(_T("HEADER"), _T("COUNT"))))
      return RTERROR;
   nTotClass = _wtoi(pProfileEntry->get_name2());
   if (nTotClass <= 0) return RTNORM;
   for (i = 1; i <= nTotClass; i++)
   {
      label = i;
      if (!(ProfileSection = (C_BPROFILE_SECTION *) ProfileSections.search(label.get_name()))) continue;
      pProfileEntries = (C_2STR_BTREE *) ProfileSection->get_ptr_EntryList();

      // Vado a leggere il nome della classe
      if (!(pProfileEntry = (C_B2STR *) pProfileEntries->search(_T("NAME")))) continue;
      Name = pProfileEntry->get_name2();
      // Poi la path completa del file Acc
      if (!(pProfileEntry = (C_B2STR *) pProfileEntries->search(_T("FILE")))) continue;
      Path = pProfileEntry->get_name2();

      // Lettura del file di descrizione delle classi
      if (gsc_read_profile(Path, ClsProfileSections) != GS_GOOD) continue;
      // Lettura C_ID per sapere che tipo di classe si dovrà creare
      if (ID.load(ClsProfileSections, _T("0")) == GS_BAD) continue;

      pItem = new C_2STR_INT(Name.get_name(), Path.get_name(), ID.category);
      ItemList.add_tail(pItem); 
   }   

   if (ItemList.get_count() > 0)
   {
      if ((ret << ItemList.to_rb()) == NULL) return RTERROR;
      ret.LspRetList();
   }

   return RTNORM;
}


/****************************************************/
/*.doc int gs_fromDclToRB                       */
/*
   Funzione "C" che serve ad interpretare la selezione
   multipla da una lista DCL legge il file ACP e restituisce al
   Lisp la lista dei nomi e dei file di specifiche 
   per la generazione delle classi.
*/
/****************************************************/
int gs_fromDclToRB()
{
   C_INT_LIST Out;
   C_INT      *pInt = NULL;
   C_STRING   ValSelected;
   TCHAR      *punt;
   presbuf    arg = NULL;
   long       ii = 0, kk = 0, cont = 0, Num;

   acedRetNil();
   arg = acedGetArgs();
   // Il primo e unico parametro è la path completa del file Acp
   if (arg == NULL || arg->restype != RTSTR) 
      { GS_ERR_COD = eGSInvalidArg; return RTERROR; }
   ValSelected = arg->resval.rstring;

   // Se non è selezionato alcun valore ritorno nil
   if (ValSelected.len() == 0) { acedRetNil(); return RTNORM; }

   // Devo stare attento perchè in val ci possono essere più valori,
   // perchè la selezione è multipla il formato di restituzione è "2 3 7 9 11"
   // Sostituisco gli spazi con \0 così ricavo il numero di elementi selezionati
   cont = gsc_strsep(ValSelected.get_name(), _T('\0'), _T(' '));
   // Incremento di uno perchè se gli spazi sono due i valori sono tre
   cont++; 
   if (cont == 1)
   {
      Num = _wtoi(ValSelected.get_name()); //  + 1;
      if ((pInt = new (C_INT)) == NULL) return RTERROR;
      pInt->set_key(Num);
      Out.add_tail(pInt);
   }
   else
   {
      // Attenzione anche alla restituzione di acad, il valore 2 corrisponde
      // al terzo elemento nella lista
      punt = ValSelected.get_name();
      for (ii = 1; ii <= cont; ii++)
      {
         if (ii != 1)
         {
            for (kk = 1; kk < ii; kk++)
               while (*punt != _T('\0')) punt++; punt++; 
         }
         Num = _wtoi(punt); //  + 1;
         if ((pInt = new (C_INT)) == NULL) return RTERROR;
         pInt->set_key(Num);
         Out.add_tail(pInt);
      }
   }

   if (Out.get_count() > 0)
   {
      C_RB_LIST  ret;
      if ((ret << Out.to_rb()) == NULL) return RTERROR;
      ret.LspRetList();
   }
   else
      acedRetNil();

   return RTNORM;
}


/*********************************************************/
/*.doc gsc_AutomaticCreationClass <external> */
/*+
  Questa funzione crea una classe di entità di GEOsim leggendo le sue 
  caratteristiche da file.
  Parametri:
  int        Prj;           Codice progetto
  C_STRING   &ClsPathFile;  Path del file contenente la struttura della classe
  C_GPH_INFO *pGphInfo;     Definizione del collegamento ai dati geometrici
  C_INFO     &AlphaNumInfo; Definizione del collegamento ai dati alfanumerici

  Restituisce codice classe in caso di successo altrimenti restituisce 0.
-*/  
/*********************************************************/
int gsc_AutomaticCreationClass(int Prj, C_STRING &ClsPathFile, 
                               C_GPH_INFO *pGphInfo, C_INFO &AlphaNumInfo)
{
   C_ID      ID;
   C_CLASS   *pCls = NULL;
   int       result = GS_BAD, new_code = 0;
   C_RB_LIST Descr;
   presbuf   p, pGphInfoRbList;
   C_PROFILE_SECTION_BTREE ProfileSections;

   // Verifica dei parametri di input
   if (Prj <= 0) { GS_ERR_COD = eGSInvalidPrjCode; return 0; }
   // Lettura del file di descrizione delle classi
   if (gsc_read_profile(ClsPathFile, ProfileSections) == GS_BAD)
      return 0;
   
   result = GS_BAD;

   do
   {
      // Lettura C_ID per sapere che tipo di classe si dovrà creare
      if (ID.load(ProfileSections, _T("0")) == GS_BAD) break;

      // Alloca una classe della categoria indicata
      if ((pCls = gsc_alloc_new_class(ID.category)) == NULL) break;

      if ((p = pCls->read_stru(ProfileSections)) == NULL) break;      
      Descr << p;

      if (ID.category == CAT_EXTERN)
      {
         presbuf lista_sub = Descr.nth(2);
         int len = gsc_length(lista_sub);

         // Aggiungo alla lista delle sub la struttura pGphInfo (C_GPH_INFO)
         for (int i = 0; i < len; i++)
         {
            if ((p = gsc_nth(i, lista_sub)) == NULL)
               { delete pCls; return RTERROR; }
            p = gsc_scorri(gsc_nth(2, p)); // ultimo elemento della terza lista
            Descr.set_cursor(p);

            p = pGphInfoRbList = acutBuildList(RTLB, 0);
            while (p->rbnext) p = p->rbnext;
            p->rbnext = pGphInfo->to_rb();
            while (p->rbnext) p = p->rbnext;
            p->rbnext = acutBuildList(RTLE, 0);

            Descr.link_atCursor(pGphInfoRbList);
         }
      }
      else
      if (pCls->ptr_fas())
      {
         if (pCls->ptr_info())
            p = gsc_scorri(gsc_nth(2, p)); // ultimo elemento della terza lista (id, db_info, fas, ...)
         else
            p = gsc_scorri(gsc_nth(1, p)); // ultimo elemento della seconda lista (id, fas, ...)
         Descr.set_cursor(p);

         // Aggiungo la struttura pGphInfo (C_GPH_INFO)
         p = pGphInfoRbList = acutBuildList(RTLB, 0);
         while (p->rbnext) p = p->rbnext;

         if (pGphInfo->getDataSourceType() == GSDBGphDataSource)
         {
            C_DBGPH_INFO dummy;
            C_STRING     Catalog, Schema, Table;

            pGphInfo->copy(&dummy);

            if (dummy.getDBConnection()->split_FullRefTable(dummy.TableRef, Catalog,
                                                            Schema, Table) != GS_GOOD)
               break;
            Table = ID.name;
            if (dummy.getDBConnection()->IsValidFieldName(Table) == GS_BAD) break;
            dummy.TableRef.paste(dummy.getDBConnection()->get_FullRefTable(Catalog, Schema, Table));

            p->rbnext = dummy.to_rb();
         }
         else            
            p->rbnext = pGphInfo->to_rb();

         while (p->rbnext) p = p->rbnext;
         p->rbnext = acutBuildList(RTLE, 0);

         Descr.link_atCursor(pGphInfoRbList);
      }

      if (pCls->from_rb(Descr.get_head()) == GS_BAD) break;

      if (pCls->ptr_info())
      {
         // inizializzo il collegamento ai dati alfanumerici
         AlphaNumInfo.copy(pCls->ptr_info());
         // Ottengo la connessione OLE-DB di default
         // Conversione struttura tabella
         if (pCls->ptr_attrib_list()->Convert2ProviderType(GEOsimAppl::DBCONNECTION_LIST.get_Connection(), 
                                                           pCls->ptr_info()->getDBConnection(OLD)) == GS_BAD)
            break;
      }

      // Creo la nuova classe
      if ((new_code = gsc_createclass(Prj, pCls)) == GS_BAD) break;

      result = GS_GOOD;      
   }
   while (0);

   if (result == GS_BAD)
   {
      TCHAR Msg[MAX_LEN_MSG];

      // "Classe <%s> non creata."
      swprintf(Msg, MAX_LEN_MSG, gsc_msg(687), (pCls) ? pCls->ptr_id()->name : GS_EMPTYSTR);

      // Scrivo sul video che la classe non è stata creata
      acutPrintf(Msg);
      acutPrintf(GS_LFSTR);
      acutPrintf(gsc_err(GS_ERR_COD));
      // Scrivo sul file LOG che la classe non è stata creata 
      gsc_write_log(Msg);
      gsc_write_log(gsc_err(GS_ERR_COD));

      if (pCls) delete pCls;
   }

   return new_code;
}


/****************************************************/
/*.doc int gs_AutomaticCreationClass                */
/*
   Funzione lisp per la generazione automatica delle 
   classi, il primo parametro è il codice progetto,
   il secondo è il nome+path del file Acp, il terzo è 
   la lista di descrizione di ogni singola classe.
   <prj><Path>(<Nome classe><Path><category><GphDB><AlphaNumDB>)...)
*/
/****************************************************/
int gs_AutomaticCreationClass()
{
   presbuf    arg, pDescr = NULL, ptmp = NULL;
   int        prj = 0, index = 0, category;
   C_STRING   filesdescription, nomeCls, fileCls, dirdwgCls;
   C_INFO     AlphaNumInfo;
   C_GPH_INFO *pGphInfo = NULL;

   acedRetNil();
   arg = acedGetArgs();

   // Leggo i parametri di input, il primo è il codice del progetto
   if (arg == NULL || arg->restype != RTSHORT) { GS_ERR_COD = eGSInvalidArg; return RTERROR; }
   prj = arg->resval.rint;

   // Il secondo parametro è il nome+path del file delle descrizioni
   if ((arg = arg->rbnext) == NULL || arg->restype != RTSTR) { GS_ERR_COD = eGSInvalidArg; return RTERROR; }
   filesdescription = arg->resval.rstring;
   if ((arg = arg->rbnext) == NULL) { GS_ERR_COD = eGSInvalidArg; return RTERROR; }
   while ((pDescr = gsc_nth(index++, arg)) != NULL)
   {
      // Nome classe da generare
      if ((ptmp = gsc_nth(0, pDescr)) != NULL && ptmp->restype == RTSTR)
         nomeCls.set_name(ptmp->resval.rstring);
      else { GS_ERR_COD = eGSInvalidArg; return RTERROR; }

      // Path file descrizione
      if ((ptmp = gsc_nth(1, pDescr)) != NULL && ptmp->restype == RTSTR)
         fileCls.set_name(ptmp->resval.rstring);
      else
         { GS_ERR_COD = eGSInvalidArg; return RTERROR; }

      // categoria della classe
      if ((ptmp = gsc_nth(2, pDescr)) == NULL || gsc_rb2Int(ptmp, &category) == GS_BAD)
         { GS_ERR_COD = eGSInvalidArg; return RTERROR; }

      if (category != CAT_GROUP) // leggo il db grafico
      {
         GraphDataSourceEnum SrcType;

         // Se il quarto argomento è NULL la classe non è definita, e quindi non va generata.
         if ((ptmp = gsc_nth(3, pDescr)) == NULL) continue;
         if ((SrcType = gsc_getGraphDataSourceType(ptmp)) == GSNoneGphDataSource) return RTERROR;
         if ((pGphInfo = gsc_alloc_GraphInfo(SrcType)) == NULL) return RTERROR;
         if (pGphInfo->from_rb(ptmp) == GS_BAD) return RTERROR;
      }

      if (category != CAT_SPAGHETTI) // leggo il db alfanumerico
      {
         // Se il quinto argomento è NULL la classe non è definita, e quindi non va generata.
         if ((ptmp = gsc_nth(4, pDescr)) == NULL) continue;
         // Caricamento della info della classe da generare      
         if (AlphaNumInfo.from_rb(ptmp) == GS_BAD) return RTERROR;
      }

      // Richiamo la funzione di creazione della classe
      if (gsc_AutomaticCreationClass(prj, fileCls, pGphInfo, AlphaNumInfo) == 0)
         return RTERROR; 

      if (pGphInfo)
      {
         delete pGphInfo;
         pGphInfo = NULL;
      }
   }

   acedRetT();

   return RTNORM;
}


/*********************************************************/
/*.doc gs_class_write_stru                    <internal> */
/*+
  Questa funzione scrive la struttura della classe in un file
  per generare file per la creazione automatica di classi.
  Parametri:
  (<prj><cls><Path>(("UDL_FILE" <file UDL> | <stringa di connessione>) ("UDL_PROP" <value>))

  Restituisce RTNORM in caso di successo altrimenti restituisce RTERROR.
-*/  
/*********************************************************/
int gs_class_write_stru()
{
   C_DBCONNECTION *pConn = NULL;
   presbuf        arg = acedGetArgs();
   C_STRING       Path;
   int            prj, cls;
   C_CLASS        *pCls;

   acedRetNil();

   // Legge nella lista dei parametri: progetto e classe
   if (arg_to_prj_cls_sub(&arg, &prj, &cls) == GS_BAD) return RTERROR;

   // Ritorna il puntatore alla classe cercata
   if ((pCls = gsc_find_class(prj, cls)) == NULL) return RTERROR;

   // Path del file
   if (!arg || arg->restype != RTSTR)
      { GS_ERR_COD = eGSInvalidArg; return RTERROR; }
   Path = arg->resval.rstring;  // descrizione tipo

   if ((arg = arg->rbnext))
      // Legge nella lista dei parametri i riferimenti al DB
      if ((pConn = gsc_getConnectionFromLisp(arg)) == NULL) return RTERROR;

   if (pCls->get_category() == CAT_EXTERN)
   {
      if (((C_EXTERN *) pCls)->write_stru(Path, pConn) == GS_BAD) return RTERROR;
   }
   else
      if (pCls->write_stru(Path, pConn) == GS_BAD) return RTERROR;
   acedRetT();

   return RTNORM;
}


//-----------------------------------------------------------------------//
///////////////////   C_CLASS_SET_LIST  INIZIO   //////////////////////////
//-----------------------------------------------------------------------//


// costruttore
C_CLASS_SET_LIST::C_CLASS_SET_LIST():C_LIST() {}

// distruttore
C_CLASS_SET_LIST::~C_CLASS_SET_LIST() {}

int C_CLASS_SET_LIST::copy(C_CLASS_SET_LIST &out)
{
	C_CLASS_SET *newClsSet, *punt;

	out.remove_all();
	punt = (C_CLASS_SET *) get_head();  
	while (punt)
	{
		if ((newClsSet = new C_CLASS_SET) == NULL) { GS_ERR_COD = eGSOutOfMem; return GS_BAD; }
		out.add_tail(newClsSet);
      punt->copy(*newClsSet);
	  
		punt = (C_CLASS_SET *) get_next();
	}

	return GS_GOOD;
}


/*********************************************************/
/*.doc C_CLASS_SET_LIST::Insert               <external> */
/*+
  Questa funzione inserisce un set di classi nella lista.
  Parametri:
  C_CLASS_SET *pClsSet;    Set di classi da inserire
  int SetIdParent;         Opzionale; Id del set padre se = 0 significa figlio della root
                           (default = 0)
  int Pos;                 Opzionale; Posizione (1-index) in cui inserire il set
                           (default = 1, prima posizione)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_CLASS_SET_LIST::Insert(C_CLASS_SET *pClsSet, int SetIdParent, int Pos)
{
   if (SetIdParent > 0)
   {
      C_CLASS_SET *pClsSetParent;

      if ((pClsSetParent = Search(SetIdParent)) == NULL)
         {  GS_ERR_COD = eGSInvClsSetId; return GS_BAD; }

      C_INT_INT *p;
   
      if ((p = new C_INT_INT(pClsSet->get_key(), GSClassSet)) == NULL)
         { GS_ERR_COD = eGSOutOfMem; return GS_BAD; }

      if (Pos <= 1) pClsSetParent->ClsCodeList.add_head(p);
      else if (Pos > pClsSetParent->ClsCodeList.get_count() + 1) pClsSetParent->ClsCodeList.add_tail(p);
      else pClsSetParent->ClsCodeList.insert_before(Pos, p);

      pClsSetParent->ClassSetList.add_tail(pClsSet);
   }
   else
   {
      if (Pos <= 1) add_head(pClsSet);
      else if (Pos > get_count() + 1) add_tail(pClsSet);
      else insert_before(Pos, pClsSet);
   }

   return GS_GOOD;
}


/*********************************************************/
/*.doc C_CLASS_SET_LIST::InsertCls            <external> */
/*+
  Questa funzione inserisce un classe in un set di classi della lista.
  Parametri:
  int SetId;   Id del set
  int Cls;     Codice classe da aggiungere al set di classi
  int Pos;     Opzionale; Posizione (1-index) in cui inserire la classe
               (default = 1, prima posizione)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/
/*********************************************************/
int C_CLASS_SET_LIST::InsertCls(int SetId, int Cls, int Pos)
{
   C_CLASS_SET *pClsSet;

   if ((pClsSet = Search(SetId)) == NULL)
      {  GS_ERR_COD = eGSInvClsSetId; return GS_BAD; }

   return pClsSet->InsertCls(Cls, Pos);
}


C_CLASS_SET *C_CLASS_SET_LIST::get_next_on_tree(void)
{
   C_CLASS_SET *pClsSet = (C_CLASS_SET *) get_cursor();

   if (!pClsSet) return NULL;

   if (pClsSet->ClassSetList.get_count() > 0) // Se ha figli
   {
      if ((pClsSet = pClsSet->ClassSetList.get_next_on_tree()) == NULL)
         if ((pClsSet = (C_CLASS_SET *) get_next())) // fratello successivo
            pClsSet->ClassSetList.get_head(); // mi posiziono sul primo figlio
   }
   else
      if ((pClsSet = (C_CLASS_SET *) get_next())) // fratello successivo
         pClsSet->ClassSetList.get_head(); // mi posiziono sul primo figlio

   return pClsSet;
}


/*********************************************************/
/*.doc C_CLASS_SET_LIST::Search               <external> */
/*+
  Questa funzione cerca un set di classi nella lista cercando anche nei set figli.
  Parametri:
  int SetId;         Id del set da cercare
  oppure
  const TCHAR *Mask; Stringa di maschera del nome del set
  bool FromStart;    Opzionale; flag di ricerca, se = true parte dall'inizio
                     se = false parte dalla posizione successiva a quella del cursore 
                     (default = true)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
C_CLASS_SET *C_CLASS_SET_LIST::Search(int SetId)
{
   C_CLASS_SET *p;

   if ((p = (C_CLASS_SET *) search_key(SetId))) return p;

   C_CLASS_SET *pParent = (C_CLASS_SET *) get_head();
   while (pParent)
   {
      if ((p = pParent->ClassSetList.Search(SetId))) return p;
      pParent = (C_CLASS_SET *) get_next();
   }

   GS_ERR_COD = eGSInvClsSetId;

   return NULL;
}
C_CLASS_SET *C_CLASS_SET_LIST::Search(C_STRING &Mask, bool FromStart)
{
   C_CLASS_SET *p;

   if (FromStart) p = (C_CLASS_SET *) get_head();
   else p = (C_CLASS_SET *) get_next_on_tree();

   while (p)
   {
      if (Mask.wildcomp(p->get_name())) return p;
      p = (C_CLASS_SET *) get_next_on_tree();
   }

   GS_ERR_COD = eGSInvClsSetId;

   return NULL;
}


/*********************************************************/
/*.doc C_CLASS_SET_LIST::Search               <external> */
/*+
  Questa funzione cerca una classe nella lista cercando anche nei set figli.
  Parametri:
  int Cls;           Codice della classe di entità

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
C_CLASS_SET *C_CLASS_SET_LIST::SearchCls(int Cls)
{
   C_CLASS_SET *p = (C_CLASS_SET *) get_head();

   while (p)
   {
      if (p->ClsCodeList.search_key(Cls)) return p;
      p = (C_CLASS_SET *) get_next();
   }

   GS_ERR_COD = eGSInvClassCode;

   return NULL;
}


/*********************************************************/
/*.doc C_CLASS_SET_LIST::Search               <external> */
/*+
  Questa funzione cerca classi e set di classi che siano in una lista
  data come parametro. La ricerca avverrà nella lista dei set 
  cercando anche nei set figli.
  Parametri:
  C_INT_INT_LIST &Cls_ClsSet_CodeList; Lista di classi e di set di classi da cercare
  bool FromStart;                      Opzionale; flag di ricerca, se = true parte dall'inizio
                                       se = false parte dalla posizione successiva a quella del cursore 
                                       (default = true)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
C_CLASS_SET *C_CLASS_SET_LIST::Search(C_INT_INT_LIST &Cls_ClsSet_CodeList, bool FromStart)
{
   C_CLASS_SET *pClsSet;
   C_INT_INT   *p;

   if (FromStart) pClsSet = (C_CLASS_SET *) get_head();
   else pClsSet = (C_CLASS_SET *) get_next_on_tree();

   while (pClsSet)
   {
      p = (C_INT_INT *) Cls_ClsSet_CodeList.get_head();
      while (p)
      {
         if (pClsSet->ClsCodeList.search(p->get_key(), p->get_type())) return pClsSet;
         p = (C_INT_INT *) Cls_ClsSet_CodeList.get_next();
      }
      pClsSet = (C_CLASS_SET *) get_next_on_tree();
   }

   return NULL;
}


/*********************************************************/
/*.doc C_CLASS_SET_LIST::Remove               <external> */
/*+
  Questa funzione cancella un set di classi. 
  La ricerca avverrà nella lista dei set cercando anche nei set figli.
  Parametri:
  int SetId;         Id del set da cancellare

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_CLASS_SET_LIST::Remove(int SetId)
{
   if (remove_key(SetId) == GS_GOOD) return GS_GOOD;

   C_CLASS_SET *p = (C_CLASS_SET *) get_head();
   while (p)
   {
      if (p->ClassSetList.Remove(SetId) == GS_GOOD)
         return p->ClsCodeList.remove(SetId, GSClassSet);

      p = (C_CLASS_SET *) get_next();
   }

   return GS_BAD;
}


/*********************************************************/
/*.doc C_CLASS_SET_LIST::Move                 <external> */
/*+
  Questa funzione sposta un set di classi facendolo diventare figlio 
  di un'altro set di classi. 
  Parametri:
  int SetId;         Id del set da spostare
  int IdParent;      Opzionale; Id del set di classi che diventerà nuovo padre.
                     Se = 0 significa root (default = 0)
  int Pos;           Opzionale; Posizione (1-index) in cui inserire il set
                     (default = 1, prima posizione)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_CLASS_SET_LIST::Move(int SetId, int IdParent, int Pos)
{
   C_CLASS_SET *pOld, *pNew;

   if ((pOld = Search(SetId)) == NULL) return GS_BAD;

   if ((pNew = new C_CLASS_SET()) == NULL)
      { GS_ERR_COD = eGSOutOfMem; return GS_BAD; }

   pOld->copy(*pNew);

   if (Insert(pNew, IdParent, Pos) == GS_BAD)
      { delete pNew; return GS_BAD; }

   return Remove(SetId);
}


/*********************************************************/
/*.doc C_CLASS_SET_LIST::get_ClsCodeList      <external> */
/*+
  Questa funzione ricava la lista delle classi di una lista di set di classi.
  Parametri:
  C_INT_LIST &out;  Lista dei codici di classi nell'ordine in cui 
                    sono stati inseriti nei set di classi

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
void C_CLASS_SET_LIST::get_ClsCodeList(C_INT_LIST &out)
{
   C_CLASS_SET    *p = (C_CLASS_SET *) get_head();
   C_INT_LIST _out;

   out.remove_all();
   while (p)
   {
      p->get_ClsCodeList(_out);
      out.paste_tail(_out);

      p = (C_CLASS_SET *) get_next();
   }
}


/*********************************************************/
/*.doc C_CLASS_SET_LIST::MoveCls              <external> */
/*+
  Questa funzione sposta una classe da un set di classi all'altro. 
  Parametri:
  int Cls;           Codice della classe di entità
  int SetId;         Id del set in cui spostare la classe
  int Pos;           Opzionale; Posizione (1-index) in cui inserire la classe
                     (default = 1, prima posizione)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_CLASS_SET_LIST::MoveCls(int Cls, int SetId, int Pos)
{
   C_CLASS_SET *pOld;

   if ((pOld = SearchCls(Cls)) == NULL) return GS_BAD;
   if (InsertCls(SetId, Cls, Pos) == GS_BAD) return GS_BAD;

   return pOld->RemoveCls(Cls);
}


/*********************************************************/
/*.doc C_CLASS_SET_LIST::from_db              <external> */
/*+
  Questa funzione carica la lista dei set di classi di un progetto.
  Parametri:
  int prj;           Codice progetto

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_CLASS_SET_LIST::from_db(int prj)
{
   C_CLASS_SET dummy;
   C_PROJECT   *pPrj;

   // Cerca progetto nella lista GEOsimAppl::PROJECTS
   if ((pPrj = (C_PROJECT *) GEOsimAppl::PROJECTS.search_key(prj)) == NULL)
      return GS_BAD;

   // Carico il nodo root (= 0)
   if (dummy.from_db(pPrj, 0) == GS_BAD) return GS_BAD;
   return dummy.ClassSetList.copy(*this);
}


/*********************************************************/
/*.doc C_CLASS_SET_LIST::to_db              <external> */
/*+
  Questa funzione scrive la lista dei set di classi di un progetto.
  Parametri:
  int prj;           Codice progetto

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_CLASS_SET_LIST::to_db(int prj)
{
   C_PROJECT *pPrj;

   // Cerca progetto nella lista GEOsimAppl::PROJECTS
   if ((pPrj = (C_PROJECT *) GEOsimAppl::PROJECTS.search_key(prj)) == NULL)
      return GS_BAD;

   // il nodo root (= 0)
   if (get_head())
      return ((C_CLASS_SET *) get_head())->to_db(pPrj);
   else
   {
      C_CLASS_SET dummy;
      dummy.Id = 0; // il set di classi root ha codice 0
      return dummy.to_db(pPrj);
   }
}


//-----------------------------------------------------------------------//
///////////////////   C_CLASS_SET_LIST  FINE     //////////////////////////
///////////////////   C_CLASS_SET  INIZIO  ////////////////////////////////
//-----------------------------------------------------------------------//


C_CLASS_SET::C_CLASS_SET():C_NODE()
{
   Id = 0;
}
C_CLASS_SET::~C_CLASS_SET() {}

int C_CLASS_SET::get_key(void)  { return Id; }
TCHAR* C_CLASS_SET::get_name(void) { return Name.get_name(); }
TCHAR* C_CLASS_SET::get_Descr(void) { return Descr.get_name(); }

int C_CLASS_SET::copy(C_CLASS_SET &out)
{
   out.Id = Id;
   out.Name = Name;
   out.Descr = Descr;
   out.ImagePath = ImagePath;
   ClassSetList.copy(out.ClassSetList);
   ClsCodeList.copy(&out.ClsCodeList);

   return GS_GOOD; 
}


/*********************************************************/
/*.doc C_CLASS_SET::Insert                    <external> */
/*+
  Questa funzione inserisce un set di classi come figlio del set 
  (che in effetti ha come figli dei codici di classe e dei set di classi).
  Parametri:
  C_CLASS_SET *pClsSet;    Set di classi da inserire
  int Pos;                 Opzionale; Posizione (1-index) in cui inserire il set
                           (default = 1, prima posizione)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_CLASS_SET::Insert(C_CLASS_SET *pClsSet, int Pos)
{
   C_STRING  Mask(pClsSet->get_name());
   C_INT_INT *p;
   
   if ((p = new C_INT_INT(pClsSet->get_key(), GSClassSet)) == NULL)
      { GS_ERR_COD = eGSOutOfMem; return GS_BAD; }

   if (Pos <= 1) ClsCodeList.add_head(p);
   else if (Pos > ClsCodeList.get_count() + 1) ClsCodeList.add_tail(p);
   else ClsCodeList.insert_before(Pos, p);

   ClassSetList.add_tail(pClsSet);

   return GS_GOOD;
}


/*********************************************************/
/*.doc C_CLASS_SET::InsertCls                 <external> */
/*+
  Questa funzione inserisce una classe nel set di classi.
  Parametri:
  int Cls;     Codice classe da inserire
  int Pos;     Opzionale; Posizione (1-index) in cui inserire la classe
               (default = 1, prima posizione)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_CLASS_SET::InsertCls(int Cls, int Pos)
{
   if (SearchCls(Cls)) // la classe deve essere univoca nel set
      {  GS_ERR_COD = eGSInvClsSetName; return GS_BAD; }

   C_INT_INT *p;
   
   if ((p = new C_INT_INT(Cls, GSClass)) == NULL)
      { GS_ERR_COD = eGSOutOfMem; return GS_BAD; }

   if (Pos <= 1) ClsCodeList.add_head(p);
   else if (Pos > ClsCodeList.get_count() + 1) ClsCodeList.add_tail(p);
   else ClsCodeList.insert_before(Pos, p);

   return GS_GOOD;
}


/*********************************************************/
/*.doc C_CLASS_SET::SearchCls                 <external> */
/*+
  Questa funzione cerca una classe nel set di classi e nei set figli.
  Parametri:
  int Cls;           Codice della classe

  Restituisce il puntatore al set di classi in caso di successo altrimenti restituisce NULL.
-*/  
/*********************************************************/
C_CLASS_SET *C_CLASS_SET::SearchCls(int Cls)
{
   if (ClsCodeList.search(Cls, GSClass)) return this;
   return ClassSetList.SearchCls(Cls);
}


/*********************************************************/
/*.doc C_CLASS_SET::Search                    <external> */
/*+
  Questa funzione cerca una classe o un set di classi nel set di classi e nei set figli.
  Parametri:
  C_INT_INT_LIST &Cls_ClsSet_CodeList; Lista di codici di classi o set di classi

  Restituisce il puntatore al set di classi in caso di successo altrimenti restituisce NULL.
-*/  
/*********************************************************/
C_CLASS_SET *C_CLASS_SET::Search(C_INT_INT_LIST &Cls_ClsSet_CodeList)
{
   C_INT_INT *p = (C_INT_INT *) Cls_ClsSet_CodeList.get_head();
   while (p)
   {
      if (ClsCodeList.search(p->get_key(), p->get_type())) return this;
      p = (C_INT_INT *) Cls_ClsSet_CodeList.get_next();
   }

   return ClassSetList.Search(Cls_ClsSet_CodeList);
}


/*********************************************************/
/*.doc C_CLASS_SET::RemoveCls                 <external> */
/*+
  Questa funzione cancella una classe dal set di classi.
  Parametri:
  int Cls;     Codice della classe da cancellare

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_CLASS_SET::RemoveCls(int Cls)
{
   return ClsCodeList.remove(Cls, GSClass);
}


/*********************************************************/
/*.doc C_CLASS_SET::get_ClsCodeList           <external> */
/*+
  Questa funzione ricava la lista delle classi di una set di classi 
  e i suoi figli.
  Parametri:
  C_INT_LIST &out;  Lista dei codici di classi nell'ordine in cui 
                    sono stati inseriti nei set di classi
  bool Append;      Flag di inserimento; se true la lista non viene
                    svuotata prima di aggiungere nuovi elementi (default = false)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
void C_CLASS_SET::get_ClsCodeList(C_INT_LIST &out, bool Append)
{
   C_INT_INT   *p = (C_INT_INT *) ClsCodeList.get_head();
   C_CLASS_SET *pClassSet = (C_CLASS_SET *) ClassSetList.get_head();

   if (!Append) out.remove_all();

   while (p)
   {
      if (p->get_type() == GSClass)
         out.add_tail_int(p->get_key());
      else // set di classe
      {
         pClassSet->get_ClsCodeList(out, true);
         pClassSet = (C_CLASS_SET *) ClassSetList.get_next();
      }

      p = (C_INT_INT *) ClsCodeList.get_next();
   }
}


/*********************************************************/
/*.doc C_CLASS_SET::clear                     <external> */
/*+
  Questa funzione svuota e lisce un set di classi la lista delle classi di una set di classi 
  e i suoi figli.
  Parametri:
  C_INT_LIST &out;  Lista dei codici di classi nell'ordine in cui 
                    sono stati inseriti nei set di classi

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
void C_CLASS_SET::clear(void)
{
   Id = 0;
   Name.clear();
   Descr.clear();
   ClassSetList.remove_all();
   ClsCodeList.remove_all();
}


/*********************************************************/
/*.doc C_CLASS_SET::from_db                   <internal> */
/*+
  Questa funzione carica i dati di un C_CLASS_SET da DB.
  Parametri:
  C_NODE *pPrj;   Puntatore a progetto
  int SetId;      Opzionale, Codice de set da caricare,
                  il set di classi root ha codice 0 (default = 0)
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int C_CLASS_SET::from_db(C_NODE *pPrj, int SetId)
{
   C_DBCONNECTION *pConn;
   C_STRING       TableRef, statement;
   _RecordsetPtr  pRs;
   presbuf        pRb, p;
   C_RB_LIST      ColValues;
   int            Code, Type;
   C_CLASS_SET    *pClsSet;

   clear();

   // setto il riferimento di SET_CLASS_TABLE_NAME (<catalogo>.<schema>.<tabella>)
   if (((C_PROJECT *) pPrj)->getClassSetTabInfo(&pConn, &TableRef) == GS_BAD)
      return GS_BAD;
   statement = _T("SELECT * FROM ");
   statement += TableRef;
   statement += _T(" WHERE GS_ID=");
   statement += SetId;

   // leggo la riga della tabella
   if (pConn->ExeCmd(statement, pRs) == GS_BAD) return GS_BAD;
   if (gsc_isEOF(pRs) == GS_GOOD) { gsc_DBCloseRs(pRs); return GS_GOOD; }
   if (gsc_DBReadRow(pRs, ColValues) == GS_BAD) { gsc_DBCloseRs(pRs); return GS_BAD; }
   gsc_DBCloseRs(pRs);
   
   Id = SetId;
   if ((p = ColValues.CdrAssoc(_T("NAME"))) == NULL || p->restype != RTSTR) Name.clear();
   else Name = p->resval.rstring;
   if ((p = ColValues.CdrAssoc(_T("DESCRIPTION"))) == NULL || p->restype != RTSTR) Descr.clear();
   else Descr = p->resval.rstring;
   if ((p = ColValues.CdrAssoc(_T("IMAGE_PATH"))) == NULL || p->restype != RTSTR) ImagePath.clear();
   else
   {
      ImagePath = p->resval.rstring;
      gsc_nethost2drive(ImagePath); // lo converto alias host in path
   }

   // setto il riferimento di SET_CLASS_TREE_TABLE_NAME (<catalogo>.<schema>.<tabella>)
   if (((C_PROJECT *) pPrj)->getClassSetTreeTabInfo(&pConn, &TableRef) == GS_BAD)
      return GS_BAD;
   statement = _T("SELECT * FROM ");
   statement += TableRef;
   statement += _T(" WHERE GS_ID_PARENT=");
   statement += SetId;
   statement += _T(" ORDER BY POS");

   // leggo le righe della tabella
   if (pConn->ReadRows(statement, ColValues) == GS_BAD) return GS_BAD;

   ColValues.remove_head(); // cancello la prima tonda
   ColValues.remove_tail(); // cancello l'ultima tonda
   
   pRb = ColValues.get_head();
   while (pRb)
   {
      if ((p = gsc_CdrAssoc(_T("ITEM_ID"), pRb, FALSE)) == NULL) return GS_BAD;
      if (gsc_rb2Int(p, &Code) == GS_BAD) return GS_BAD;

      if ((p = gsc_CdrAssoc(_T("ITEM_TYPE"), pRb, FALSE)) == NULL) return GS_BAD;
      if (gsc_rb2Int(p, &Type) == GS_BAD) return GS_BAD;

      ClsCodeList.values_add_tail(Code, Type);

      if (Type == GSClassSet)
      {
         if ((pClsSet = new C_CLASS_SET) == NULL)
            { GS_ERR_COD = eGSOutOfMem; return GS_BAD; }
         if (pClsSet->from_db(pPrj, Code) == GS_BAD) return GS_BAD;
         
         ClassSetList.add_tail(pClsSet);
      }

      if ((pRb = gsc_scorri(pRb))) // vado alla chiusa tonda successiva
         pRb = pRb->rbnext;
   }

   return GS_GOOD;
}


/*********************************************************/
/*.doc C_CLASS_SET::to_db                     <internal> */
/*+
  Questa funzione scrive i dati di un C_CLASS_SET in DB.
  Parametri:
  C_NODE *pPrj;      Puntatore a progetto
  int SetIdParent;   Opzionale, Codice del set padre.
                     il set di classi root ha codice 0 (default = 0)
  int *pNextSetClassId; Codice da usare per il successivo Set da creare come nuovo
                        (default = NULL)
    
  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/
/*********************************************************/
int C_CLASS_SET::to_db(C_NODE *pPrj, int SetIdParent, int *pNextSetClassId)
{
   C_DBCONNECTION *pConn;
   C_STRING       TableRef, statement;
   _RecordsetPtr  pRs;
   C_RB_LIST      ColValues;
   int            IsTransactionSupported = GS_BAD;

   if (Id == 0) // Se si tratta della root
   {
      if ((pNextSetClassId = (int* ) malloc(sizeof(int))) == NULL)
         { GS_ERR_COD = eGSOutOfMem; return GS_BAD; }
      if ((*pNextSetClassId = ((C_PROJECT *) pPrj)->getNextClassSetId()) == 0)
         { free(pNextSetClassId); return GS_BAD; }

      // setto il riferimento di SET_CLASS_TREE_TABLE_NAME (<catalogo>.<schema>.<tabella>)
      if (((C_PROJECT *) pPrj)->getClassSetTreeTabInfo(&pConn, &TableRef) == GS_BAD)
         return GS_BAD;

      IsTransactionSupported = pConn->BeginTrans();

      // Svuoto la tabella
      if (pConn->DelRows(TableRef.get_name()) == GS_BAD)
         { if (IsTransactionSupported == GS_GOOD) pConn->RollbackTrans(); return GS_BAD; }
      // setto il riferimento di SET_CLASS_TABLE_NAME (<catalogo>.<schema>.<tabella>)
      if (((C_PROJECT *) pPrj)->getClassSetTabInfo(&pConn, &TableRef) == GS_BAD)
         { if (IsTransactionSupported == GS_GOOD) pConn->RollbackTrans(); return GS_BAD; }
      // Svuoto la tabella
      if (pConn->DelRows(TableRef.get_name()) == GS_BAD)
         { if (IsTransactionSupported == GS_GOOD) pConn->RollbackTrans(); return GS_BAD; }
   }
   else
   {
      // setto il riferimento di SET_CLASS_TABLE_NAME (<catalogo>.<schema>.<tabella>)
      if (((C_PROJECT *) pPrj)->getClassSetTabInfo(&pConn, &TableRef) == GS_BAD)
         return GS_BAD;
      if (Id < 0) // Se si tratta di un nuovo set (ancora senza codice)
      {
         Id = *pNextSetClassId;
         (*pNextSetClassId)++;
      }
   }

   C_STRING _Path(ImagePath);
   gsc_drive2nethost(_Path); // converto path con alias host

   if ((ColValues << acutBuildList(RTLB,
                                   RTLB, RTSTR, _T("GS_ID"),       RTSHORT, Id, RTLE, 
                                   RTLB, RTSTR, _T("NAME"),        RTSTR,   (Name.get_name() ? Name.get_name(): GS_EMPTYSTR), RTLE,
                                   RTLB, RTSTR, _T("DESCRIPTION"), RTSTR,   (Descr.get_name() ? Descr.get_name(): GS_EMPTYSTR), RTLE,
                                   RTLB, RTSTR, _T("IMAGE_PATH"),  RTSTR,   (_Path.get_name() ? _Path.get_name(): GS_EMPTYSTR), RTLE,
                                   RTLE, 0)) == NULL)
   {
      if (Id == 0)
      {
         if (IsTransactionSupported == GS_GOOD) pConn->RollbackTrans(); 
         free(pNextSetClassId);
      }
      return GS_BAD;
   }

   if (pConn->InsRow(TableRef.get_name(), ColValues) == GS_BAD)
   {
      if (Id == 0)
      {
         if (IsTransactionSupported == GS_GOOD) pConn->RollbackTrans(); 
         free(pNextSetClassId);
      }
      return GS_BAD;
   }

   // setto il riferimento di SET_CLASS_TREE_TABLE_NAME (<catalogo>.<schema>.<tabella>)
   if (((C_PROJECT *) pPrj)->getClassSetTreeTabInfo(&pConn, &TableRef) == GS_BAD)
      return GS_BAD;

   C_INT_INT   *pClsCode = (C_INT_INT *) ClsCodeList.get_head();
   C_CLASS_SET *pClsSet = (C_CLASS_SET *) ClassSetList.get_head();
   int         pos = 1, ItemId;
   while (pClsCode)
   {
      // se è un set di classi nuovo
      if (pClsCode->get_type() == GSClassSet && pClsCode->get_key() < 0)
         ItemId = *pNextSetClassId;
      else
         ItemId = pClsCode->get_key();

      if ((ColValues << acutBuildList(RTLB,
                                      RTLB, RTSTR, _T("GS_ID_PARENT"), RTSHORT, Id, RTLE, 
                                      RTLB, RTSTR, _T("POS"), RTSHORT, pos, RTLE,
                                      RTLB, RTSTR, _T("ITEM_ID"), RTSHORT, ItemId, RTLE,
                                      // GSClassSet = set di classi, GSClass = classe di entità
                                      RTLB, RTSTR, _T("ITEM_TYPE"), RTSHORT, pClsCode->get_type(), RTLE, 
                                      RTLE, 0)) == NULL)
      {
         if (Id == 0)
         {
            if (IsTransactionSupported == GS_GOOD) pConn->RollbackTrans(); 
            free(pNextSetClassId);
         }
         return GS_BAD;
      }

      if (pConn->InsRow(TableRef.get_name(), ColValues) == GS_BAD)
      {
         if (Id == 0)
         {
            if (IsTransactionSupported == GS_GOOD) pConn->RollbackTrans(); 
            free(pNextSetClassId);
         }
         return GS_BAD;
      }

      if (pClsCode->get_type() == GSClassSet)
      {
         if (pClsSet->to_db(pPrj, Id, pNextSetClassId) == GS_BAD)
         {
            if (Id == 0)
            {
               if (IsTransactionSupported == GS_GOOD) pConn->RollbackTrans(); 
               free(pNextSetClassId);
            }
            return GS_BAD;
         }
         
         pClsSet = (C_CLASS_SET *) ClassSetList.get_next();
      }

      pos++;
      pClsCode = (C_INT_INT *) ClsCodeList.get_next();
   }
   
   if (Id == 0)
   {
      if (((C_PROJECT *) pPrj)->setNextClassSetId(*pNextSetClassId) != GS_GOOD)
      {
         free(pNextSetClassId);
         if (IsTransactionSupported == GS_GOOD) pConn->RollbackTrans();
         return GS_BAD;
      }
      pConn->CommitTrans();
      free(pNextSetClassId);
   }

   return GS_GOOD;
}


/*********************************************************/
/*.doc gsc_getClassSet_StandardBitmap         <external> */
/*+
  Funzione che restituisce la bitmap del set di classi.
  Parametri:
  bool LargeSize;    Se vero la dimensione della bitmap sarà di 32x16
                     altrimenti sarà di 16x16
  CBitmap &CBMP;     Oggetto bitmap (output)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int gsc_getClassSet_StandardBitmap(bool LargeSize, CBitmap &CBMP)
{
   UINT nIDResource = (LargeSize) ? IDB_CLASS_SET_32X16 : IDB_CLASS_SET_16X16;
   // When resource from this ARX app is needed, just
   // instantiate a local CAcModuleResourceOverride
   CAcModuleResourceOverride myResources;

   HBITMAP hBitmap=LoadBitmap(_AtlBaseModule.GetResourceInstance(), MAKEINTRESOURCE(nIDResource));
   HGDIOBJ obj = CBMP.Detach();
   if (obj) ::DeleteObject(obj);
   if (CBMP.Attach(hBitmap) == false) return GS_BAD;

   return GS_GOOD;
}


/*********************************************************/
/*.doc gs_move_classes_to_class_set           <external> */
/*+
  Funzione LISP che sposta le classi il cui nome corrisponde ad una 
  certa maschera in un set di classi.
  Parametri:
  (<prj><Maschera><ClassSetId>)

  Restituisce GS_GOOD in caso di successo altrimenti restituisce GS_BAD.
-*/  
/*********************************************************/
int gs_move_classes_to_class_set(void)
{
   presbuf            arg;
   int                Prj, Cls, ClassSetId;
   TCHAR              *Mask;
   C_PROJECT          *pPrj;
   C_SINTH_CLASS_LIST SinthClassList;
   C_SINTH_CLASS      *pSinthClass;
   C_CLASS_SET        RootClassSet, *pOldClassSet, *pNewClassSet;

   acedRetNil();
   if (gsc_superuser() != GS_GOOD)
      { GS_ERR_COD = eGSOpNotAble; return RTERROR; } // non è un SUPER USER

   // Legge nella lista dei parametri: progetto classe e sub
   arg = acedGetArgs();
   if (gsc_rb2Int(arg, &Prj) == GS_BAD)
      { GS_ERR_COD = eGSInvalidArg; return RTERROR; }
   if ((arg = (arg->rbnext)) == NULL || arg->restype != RTSTR)
      { GS_ERR_COD = eGSInvalidArg; return RTERROR; }
   Mask = arg->resval.rstring;
   if ((arg = (arg->rbnext)) == NULL || gsc_rb2Int(arg, &ClassSetId) == GS_BAD)
      { GS_ERR_COD = eGSInvalidArg; return RTERROR; }

   // Cerca progetto nella lista GEOsimAppl::PROJECTS
   if ((pPrj = (C_PROJECT *) GEOsimAppl::PROJECTS.search_key(Prj)) == NULL)
      { GS_ERR_COD = eGSInvalidPrjCode; return RTERROR; }
   if (RootClassSet.from_db(pPrj) == GS_BAD) return RTERROR;

   // Cerco il set di classi
   if (ClassSetId == 0) pNewClassSet = &RootClassSet;
   else 
      if ((pNewClassSet = RootClassSet.ClassSetList.Search(ClassSetId)) == NULL)
         return RTERROR;

   if (pPrj->getSinthClassList(SinthClassList) == GS_BAD) return RTERROR;
   SinthClassList.sort_name(); // ordine alfabetico
   SinthClassList.FilterOnName(Mask);
   
   // poichè SinthClassList è in ordine alfabetico per inserire le classi nello stesso ordine
   // parto dal fondo inserendo all'inizio
   pSinthClass = (C_SINTH_CLASS *) SinthClassList.get_tail();
   while (pSinthClass)
   {
      Cls = pSinthClass->get_key();
      if ((pOldClassSet = RootClassSet.SearchCls(Cls))) // se era già inserita in un set di classi
         if (pOldClassSet != pNewClassSet)
            if (pOldClassSet->RemoveCls(Cls) == GS_BAD) return RTERROR;

      // la inserisco
      if (pNewClassSet->InsertCls(Cls) == GS_BAD) return RTERROR;

      pSinthClass = (C_SINTH_CLASS *) SinthClassList.get_prev();
   }

   if (RootClassSet.to_db(pPrj) == GS_BAD) return RTERROR;

   return RTNORM;
}


//-----------------------------------------------------------------------//
///////////////////    C_CLASS_SET  FINE    ///////////////////////////////
